JavaStudy (Source: JavaTPoint)

||Java Basics||
Java is a language and a platform as well.
Now, what do you understand with java as a platform? See, java is a software platform which means that it is the software and specification that is used to develop applications (EE, SE or ME) using the java programming language. Java programming language is a language to develop different kind of application software (any kind means here is for mobile, enterprise, web sites and others). Now, java is computing platform independent where computing platform is the combination of hardware and software. Hardware the literally an intel chip and software is the operating system.  
Java as a language needs a compiler and run time environment which runs it. 
Firstly you write code which is written using alphabets, numbers and special character. However, computer understands only byte code. So, we need to convert our code into byte code. Now, the compiler comes into picture. Compiler is solely responsible for conversion of the code written by you into byte code. JDK is the compiler. JDK is physically present in the computer. Adding one more fact for JDK, which is very important, is that it is just Java SDK. 
Then the byte code needs to run to produce the result of the code written. For running the code we require runtime environment. JRE is the runtime environment for running the code and it is inside JDK only. It too physically present in the computer. There is another thing called JVM (Java Virtual Machine). Java virtual machine is actually a concept which provides java a run time environment which, if taken in details have many important task. JVM is platform dependent and that make java platform independent. That will be explained later.

How actually you run a java program –
Firstly, let’s talk about the most basic way of doing it. 
You write code on a notepad and save it in your workspace in .java format. Then, open the command prompt do some basic stuff like setting the CLASSPATH and PATH. Then, you compile the program using the “javac” command which lead to create the source course file (.class file). Then, you can run your program using “java” command. 
Below are the steps to run your java code through CMD.
1.	Open cmd.Firstly, you have to set the JAVA_HOME and Path. 
2.	Once you do that give command “javac” to check if the environment variables are set properly or not. If javac is not identified then it is not set properly. So try again. 
3.	So we have set the environmental variable which means our computer knows where JDK and JRE are stored. When you open the command prompt, you write everything after a path mentioned. I hope you understand what I mean. That path is the path where the .java and .class files are found. 
4.	To change to location (directory) where the .java and .class files are stored. We have cd command. Type cd which is followed by the new path. 
5.	Then, to compile a program use javac command. Like “javac program.java”. Compilation error come when the code is written incorrect. Exception occurs when an abnormal situation arises.
6.	For running the multiple classes which are dependent. We have to create them and put into one folder. Then, if one file is dependent over other than that file needs to be compiled first. For this, we will compile all the classes firstly and then execute any. Though, this needs more practice but currently out of scope. 
This way you can simply run a java code on CMD.
Important Notes:
1.	How to look for .java files of a project made? – go to properties and check the Location. 
2.	How to change the directory in eclipse? – Just go to file and select change work space. If you want to create a new workspace then just create folder where you want to make work space and copy its path.  

However, as the complexity increases, working with command prompt get difficult. 
So, we use an IDE (Integrated Development Enviroment). Eclipse is an IDE which is mostly used. Other IDE available is the market are netbeans, android studio and etc. 
Summary – so, for compiling the java code we need JDK which is java SDK. After compiling, we need JRE which is present in the JDK itself. Now, JDK can be of SE, EE or ME which are standard, enterprise, micro (mobile) kind of application. Until sometime, we had no option but to use command prompt to write, compile and run code. To escape the pain due to complexity of code, some great group of people invented IDE. So, IDE makes the programmer work easier. Famous IDE for java are eclipse, netbeans (oracle offers netbeans) etc.  

||Properties of java||
1.	Java is platform independent
Java is platform independent means that it can run on any platform (windows, OS, etc) without changing the code. A dependent language will require a change in code when the platform is changed. Now, how is this possible that java is platform independent? The credit goes to JVM i.e. Java virtual machine. As the name implies, it is virtual machine itself which in term means that the java code run on JVM and this JVM is installed on the platform used. Also, JVM is different for different platforms. Here platform isn’t just the operating system but the combination of hardware and software like mac OS with Intel processor. In short, unlike java, JVM is platform dependent. 
Note: I have got a point that since .class file is given to different platform then all should be able to understand the code (actually byte code). Then, what is the need to have JVM. Actually, different platform will not be able to understand the byte code since they do not know about java and so won’t be able to recognize that what is meant by the byte code. So, platform dependent JVM is required. 
2.	Java program are “write one, run anywhere” type code. That again portrays that it is platform independent but in a slightly different way. Let’s suppose you have written a java code on windows and want the same code to run on MAC OS. Then, that code will run smoothly but how? Actually, every machine needs JVM, so that is needless to say that OS will also have JVM installed. So, no matter of which platform written java code you are trying to run on some other platform, it will run because JVM is there to translate and run the code for the platform. 
Note: We have major operation systems which are windows by Microsoft, Mac OS by Apple, LINUX by developer community and iOS platform for mobiles. Hardware (process like Intel, AMD or ARM) can differ by the architecture. So, the different combination of software and hardware makes a different platform.    

||Uses of java||
1.	Creating web application – JSP (Java server pages with normal HTML can create dynamic web pages)
2.	Applets – kind of java program used to add new feature to the Web browser. 
3.	J2EE – use by enterprise to create big web applications to transfer XML structure documents. 
4.	Javabeans – javabeans is mainstream java component model. It is similar to visual basics*. It is also use the number of javabean (a component of java program) to create something new. This is done by visual manipulation in a buildertool. Sun has named that builderbox as beanbox. 
(*visual basics is created by Microsoft for using a GUI to buildsome new using a language BASIC which similar to beanbox.)
5.	Mobiles – many games, service and operating system is based on Java. Most famous and successful java based operating system is android.

||Types of application java can build||
1.	Standalone application – these are also called as desktop application. These are the applications which do not interact with any other application. Examples are media player, antivirus.
2.	Web application – these are also called as server side applications or web site more commonly. These are actually gets stored in server and used by the end user through browser. 
3.	Enterprise application – enterprise application are also web application but are more complex and have more feature. However, technical difference among them is that the enterprise application runs in a special container called enterprise container which have special features like transaction, JMS, etc (I have no clue about these special features). Example – IBM Webshere, oracle IAS, etc.  While the web application runs in a normal web container. Examples – tomcat, JavaWebServer.
4.	Mobile application – these are better called as apps. But before this, java is responsible for the creation of many games, services, operating system (like android). 

||Facts about java||
1.	Object oriented – Object oriented language is object centric. Now, an object is any physical or virtual entity (an object like car, boy, animal). So, every object has some properties and states. The property is defined by the data  
Note: Though some people say that java is not completely object oriented language since it uses the primitive data types. How does primitive data type influence this?
2.	Platform independence – ability to run the code on different set of hardware and software without changing the code. 
3.	Simple – java is simple to learn and implement.
4.	Secure – few of its property makes it secure like efficient security model which do mean that takes care the download of program from untrusted sources through sendbox, no use of pointer i.e. no access to memory locations, exception handling (prevents the crash of the application). Conversion of raw code into java byte code is a key feature and garbage collection, access control functionality to add a few.
Note: Do more research on how exactly these properties of java make it secure?
5.	Architectural neutral – well, at first glance looked like it is an trivial topic but no I was wrong. Being platform independent means that java can work with the same code on any pair of hardware and software for which JVM is available. Therefore, any software (operating system) supports the same code. Similarly, architectural neutrality signifies the ability of java to run of any hardware (processor).
6.	Portable – since java is architectural neutral and platform independent, so its code can be run over any system or processor. So, java code written on any machine can run over other machine with different hardware and software is meant by being portable. 
7.	Multi-thread – as the name suggest, java program can have multiple threads which perform some different task and can run simultaneously and hence ending up better utilization of resources available. Though this topic is not that simple so will study in detail later. 
8.	Interpreted –See, there is a difference in compilation and interpretation. Java is compiled language because it surely converts the java code to java byte code. Right? Now, there are two possibilities after the JVM receives the byte code. First, JVM will interpret it and run it by itself. Second, later invented technique, JVM has JIT (JUST IN TIME) compiler which compiles the code further from byte code to the code understood by the machine (hardware and software). Now, why is the requirement of JIT? That will be answer in the point below.
9.	High Performance – let’s say that JIT is not yet developed and we use the general method java code to byte code and byte code was interpreted and run only by JVM. But JVM is capable of handling one byte code at a time. Now, the JIT is developed and which takes the byte code from JVM and again compile it to the code types understandable to the processor or the machine. So, then the code run more quickly and efficiently.
10.	Distributed – we can create distributed application through java. These distributed application are those which can be used on different computers at the same time and stored in the cloud using cloud computing. 
11.	Dynamic – java is called as dynamic (more dynamic than C and C++) because a lot of run time information can be used verify and resolve access to object. Also, a language is called dynamic when loads the resources at run time. Java loads the byte code at the run time and hence a dynamic language.
Different editions of java –
SE, EE and ME are the editors types which we already know.  

||History||
Well, I guess this much history is sufficient to know the James gosling with his team at sun microsystem invented java in 1992 (named Oak while invention but while patent it was named java). 
Java SE versions – last version SE 8 released on 14th march, 2014. While the next release SE9 is supposed to release in 2016. 
Java EE version – last version released is EE 7 in early 2013 while the next version can be released in 2016 or 2017. 

||Java Virtual Machine|| [III]
Well we know about it already. Because of JVM, java is platform independent, architectural neutral, efficient and have many cutting edge advantages. JVM provides a run time environment. JVM receives the byte code after the compilation and then run the code by itself. But executing byte code is comparatively slower than executing machine language code. This leads the development of JIT compiler of JVM. Now, the byte code is given to JIT compiler at the run time and it converts the byte into machine language code during the runtime and then JVM can execute the code faster. Hence, the process become fast, as processor can run the code faster. 
Java Installation 
Well, if you are running the java program on command prompt then javac is the command for compiling the java program and java for running the program. 
Also, the IDEs like eclipse, netbeans and etc are available in the market which you can use for creating software. I believe that I already know what the benefits of using it are.
Now, after installing eclipse or even using the command prompt, environment variable needed to set up. 
Before looking at how we set these variables. Let’s have a look on what these environment variables are? 
Environment variables are the variable accessible to all the programs running under operating system. These are used for storing the system wide values. In simplest words, a lot a programs on an operating system and need to refer information like which are the file to be executed, where to store the temporary data and similar. So, these environmental variables have such information and for the smooth functioning of the program all the required environment variables should be set. 
Examples of environment variable of windows OS –
1.	COMPUTER NAME AND USER NAME – stores the computer and current user name. 
2.	OS – operating system 
3.	System root – System root directory.
4.	 PATH – a list of the directories for searching executable program (in simplest word, it tells your machine where is the executable program is kept). Now, what is that executable program? In simple words, the executable program is the one which is directly readable by the operating system and these executable programs are in .exe file. For example, javac.exe, java.exe. so, until the operating system finds your jdk (javac.exe) for compilation then how will the program will run. So, setting path is highly important.
5.	CLASSPATH – a list of the directories for searching the java class files (.class file containing the java byte code) and JAR files (a package file of many class files, its meta data and resources to distribute the application on the platfrom). Java compiler and java runtime searches these classpath entries for java classes referenced in your program. 
Difference between PATH and CLASSPATH - 
Does the two, path and classpath, looks same? Yes. But only looks while they are completely different. Path indicates the files which are executable to the operating system (like javac.exe) but the classpath indicates the file which the java compiler and java runtime looks for (HelloWorld.java and HelloWorld.class or any file in jdk or jre). Path is for setting the environment for operating system while classpath set the environment for java (another way of differentiating the path and classpath is that Path is set to locate the jdk and class path is set for .class and JAR file).
	
Now, how to set the environment variable:
This can be done on command prompt or going into computer properties. (jo direct property wala hai wo path set karne ka hai, class path set karne ka nahi).
Note: what is the difference between PATH, javahome and CLASSPATH? PATH is to point location of the executable files of JDK while CLASSPATH is to point the path of the .class file. 

||Hello java program||
I have made the first java program hello world. There are few key words which I need to understand. 
Public – it represent a access modifier which means visible to all. 
Class – keyword to introduce class. 
Static – For main method it is made a rule while creating java language that it must be called static. Its basic reason could be that it can instantiate itself.
Void – no return type. 
Main –main method is mandatory for every class to have.
String args[] – it is command line arguments which are used to take the input typed in from command line/console. It is taken as the input for the program and has better control over the working of the program. Check the program for printing the value of the string.

Note: 
1.	These keywords can change the positions within themselves.
2.	You may or may not give semicolon at the end of the class. 
3.	Public static void all keyword should come while declaring main method.


||Program internal|| 
Although, we know the process of how a code is compiled and executed. However, there are few things to add. Compilation byte code gets created. This is nothing but “.class” file.  Now, there are a few process happens during run which I feel is much of depth then the scope of the topic. But we should at least know that JVM then interpret the byte code and run the code. If not that, then JIT will compile the code again and machine itself will run the code. 
Some questions:
1.	Can we save a source file by other name than class name? Yes. If the class is not public and the compiled byte code will be at the class name anyway. 

||How to set path||
Again, we do know already how to set path variable and why is it important. 
JVM, JRE and JDK 
We already know all this.

||Internal details of JVM||
Well, JVM basics we already know that it provides run time environment. Also, it is platform dependent and that why java in platform independent. However, if we further simplify its function than we can say that it has to load, verify, execute and provide runtime environment. 
It also deals with memory, garbage collection heap. Also describe about JIT. 

||Variable and Data Type||
Variable – Variable are nothing but the memory locations which can hold data. They are of three type local, instance and static. 
Local Variable – well, these are written inside a method, constructor or a block. Local variable is only visible only within the declared method, constructor or block. They do not have any default value so they must to be initialized before accessedi.e. to be assigned an initial value.
Instance Variable –these are written outside the method, constructor or a block. These are used when a certain variable we require in many methods in the class (local have scope only to one method). Whenever object is created, memory is allocated to instance variable as well. Same happens when the object is destroyed. Instance variable can be declared before and after use and have some default values. These can be made public or private.
Static Variable – these are also declared inside the class but outside any method, constructor or block but uses static keyword. Now what is the need of static variable? Everything has its own purpose. An instance variable declare in one class cannot be used in the other class, but if we write static before the instance variable then it becomes static variable and can be used in other class without creating the instance. Static variable are not much used except they are made constant with the use of FINAL keyword. Static variables also hold the default values same as instance variable. Also, the static variable is one for the entire class so save memory. Static variable cannot access instance variable. Check static keyword section that has better explanation. 
Note: 
1.	local variable does not have the default value while instance and static variable have. Therefore, we must give some value to the local variable before using it. The purpose of giving default value is to avoid the program to go in an unstable situation. Because if no default value is set and no value given explicitly to the variable and if used then the program will go into unstable condition.  
2.	[III] Can we have same name static and instance variable? We cannot have a same name of a static and instance variable in the same scope. Like, local variable can have same name as instance or static variable is but vairables in the same scope cannot.

||Data Type||
Data is basically of two types which are primitive and non-primitive. Primitive (boolean, char, byte short, int, long, float, double) are those which are predefined data type while the non-primitive (string, array, etc) are those which are derived by the primitive data type. The non-primitive data types are those which refer to an object which can contain some data. String, array, Integer (all wrapper data type), creating object of the classes and many more are the non-primitive data types which are highly used in java. 
Java literals – they are represented directly as a constant value without any computation. Like, int a = 1;.
Another important thing here is that the integers can be expressed as octal and hexa decimal. For example, int octa = 0114 (0 indicate base 8 i.e. octal) and hexa decimal ass int hexa = 0x1144 (0x indicates hexa dcimal). 
Also, learn the special escape sequence used in java - \n, \r,\f,\b, \s, \t, \”, \’, \\, \ddd, \uxxxx 
\n = new line, \r = carriage return i.e. at the beginning of line, \f = form feed i.e. at the beginning of new page, \b = backspace, \s = white space, \t = tab, \” = print quote, \ddd = Octal character and \uxxxx = Unicode.
Unicode system
Well, for the standardization of all languages, Unicode was created which is followed by all languages. Actually, there are many language standards like ASCII, KOI-8, ISO 8859-1 which are American, Russian and Europian language standards. So, according to the place the character code change and so we got Unicode which are used as standard everywhere. 

||Operators in Java||
Arithmetic operator – there are basically 7 arithmetic operators. Then, total of 6 relational operators. Until here everything looks fine. Then, bitwise operator comes in picture. They have &, |, ^, ~ and shift (left, right, fill zero right shift). Let’s have a close look at the shift bitwise operator. 
1.       Left shift – operand is 5: 0101. Operation to be performed is operand << 2. This command means to shift the number of bits left side the number that you mentioned (2 is the number of shift in this case). The answer will be 10100.
2.      Right shift – Simple right shift symbol is “>>”. It is different for positive and negative numbers. With positive number, it simply sift the bits the number of times it is asked. If we have to right shift a negative number then we shift the bits as the number of times mentioned and the places that become vacant on the left side will be filled by 1’s. Check examples through the link. 
3.       Fill zero right shift – This is shown by symbol “>>>”. This is also different for positive and negative numbers. With positive numbers, it simply shifts the number as right shift.  But, it behaves differently with negative numbers. It shifts the bits as the number of times asked and fills the left side vacant position with zeros.  
(For explanation checkhttp://www.javaranch.com/campfire/StoryBits.jsp).
Logical operator– These are logical operator which are three types. 1. Logical AND - if a is T and b is F. then, the normal And table is studied earlier will make a && b = F. 2. Logical OR – normal OR table will make a OR b = T. 3. Logical NOT. If a is T. Then, !a will be F. 
Assignment operator – they are basically of 11 types but easy to understand. 1. =, 2. +=  (a+=2 means a = a+2), 3. -= (a-= 2 means a = a-2), 4. *=, 5/=, %= (a%=2 means a = a%2), <<= (a<<=2, means a = a<<2), >>=, &=, ^=, |=. X`
Note: a^=2 is a=a^2. This is means as XOR for a and 2. Here, 2 is not the integer 2 but we have to operate the bits equal to integer 2. 
Miscellaneous operator –
1.    Conditional Operator (?:) – lets learn it through an example. A = (b==2)?20:30; which means that A will be 20 if b==2 and A will be 30 if b is not 2. 
2.    InstanceOf Operator – this instance of operator is used for reference data types. This only checks if the data belong to a particular reference data type or not (like String, Array, etc) and produce a Boolean result.  For example – first a string name is declared and instantiated as “John”. Then, Boolean result = john instance of String. Result will be true. Example 2, Vehicle obj = new Car(). (vehicle is parent class and car is child class and this is called as upcasting) then, Boolean result = obj instance of Car. Result true. 
3.    Precedence of java operator – check the precedence of the operator in an expression. Though, this is not a thing to learn. 

Frequently asked Java Programs
These are some frequently asked java questions.
1.       Fibonacci Series – using recursion and without recursion.
2.       Check prime number 
3.       Check pelindrome number
4.       Print factorial number 
5.       Check Armstrong number 
6.       Sort an array using bubble sort algorithm. 
7.       Selection sort 
8.       Insertion sort 












Java OOPs Concept 

||Advantage of OOPs||
The advantages of OOPs languages are its special features such as abstraction, encapsulation, inheritance and polymorphism. We have taken a glance at what these feature are all about and their advantages. There is something called as object based programming language (Javascript, VBscript) are different the OOPs only as do they not have inheritance feature. Else both are same. 
Please answer DO YOU KNOW section.
Do You Know ?
•	Can we overload main method ?
•	Constructor returns a value but, what ?
•	Can we create a program without main method ?
•	What are the 6 ways to use this keyword ?
•	Why multiple inheritance is not supported in java ?
•	Why use aggregation ?
•	Can we override the static method ?
•	What is covariant return type ?
•	What are the three usage of super keyword?
•	Why use instance initializer block?
•	What is the usage of blank final variable ?
•	What is marker or tagged interface ?
•	What is runtime polymorphism or dynamic method dispatch ?
•	What is the difference between static and dynamic binding ?
•	How downcasting is possible in java ?
•	What is the purpose of private constructor?
•	What is object cloning ?

||Java Naming Conventions||
These are not rules which mandatory to be followed but are conventions to make your code standardize and easy to understand. Now, just be a little careful with starting a name with upper case or lower case. Also, use camel casing. That’s it. 

||Objects and Classes in Java||
Object – An object has three properties which are state (data or variables), behavior (method) and identity (object identity is implemented by unique ID, infect as a class can have multiple object and but always every object is unique). To relate an object to a class, we can say that an object is an instance of a class.
Class – A class is a group of objects having similar properties. For example, a student class can have object as S1. Here, student class can have n number of student but an object belongs to a unique student. A class has data member, methods, constructor, block, class and interface. (Here you can see that a class can be contains in another class which means that class nesting is possible. However, method nesting is not possible in java).
So far the difference between a class and object is clear. (nahi hua to ek bar sunnle hindi mai, ek class agar student name ki hai to wo koi particular student k bar mai nahi hai balki group of student having same properties like name, roll name, college name. lekin jo object hai wo ek unique student k bare mai. Isiliye ek class mai multiple objects ho sakte hai). Practice the programs for declaring the object and simply displaying its values. Second, declaring object and first passing value to one method and displaying through other method. 
Anonymous object – if we have to create only one object than use anonymous object. It’s like “new Student()”. It may be used as Class c = new class(new student(system.in)). Creating multiple object in one statement – “student obj1 = new student(), obj2 = new student();”
Note: “An object can be physical or logical but a class can be logical only”. Firstly, many people do not accept these terms logical and physical in regard to classes and objects. But, others do. Classes can be understood logical because they just contain the logic of processing the data while object can be logical and physical because they actually contain the data in the memory. But there is another argument. Class also resides on the memory otherwise how they can exist. In the nutshell, it is quite ambiguous. 

||Method Overloading||
Method overloading is having multiple methods with the same name but with different parameters (here parameter is different in terms of number of arguments and types of arguments). There are three ways of overloading which are –
1.	Through number of arguments 
2.	Through type of arguments
3. 	Shuffling the parameter of same data type
We cannot do method overloading with the return type of the method, if did so will give compile time error. The return type overloaded methods can be different. Method overloading is also the compile time overloading. 
Now, can we overload main method? Yes, we can. But main method with string args[] will run first because it is the entry point of any class.
TypePromotion – well, this is something interesting. Let’s say that the arguments are int and long. But, the inputs given in main method were int and int. then, also argument will be accepted, even if exact match was not found. Some set of data type can be promoted to other. 
Benefits of Overloading – There are two advantages which I tracked. First, it is definitely good to remember the methods have the same function but accept different set of parameters. So, you have to remember lesser names. It really helps developers in big applications. Second, we can have different types of constructors. Without method overloading we could not have multiple constructors of a class.  Also, it saves some memory. The logic behind this is the byte code of all the overloaded methods set is same. However, some people deny this as well. Infect, I also do not think so.
Note: 
1.	We can overload a static method but we cannot override it.
2.	What is operator overloading and why is it not possible in java? Operator overloading is having different meaning of a same operator. This is not possible in java. It is done to avaoid complexity and bring simple and clean implementations. 
3.	Return type in overloaded method can be same or different. However, return type alone is not sufficient for compiler to identify the method of be called.  
4. [III] We can do overloading of private, final, abstract and static method. Remember!

||Constructor||
Constructor is the special type of method with the name same as class name and does not have a return type. They are of two types which are default and parameterized. 
Default constructor–A constructor with no parameter is known as default constructor. The default constructor is used to create an object of the class. If we do not create any constructor by our own then the compiler creates a default constructor with empty body which then used to create objects. Constructors are also used to give initial value to the data member of an object. If your main method does not have an object created (through constructor), then you cannot call any non-static method or variable of the same class. So, constructor is very important in java.  
Parameterized Constructor – A constructor with one or more parameters is called as parameterized Constructor. We can pass values to the variables of the constructors. (Though, I found that that’s not the only way). When we declare constructor in class, default or parameterized, the compiler does not declares a constructor itself (that is because the constructor provided by the compiler is empty body while even if you write your own default constructor with body then compiler may get confuse). We can also use parameterized constructors for creating object.  
Note: [III] An advantage of constructor over a method is that we do not need to call it explicitly. Also, we can change the value of a final variable (with no value set) using a constructor (default or parameterized).
Constructor Overloading – this also done the same way we do method overloading. Either the number of argument or the type of argument is different. 
Copy constructor – Chaho to kya nahi hai assan! Well, I had spent around 2 hour to just understand a topic called copy constructor. At some point in time, I felt that I should leave it for now and move forward. But, I understood at last. In copy constructor, we create a simple parameterized constructor to invoke the instance variables. Then, we build a copy constructor which has the argument as the obj type (look at the example at javatpoint). Now, first constructorpasses the argument and first result is displayed. Then, we pass the first obj in the second obj that invokes the copy constructor and mystery solves here. The invoked copy constructor will pass the object one and display it again. 
Also, check the way for copying the object without copy constructor.
Note: 
1.	[III] Can we call child constructor from parent? There is no way of calling child constructor from parent class constructor. 
2.	[III] Can constructor have any return type? Constructor cannot have return type. If you have method with the same name of class and have return type then that would not be called constructor. Compiler will give a warning. [IIII] You can write void with it then it will be considerd as normal method rather than a constructor. 
3.	[III]Difference in default and no args constructor? Default constructor and no-args constructor are not exactly same. Default constructor calls the super class constructor thus its body has super(). The exception here is a primordial class which does not has any super class like object class. While the No-args constructor is wrote by dev and overrides the actual implementation of default constructor. 
4.	[III] What are valid access and non access modifiers with constructor? No other access modifier is allowed with constructor except public, private and protected. 

||Static Keyword|| 
The Static keyword is used for memory management in java. It can be used with a variable, method, block or nested class. We cannot use it with the outer class.
1.	Java static variable – Whichever variable stated static will have same value for all objects of a class but will be declared only once while loading the class. When its value is changed then all the objects will use the changed value (instance variable can have different values for different objects). To make the value of the static variable constant and does not allow it to change later, we require final keyword. Also, Static variable can be called in the main method of the same class in which they are declared without creating an object(object needed for instance variable) and in other class of same package without creating any object but with the class name. Instance variable cannot do this. Practice counter variable with and without static keyword. Another very important aspect of static variable is shown with these count programs. Static variable are associated to the class but not with the instance. So, they get the memory at the time of class loading and they retain their value even after the new object is called. 
2.	Java static Method – Similar to a variable, a static method also belongs to class rather than object of class. A static method can be invoked without instance in its class and in the other class like this “ClassName.StaticMethodName”. Static method can access the static variable and change its value. We cannot directly use non-static value in the static methods including main method. We have to create an object of the class and then call the instance members through the object. 
3.	Static nested classes and static block – nested class can be made static and they cannot have non static variables and methods. Static block are the special blocks use to initialize class and executed according to the order they are written in. Try and collect more information if interested. Static block also cannot use the non-static value. 
Note: 
1.	Why we make main method static? There are few logics behind why we have main method as static. First, if it is not declared static then we need to create an instance for calling the main method as well. Second, java language is designed in such a way that we need to have main method as static. Thirdly, main method is an entry point for the class. Then, it will be of great help it can be instantiate itself.
2.	If you do not want to use the object rather just want to run the default constructor written by you then just write this “new Constructor()” instead of complete sentence.
3.	A top level class cannot be declared static while an inner class can definitely be declared. 
4. [III] Can an abstract method be static? An abstract method cannot be static while an abstract class can have static variables. If you make abstract method static then how do you think to override them? 

||This() Java Keyword||
This keyword is a reference variable which refers to the current object. In tutorial, we have given 6 usage of this keyword but suggested to do only first two for the beginner. 
1.	This keyword is used to refer to the current object instance variable when the argument (parameter) and the instance variable are named same. 	Check example for clarity. 
2.	This keyword can be used to invoke any of the current class constructors. In simple words, to call one constructor from the other constructor using this() keyword. This is also called as constructor chaining. Well, if your understand the difference between this(something inside or not) and this.something then you will understand the trick. “This ()” means calling the constructor with no parameter. Similarly, this(int a) means calling a constructor with int a as an argument (Parameter). Now, “this.something = something” means some (ex-city) variable of the current constructor is equal to the something (city) variable. This() should be the first statement if used. 
3.	We can use this keyword for calling a non-static method is other non-static method. Though, this can be done without this keyword or without anything else.
4.	This keyword (without “.” or “()”) can also be used as a parameter for a method (object type parameter). In such case, the parameter is class type. Check the example for better understanding. 
5.	This keyword (without “.” or “()”) can also be used for using the object of one class as the parameter in the constructor of other class and passing its object. Suppose when one class calls a constructor of other class and passed this keyword as parameter then through this keyword other class would be able to use variables of the original class. Check the example for better understanding. 
6.	This keyword can be used to return an instance of class. Check the example.
Note: 
1.	[III] This() calls the constructor of the class with no parameter and must be used as the first line of a constructor. This keyword can be used anywhere. 
2.	Better expressed: “this keyword is used in constructor to differentiate between same name instance and local variable”.
3.	[III] Usage with static member with this! We can call static and non static members through this keyword inside constructor and non-static methods and nonstatic blocks. However, we cannot call static member or nonstatic memebrs using this keyword inside static methods or blocks. This is because this is treated as reference of current object, but we should have object at the first place. Notably, we can call static or nonstatic members from static methods or blocks by first creating an object and then using it. Bottomline, we cannot use this in static method or block to access any kind of variable, rather we have to create an object first. 
  
||Inheritance||
Well, we already know about the basics of inheritance that a child class can use the methods and variables of the parent class. This offers code reusability. This is attributed as IS-A relationship(sub class IS-A super class i.e. if programmer is extended by employee then, programmer is an employee shows the IS-A relationship). Along with code reusability benefit, we also get benefit of implementing the run time polymorphism called as overriding. Extend keyword is used to inherit the super class by the sub class. We can call the method of the super class directly by the object of sub class or by the super keyword in the non-static methods. 

How to actually use members of parent class? Let’s say a class Father has one default constructor and two methods, method A, method B and static method C. Class Son extends the class Father. 
1.	Now, without creating the object of father, if Son wants to use the constructor of Father then it can be used this way “super()” and super() only be as the first statement of constructor of Son. The constructor call must be done in the constructor only. 
2.	Son has overridden amethod of Father but still want to use the father’s implementation of the same method. This can be done by using the “super.methodName()” without creating father’s object. But, it can be done by creating the father’s objectin main method.
3.	Son can use the method which it does not override without creating father’s object is by super method in any non-static method. Also, in main method by fathers object. 
4.	For accessing any static method (obviously not overridden), it should be used by both class objects.
5.	If father class wants to use the unique method of son class, then it could only be done by creating a downcast or creating an object of son. We cannot use simply by the object of father. Same goes with static method as well. 

There are three types of inheritance allowed in java through classes which are single, multilevel, hierarchical while multiple and hybrid inheritance is not allowed. Single inheritance is done when one class extends other class, multilevel inheritance occurs when a class extends a class and that class extends some other class, hierarchical is done when two classes inherits a single class to form a hierarchy, when a class inherits multiple class it is called as multiple inheritance and for hybrid check diagram. When a class inherits two classes then the two classes may have same method and when child class calls it then it will be ambiguous to call method from which parent class. So, even when to try to inherit two classes, a compile time error will be generated.
Note: 
1.	We do not allow multiple inheritance (explained in interface section) through multiple classes but with interfaces. Also, we can simply use any method of the super class without implementing them. This happens in abstraction.
2.	We should not think of inheritance as class extending class but it is also about implementing an interfaces.
3.	In multilevel inheritance, let suppose class b extends class a and class c extends class b. Now, class a and class b inheritance will be same. If class c can call the class a constructor by creating an object and can call the constructor of class b by creating an object or by using “super()” keyword. If class c wants to use the class b implementation of overridden method of class b then use super keyword otherwise create an object of class a for class a implementation of the same method. Class c can call the unique method of class a by creating its own object as well just like class b. Lastly, class c can call the static methods directly of any of the class a or b. [III] Super keyword gets you the members of the immediate super class in the multilevel inheritance. 
4.	In hierarchical inheritance, class a is extended by class b and class c. The relation between class a with class b and class c will be same as a single inheritance. 
5. [III] Can subclass access private members of super class with super keyword? Sub classes cannot inherit the private mebers of the super class. 

||Aggregation in java||
I must say that aggregation is similar to inheritance. It is one directional association between two classes. They share HAS-A relationship. The need of aggregation is also for code reusability (like inheritance). For example, one class is a square of a number and other is for finding the area of the circle. So, the square class can give the square of the radius to help calculating the area of the circle. However, area class cannot help square class in anyway. So, they have one directional Has-A relation. Try an example.
Note: Inheritance – “Car is an automobile” while “Car has an engine”. So, the other class in aggregate is a part of the original class and has no meaning individually. Sometimes, we can use both of them (inheritance and aggregation) then how to decide that which one to use. For this, if we want a polymorphic condition then choose inheritance and when you just want a class to give certain result the other class can use then use aggregation. However, inheritance is difficult to undo after lot of development is done in an application because it affect will be more than aggregation.  

||Method Overriding||
Method overriding is the runtime polymorphism. When sub class has a method with same name but with different implementation as the parent class, then it is called as method overriding in java. The parent and the child class must have a IS-A relation (Inheritance). 
Now, let’s understand the need of method overriding. Suppose a class extends a class and overrides any of its method. Now, if the sub-class wants to give some specific functioning to the inherited method related to it (the sub class), then method overriding is the only way.
Note: 
Question 1 – Can we override a static method? We cannot override a static method.  This is because polymorphism is allowing the different instances (cat, dog of animal) to implement a method of parent class in different way. However, the static method does not belong to any instance. So, we cannot do this. We can change the return value of the same type in sub class.
Question 2 – Can we override the main method? No, we cannot override a main method. Firstly, main method is always a static method. Also, it belongs to a class and only that class it is written in. This is how it is made while creating java language. While creating java language it was decided that the only way to startup your application (or class) is main() method and it belongs to that class as entry point. Also, overriding the main method does not give any sense.
Question 3 – Difference between overloading and overriding? It is like comparing oranges with apples. We already know the implementation difference in overloading and overriding. However, the purpose of overloading is improve code readability and overriding is to provide different functionality in the sub class. Overloading is compile time polymorphism (which means overloaded method can be identified at the compilation time) while overriding is run time polymorphism (difference or selection between the overridden methods is seen in the runtime). [III] Return type can be same or different in overloading while must be same in overriding (only till java 5).  



||Covariant Return Type||
Before Java 5, the return type of two overridden methods must be same. However, we can override two methods with different return types after java 5 but the return type of parent class method implementation must be non-primitive type and sub class implementation must return its own type(Sub class type). Also, the covariant return type should be narrower to the original return type. Understood the concept but not able to confirm on eclipse. 

||Super Keyword||
The super in keyword is a reference variable and is used to refer immediate parent class object. 
Below are three usage of super class –
1.	For referring the immediate parent class instance variable – let’s suppose that parent and child class has one instance variable with the same name. Now, when the same instance variable was printed then by default the instance variable of the child class will be printed. To print the parent class instance variable, we will need super keyword. Aur ha, “super” ka s capital nai hai.
2.	To invoke parent class constructor – super() will invoke the parent class constructor in the child class. Though, even if you explicitly do not invoke parent class constructor, compiler will still invoke one, that too before the child class constructor. Parent class constructor using super() can be invoked in sub class constructor only, but not in any method (not even in main method). 
3.	To invoke the parent class method – simple by “Super.MethodName”.Interesting hai kark dekh. Write super keyword as first statement in the method. 
Note: [III]
1.	Usage of super with static member! Super keyword works just like this keyword. Super keyword can be used to call static or non static members of parent class in child constructor and instance methods. However, it cannot be used in static methods or static blocks to get static or nonstatic variables. Notably, we can do this by creating an instance of parent class and using it. 
2.	Is it good to use static member through super or this? Although, we can use static member of parent in child class with super keyword but it is discouraged and if done so then we will receive warning from compiler saying we should be accessing static member in static way. Preferably, we should use it like ClassName.static. 

||Instance Initializer Block|| [III]
A block in java is nothing but multiple statements written inside braces. They are called before a constructor is called. Also, they are called everytime any constructor is called. Instance initializer block is something special and its primary task is to instanciate instance member before even the constructor is called. It is also called before a constructor is called like ordinary java blocks. In case if the class extends other class then super() method will be calling the parent class constructor first followed by instance initializer block and then rest of the methods called explicitly. Also, see the example for the better understanding of the topic. Remember all the rules. Parent IIB, Parent Constructor, Child IIB, Child Constructor is the flow. 
Note:
1. They are called before main method so that all the variables must be initialized before they are used. 
2. What is the difference between static and non-static initialize block? Static block are used to initialized static variables and is loaded only once the class is loaded. They are different from instance initializer block. 
3. Why would you want to use IIB if constructor too can instantiate instance member? In case, if you do not have use of constructor beside instantiating instance member then its better to use IIB. We will mostly use constructor for instanciating instance variable when values coming as arguments of constructor. 

||Final Keyword||
We will take two cases where a variable is declared final and initialized final. Whenever a variable is declared final (I mean declare but not initialized. Alright?), then its value is finalized as 0 (default value for intiger). But we can change its value through parameterized constructor. Now, if a variable is initialized by making it final then there is no way of changing its value except static block. Also, if the variable is static then static initialize block does the same thing as parameterized constructor.   
Final method –We cannot override a method when Final keyword is used with it. It is written in the signature after public or static and before void. Try it. It is pretty simple. [III] we can overload final methods though. 
Final class – [III] If a class is made final then it cannot be extended by any other class. String, stingbuffer and stringBuilder classes are final classes. 
Extra information – Arguments can also be made final. Then, these argument values cannot be changed. 
Note – 
1.	Can we declare a constructor final? No, we cannot use final keyword with constructor.
2.	[III]Affect on applying final keyword with array or collection? Using final with arrays or collections does only impact that you cannot assign new array or collection while everything else works the same way.
3.	[III] From java 8, we cannot place non final variable inside an anonymous class. 
4.	[III] static final variables are known as constants. Also, these are thread safe as you cannot change them.	

||Runtime Polymorphism||
Before understanding about runtime polymorphism, we should know what is polymorphism? The most general meaning of polymorphism in java is that the methods with the same name can have different actions or forms. It is possible only through polymorphism. Polymorphism is of two types which are Compile-time polymorphism (Overloading) and Run-Time polymorphism (Overriding). 
1.	Compile-Time Polymorphism – The compile time polymorphism allow methods with the same name having different internal structure and perform same/different actions in the same class. The difference in the same name method here is of the number and type of parameters they have. It includes constructors as well. The same name methods that have different versions are called as polymorphic methods. Also, the compiler got to know that which version of the polymorphic methods to call during the compile time only and thus it is known as compile time polymorphism. Check example.
2.	Run-Time Polymorphism – The Run-Time Polymorphism allows a method to have different actions in the classes extending the class in which they are defined. This way a class can have some implementations of its own while adding some generic behavior of the class extended or the interface implemented. Compiler gets to know which version of polymorphic method to call during run time only. Thus, it is called as run time polymorphism. Check an example.

Casting – when a class B inherits the class A, then instance of class B is used as object of class B but as well as for class A. This means the object of class B can access the members of class A as well. For this we do not need to do casting (sometimes people still do upcasting). Now, the instance of class A is object for class A but not for class B. This means the object of parent class cannot access the members of child class. So, for using the instance of class A for accessing the members of class B, we do a casting called downcasting (object A casted for class B). It is checked at run time. If the object of class A actually belongs to class B otherwise an exception is thrown which is classCastException.

Look at its types –   
Upcasting– It is a process where the object of the child class gets the label of the parent class. This means the child class can use members of parent class. Syntax: Parent p = new Child(). However, this is not required to be done explicitly and is done automatically. 
[III] Downcasting – I have taken a lot time to understand this concept. Though, it is better now. Below is the way we do downcasting. 
/*if we do downcasting using p1, then we will get classcastexception during
		 * runtime while using p will do valid downcasting*/
		ParentClass p1 = new ParentClass();
		ParentClass p = new ChildClass();
		((ChildClass)p).childInstVarible=10;


Question – runtime polymorphism mai asia kya hota hai ki wo runtime mai hi hota hai aur aisa aur same with compile time polymorphism. 
Answer – I have a little justification to offer. Check http://www.studytonight.com/java/dynamic-method-dispatch.php for the example of dynamic method dispatch or runtime polymorphism. In this case, “gm.type()” at compile time will look like referring the game class object but at run time it will refer to child class object. Now, why not it can be detected at compile time is because at compile time the syntax of the code is checked.

Note –
1.	Difference between declaring and defining a variable, method and class specifically in java. In java, classes are declared and defined at the same time. Method, if abstract, are declared but not defined. Normal methods are like classes i.e. they are declared and defined at the same time. Variable are declared like this “int a;” and declared and defined like this “int a = 10;”.Please check this, if needed: http://stackoverflow.com/questions/11715485/what-is-the-difference-between-declaration-and-definition-in-java.
2.	Static and Dynamic typed language – Static typing is the one in which the variable is needed to be defined/declared (the data type) before use. For example, writing “a=10” before declaring that a is of which data type i.e. int a or double then a will give error at compile time. Also, writing “int a = 10” is fine because you have declared the type at the time of defining. While the dynamic typed language can use the variable before declaring the type which means writing “a=10” will not give error before declaring a. Now, some people advocate the declaring the variable type (static typed language) is an essential requirement for any programming language and other says that using variable even before declaration saves time coding. 
3.	Strong and weak typed languages – strong typed languages are those which will give error at the compile time if similar to this happen “char a = 10”. This means that “a” is char and giving int value to it will give an error at compile time. While in weak language, no error arises in such situations. 
4.	Java is static and strong typed language.
5.	Suppose, we have created an object of child class with child class reference. Now, we can call any method of parent or child class (overridden or unique). Now, if we have created object of parent class with the reference of parent class. Then, we can call all parent class method and variables. But we cannot call methods and variables of child class with this object. Even the common variable will also get value given in parent class. To do this, do downcasting.
6. [III] During runtime, if an object is not able to be casted to other type then classCastException is thrown.
7. [III] if reference of parent class points to the object of child class and calls a member of parent class  in parent, then parent member version will be called. If any member present in child is called then classCastException will be called since it needs to be downcasted.


||Static and dynamic binding||
Connecting a method call to the method body is called as binding. They are of two types, namely, static and dynamic. In static binding, the type of object is checked at the compile time (whether object is of parent or child class). In dynamic binding, the object types get to know at the runtime only. Check examples for better understanding. Both static and dynamic binding can be seen in java.
Note: In the example of static binding, the class does not even extending any class. So, only one type of object is available. So, it is known at compile time only. 

||Instanceof Operator||
Java instanceof is used to test to which class an object belongs to. It is also called as comparison operator the instance with type. It is very simple yet interesting. Please try it. If we apply instanceof operator for null object (parent obj = null), then test will always come false. We already know how to do downcast. But we can downcasting involving the instanceof operator. This is done by create an object of child class in the main method. Then do upcasting. In any method, pass the upcast object as parameter. Finally, apply if condition and downcast it back. It is best to check the example. I have done an example and it was downcasting pretty well. Also, the instanceof works with object data types and wrapper classes. 
[III] Whats the syntax for using instanceof variable. Syntax: System.out.println("s" instanceof String);

||Abstract Class in Java||
A class that is declared with a key word abstract is called as abstract class. It can have abstract and/or non-abstract methods (Concrete method). Abstract methods are those that do not have body. Also, we put semicolon after declaring an abstract class. 

Abstraction – Abstraction used to hide the implementation and only showing the functionality. Abstraction can be achieved by abstract classes and interfaces. 
1.	Abstraction through Abstract classes – A class extending an abstract class must implement all its abstract methods otherwise should use abstract keyword in its signature. Abstract class may also contain the constructor and simple methods which may or may not be called in the main method. Abstract keyword is also used in the signature of the abstract method. It is not compulsory to implement all the abstract methods of the class extended, but then the extending class must also be use abstract keyword in its signature. Abstraction through abstract class is less than or equal to 100%.
2.	Abstraction through interfaces – A class implements the interface must implement all the method of the interface otherwise use abstract keyword in its signature. A class extending the class A can only implement the left over methods of interface which are not implemented by class A. Abstraction through interface is 100%.
Note(s):      
1.	Why abstract classes cannot be instantiated? No. This is because of the simple reason that they have at least one abstract method and that makes them incomplete. If they are instantiated and any of the abstract method called then what the compiler will do? So, to avoid such condition the abstract methods are not instantiated by rule. 
2.	What advantage abstract classes have over interfaces? Interfaces do not implement any of its method whereas abstract classes may implement some of its methods. Suppose class A and class B, both implement an interface first. There are some methods of interface which are implemented in same way in both class A and class B. However, by implementing an interface both have to implement that method need to be implemented in both the classes separately. So, we need to write the same code in both the classes. In real situations, thousands of classes implement the same interface. Then, we have to write the same code thousand times. Here, abstract class can help. Abstract class can implement those methods which will have same implementation in all the sub classes and keep those methods abstract which will be implemented differently in different class.
3.	What is virtual class? Virtual classes may be the one that has virtual method. Virtual method can be overridden inside the class inheriting the virtual class. There is not keyword “virtual” in java language. However, all the methods except static or final which can be overridden are virtual method by default in java. In the nutshell, all the classes which have methods that can be overridden are classed virtual classes. 
4. [III] Can an abstract class have a constructor? Yes, but if you try to use to create an object of abstract class then it will give compilation error. Some may ask the point of having ocntrcutro when you cannot instanciate a class? We can only use this constructor chaining (called from its subclass). You might chain this constructor from the concrete class constructor. It can still be used to instantiate common variables among abstract class and concrete class. 
5. [III] Even when the Abstract class does not have an abstract method then also we cannot create an instance of abstract class.
6. Whatever that stops an abstract method to be overridden like making it final, static or private is not allowed because of the simple reason that it stops it to have an implementation. 


||Interfaces|| 
Interface - Interfaces are the blueprint of the class. An interface contains only abstract methods unlike abstract classes and hence, gives 100% abstraction. Interfaces also support the multiple inheritance and loose coupling. The variables in the interface are public, static and final and methods are made public and abstract by default.The variable of interface is made static because they cannot be instantiated so it should be made static to be used without instance and final because the programmer cannot change the value of variable of interface. An interface can extend other interface. You already know about abstraction through interfaces. 
Let’s study multiple inheritance (which tells you the need of interfaces and advantage over abstract classes) and loose coupling.
Multiple inheritances –Multiple inheritance means one class extending or implementing (inheriting) more than one class or interface. Multiple inheritance with abstract class is not possible because a method which is implemented in both the classes which are extended and if that method is called by the extending class then it will be ambiguous to call which class method. Still confused? Check this: http://beginnersbook.com/2013/05/java-multiple-inheritance/
Now, what makes interfaces allow multiple inheritance. Every method in an interface is abstract. If a class implement multiple interface and suppose all interfaces have a common method A. When this common method is called in the sub class it will not create a situation of ambiguity as in abstract class because no interface implements the method. Every method is implemented by the class implementing the interfaces.
Marker or tagged interface – These interfaces do not have any member (neither data nor method). These are very few and we do not create them. Infect, the recent versions of jdk not required to use these marker interfaces. But for knowledge perspective, these are used just to give some information to the compiler. For ex – serialization marker interface gives an idea about the implementing class. 
We can have nested interface as well. (like nested classes but nested method is not possible!)
Note: 
1.	An interface extends other interfaces (not implements). It does not extend classes.
2.	Can we instantiate interface? No. we cannot instantiate an interface because they do not have any implementation of the method so no point of instantiating them. Though, in one situation they are instantiated. While creating the anonymous inner classes. These anonymous classes override the methods of interface. 
3.	What is loose coupling? When one method does not depend on other method much then the coupling is loose. Interface lets a class to interact with a class through it and use its methods which are nothing but the implementation of the interface methods. So, other classes can still be used if the implementation is later changed. This lessens the dependency and makes the code easy to maintain. 
[III] The best example of loose coupling provided by interface is using List<Integer> list = new ArrayList<>() and method(List list). Here, we can just change the implementation of the list while keeping all the code same. This is because both the classes must have implemented methods following same signature as in interface.  
5.	[III] Can interface have private members? Interfaces cannot have private members. It is an illegal modifier. 
6.	[III] If a class implements two interfaces and both the interfaces has variable with the same name. Will the class implementing both the interface be able to use that variable? if the class is trying to use that variable then a situation of ambiguity will arise since its ambiguous to use whose variable. In this situation, we will get compilation error saying the field is ambiguous.
7.	[III] Interfaces do not extend class. Interface only extends other interface not classes. 


Abstract Class and Interface
1.	Both cannot be instantiated.
2.	Abstract class can have private, non-static and non-final variable unlike interface. 
3.	Abstract class can implement an interface but interface cannot extend/implement an abstract class. 

||Packages|| 
A package is formed when similar type of classes, interfaces, and sub-packages. Packages can be built-in or user defined. Packages are provided to better manage the classes, to provide access protection and removes naming collision. Check the method to run a package in cmd, if needed. 
Now, how to access a package from other package? There are three ways actually. 
1.	Import package.*;
2.	Import package.classes;
3.	Fully qualified name – it is “PackageName.ClassName”. we have write to it every time we will use it unlike importing which is done once and used as many time as required. 
Sub packages needs to be separately need to be imported for use. 
Now, what are sub packages? These are nothing but the packages under other package. For example, sun microsystem made one package for java and placed other packages like io, util as sub packages. The standard way for defining a package is “domain.company.package”. Check how to change the directory or classpath switch if need. 
To save the file temporarily, either save setting classpath in cmd or switch classpath. To save file permanently, save classpath environmental variable .
[IIII] Static import (Java 5 fetaure) – The static import feature of java 5 facilitates java programmer to access any static member of a class directly. This happens because the package.class.variable gets import. This is similar to importing the package.class to avoid lengthy codes. 

Example showing non static import:
Import com.smpackage.smclass;
Smclass.smapi()
Example showing static import:
Import com.smpackage.smclass.smapi;     //import com.smpackage.smclass.*
Smapi();




||Access Modifiers||
Access modifier defines the scope of data member, method, constructor and class. There are four types of access modifiers and these are of the following types.
1.	Private access modifier – these modifiers are accessible within the class which means that the method or variable made private will give compile time error if tried using outside the class. If you make constructor private, then you cannot create instance outside the class. 
2.	Default access modifiers (No Access Modifier) – if you do not use any access modifier then they come use the default category and can be used within the package. 
3.	Protected access modifier – this category of members has scope within the package and outside as well but that’s through inheritance. This rule is not applicable to a class. This may be because you cannot inherit a class so you cannot have a protected class. 
4.	Public access modifier – this modifier make its members to be accessible everywhere.
Note: 
1.	In case of overriding, the method in the sub class should not be more restrictive than the method in the parent class. But, we can increase the accessibility like from protected to public. Child implementation will still be the overridden implementation. 
2.	[III] What are non access modifiers? We also have non access modifiers which are static, final, abstract and synchronized. 
3.	[III] Access modifiers with outer class? We cannot declare an outer class as protected and private. Only public and default are allowed. 

||Encapsulation||
Encapsulation is a process of uniting the data and code. By this, we can make our class read only or write only. It provides more control over the data. Encapsulation is implemented by making all the variable private and using getter and setter methods to get and set data respectively. Practice one example. If you do not set a value through setter and try to print the getter then “null” will be printed.
Advantages of Encapsulation 
1.	Classes use getters and setters to get and set the encapsulated member of a class. Sometimes the requirement changes and we can then change the getter and setter method implementation without breaking the code that uses it. Also, we can change the data of the encapsulated method if needed. Therefore, we can maintain a code easily through encapsulation. 
2.	We can make the fields of a class either read only or write only as and when required.
Note: 
1.	Encapsulation is used to bind the functionality (method) and data (variable).
2.	[IIII] Real example where encapsulation is used! There are few frameworks in java which uses encapsulation. Like, singleton pattern which gives you its object through getInstance() while encapsulating how the instance is returned. Here, the data is the reference of the class which is bind by the method getInstance() and can only be received through this method. 

||Object Class|| 
The object class is the parent of all the classes in java. Coming straight to the point, we can refer any object of unknown type. This is because a parent class can refer to any object of its child class. getObject() is the key function for this functionality. Syntax: “Object obj = getObject();”. There are a lot of methods of object class. The object class gives lots of behaviors to all the objects exist in java like object cloning.

||Object Cloning|| [IIII]
Trust me its simple! Object cloning is used to create an exact copy of an object. We can do it through new keyword but cloning method uses less processing. For using the cloning method of the object class, we have to implement java.lang.cloneable interface and override the clone method. Also handle an exception CloneNotSupportedException. Its syntax is like this: “className obj2 = (Classname) obj1.clone();”. This looks to be similar to copy constructor.
Check the example of object cloning from program list file. 
Shallow Cloning
It is the default cloning in java. Shallow cloning involves creating another instance of the class, copy all the fields of object to the new object and return it as object type. Since, it returns as object type we need to downcast it. If the original object contains non primitive type then the cloned object also points to the same memory address as the original since only the reference on object type members was copied but not the object member itself. For primitive type, the data itself get copied. With shallow copy, changing the state of object in cloned object changes the state of the original object too. 
Deep Cloning
The default implementation of clone() method in object class does not support deep cloning. Whenever we need deep cloning then we need to overrie the cloning method the way it is needed. On a high level, clonable interface need to be implemented by overriding clone() method. In deep cloning, a copy of the object is created rather than the references. Thus, changing the state of the cloned object does not reflects in the original object. 
When to use which one?
We should definitely use shallow cloing when the data object just contain primitive members. Here, shallow and deep cloning are equivalent. However, if the object contains object type members too then based on the requirement shallow or deep cloning needs to be done. Also, if the object member of object do not change then there is no point of deep cloinning. 
Lazy cloning:
Lazy cloning is a mix of shallow and deep cloning. In this, we start with shallow cloning. A counter trackes how many objects are shared among cloned and original object. As we realize the change in any reference member of the cloned object and about to make change in original object then deep cloning in initiated. It like do not initiate deep cloning until not needed actually. 
For more details: https://howtodoinjava.com/core-java/cloning/a-guide-to-object-cloning-in-java/

||Java Array||
•	Array is a kind of data structure which is used to store one type of data. They have fixed memory size and that does not increase during the runtime. Code optimization and random access are its advantages. Code optimization means we can retrieve and sort the values easily and it allows random access of the values due to indexes. Arrays in java are index based and first element has the index zero.
•	They are of two types. 
1.	Single dimensional array – the syntax to declare an array in java is “int[] arrayName” or “int []arrName” or “int arrName[]”.Declaring and instantiation happens like int[] arrName = new  arrName[size]. Declaration, instantiation and initialization happens like “int[] arrName = new arrName[1,2,3]”. Following are the combinations allowed. 
a.	Separately doing the declaration, instantiation and initialization. (Or)
b.	Declaring and instantiation together and initialization separately. (Or)
c.	Declaring, instantiating and initializing altogether. 
I tried to run a method to print an array. I figured out that, we can pass an array as an argument to a method. To send the array as argument from the main class we must make that method static.
2.	Multi-dimensional array – In multi-dimensional, the index are given as row and column index like a matrix. Syntax for the declaration is “int[][] arrayName;”. Syntax for initialization is “arrayName = new int[n][n]”. Syntax for declaration and instantiation together is “int[][] arrayName = new int[1][1]”. Syntax for initialization is “arrayName[0][1] = 2”. Syntax for declaration, instantiation and initialization is “int arrayName = new arryaName{0,1}{3,3}” where 0 and 1 are in the first row and 3 and 4 are in second row. For printing the two dimensional array we will need two loops. Array out of the bound Exception occurs when the index is negative or greater than the size of the array. 
•	Since array is an object, so array object must belong to a class. Therefore,a proxy class is created for it whose name can be obtained on the object by getClass.getName() method. Try it. I made a program of two dimensional int array and the result I got it “[[I”. 
•	Copy of one array into other is also possible. First, declare and initiate first array. Then, declare and instantiate the second array. Then, use this syntax: “System.arraycopy(firstarray, copyfromindex, secondarray, indexcopystart, indexcopylength)”. 
•	Addition of two matrixes in java – First declare and initialize the arrays. Then, instantiate the third array. Then, with the help of two for loops, put the addition of first two arrays in the third and print it.
Note: [III]
1.	When an array is created then all indexes are given default value of the data type it is of and is given to whatever size it is created. You cannot change the size or in other words can delete or insert element to existing element. You can insert just the element on any index. 
2.	How to create anonymous array? We also have concept of anonymous arrays which are System.out.println(new int[]{1,2}.length);. 
3.	[III] While assigning one array to other only the data type of the array is checked by the compiler. Thus, we can assign a bigger array to a smaller array and it works fine provided both are of same type. Also, the size of the smaller array get increased to the size of the assigned array. Lastly, when I am saying a new array is assigned then the original array reference is no longer points to original array while it points to memory location of assigned array.
4.	Int[] array = new int[2]{1,2}; is not a correct way to create array because when you are defining the elements of array then no need to specify the size of the array. 
5.	Jagged arrays are the arrays which has multiple arrays of different size. They are the multidimensional arrays as well. 
6.	We can use Arrays.equals() method to compare to array single dimensional while we compare multidimensional using Arrays.deepEquals().
7.	ArrayIndexOutOfBoundException occurs whenever programs tries to access an invalid index. 
8.	You cannot specify empty dimension in an array. 
9.	[III] Why array are made covariant in nature? Firstly, covriant in nature means String[] is sub type of Object[]. Array is a part of java from its first version and array were originally made covariant because of the fact that its covariance nature was made useful in lot of initial program of java and also array has the concept of ArrayStoreException. So, through the concept of covariance, if the heap is polluted then it is made sure that array throws ArrayStoreException at runtime. Generics was added in java 5 and generic collection does not had any type information at runtime because of the concept of type erasure. Still have a doubt, just like arrayStoreException, in case of list we would have lot casting exception and that would have saved heap to get polluted. Lastly, this is a big debate that it’s a mistake that Array is covariant in java. Because a lot of type checking in needed at runtime. 
Number[] n = new Integer[10];
		n[0]=10.0;
We coded for integers to be in the array but when stored double then at runtime we will get arrayStoreException at runtime. Compilation will be ok.
||Wrapper Class||
•	Firstly, we have to understand what is wrapper class? Everything is java is an object like a file, image, a URL etc. So, to convert the primitive data type to an object, we have wrapper class. These wrapper classes wrap a data type to make it an object. Wrapper classes also have the method of unwrapping the object get the primitive data type. Sometime, we want to store data and that can be stored in object form only. Then wrapper class becomes savior. 
•	Wrapper class provides the mechanism to convert the primitive to object type (Wrapper class) and vice versa. We can convert the primitive type to wrapper class explicitly and it can be automatically done for us by compiler as well. The automatic conversion of primitive to object types is called as autoboxing. The conversion of wrapper to primitive is called as unboxing. Check the wrapper class for the primitive type. 
•	Check the bidirectional conversion. For converting primitive to object use valueOf() and from object to primitive use intValue()
Note: 
1.	I guess there is a problem with autoboxing in eclipse while boxing and unboxing is working fine. 
2.	Integer a = new Integer(10); creates a new integer class object holding value of 10. Thus, Another object “Integer b = new Integer(10)” is different through “==” but equals with equals(). 
Integer a = new Integer(10);
		Integer b = new Integer(10);
		System.out.println(a==b); // false
		System.out.println(a.equals(b)); //true
3.	[III] Lets see how autoboxing works: Integer a = 10;
Internally autoboxing uses valueOf() method of Integer class (other wrapper class too). It is quite beneficial for its caching facility too. From -128 to 127 is the caching limit. This means if you try to create two integer objects through autoboxing for same int value within the range -128 and 127 then both integer references will point to same object in the memory.  This intenal caching is just to boost some performance to auto boxing. Also, we have some argument that we can pass to increase this caching but I guess this will comsume extra memory. Laslty. All wrapper classes support caching. 

||Call by Value and Call by reference|| 
Formal and actual parameters ([III] Parameter and argument)
We have to pass radius of the circle to calculate the area of a circle. Currently, a variable int a has the value of the radius. Its value is 5 that we know (somehow). Then, if we pass int a then it is appropriate to say that we have passed a formal parameter. Formal parameter acts as an identifier to stand for the value that is to be passed in the method. Example, methodName(int a). If we pass 5 (literally value), then it is appropriate to say that we have passed actual parameter. Example, methodName(5). Also, the formal parameter is called as parameter and actual parameter is called as argument. 	

Pass by value and pass by reference
In pass by value, a copy of the value is passed and therefore change made to the formal parameter (parameter) does not reflect on the actual parameter (argument). On the other side, pass by reference means a method gets the location of the variable that the caller provides. Thus, changes made are reflected in the actual parameter. 
Java supports only pass by value. We can send a variable or a reference through the pass by value mechanism. When we send a value through call by value then the copy of a variable is sent.  If any change made will be made on the formal parameter while the actual parameter will remain same. Now, when we pass a reference of an object then a copy of a reference is passed to the method. The original reference and copy of the reference both points to same object in the memory. Thus, when the change is made to that copy of the reference then the original reference also changes the value it is holding.

Note: Do not understand these terms by name. Because pass by reference does not mean we have passed the reference but we have shared the reference location of the variable or reference passed. Also, pass the value does not means that we can pass the value only but we can pass the reference as well.

Edit:
Understand the difference between reference and object
I can bet that the understanding will be better after reading this note. Firstly, we have to understand that what a reference is? We have a class student. Now, we have create a reference of student class like this “Student s”. Here, “s” is the reference but what do actually mean by this. This means that “s” being a reference is actually a memory address which is point to that location in memory which is captured by any object of Student. What you understand by the statement “Student s = new student();”? This means that a student which is actually an object is located at the memory location “s” which is a reference. I hope now you understand that a reference is the memory location at which the object lies. 
Pass by Value
Now, if we talk about the pass by value and pass by reference then the concept is fine that a copy of value is given in pass by value while the original value is given in call by reference. We can send a primitive or user defined object through call by value only in java. So let’s say we first send a variable with value 2 through call by value then a copy of that variable will be sent. Similarly, we have sent a reference “s” of student class (which we call object earlier) to a method through call by value. So, this reference “s” is nothing but the memory location address. So, the receiving object will receive the memory location of a particular object of student class. However, since the copy of the reference also holding the same address then the receiving class can use or change the data in that memory location. 
Pass by Reference
Now, we will see what would have happened if java has pass by the reference. When we will try to send the primitive data like the same variable a holding a int 2 then the original copy will be sent so the changes can be seen in the sender method as well which was not the case in call by value. If we send a reference of a class like reference “s” of student class through pass by reference then the value itself of the sent reference “s” can be changed and this also means that “s” will not be pointing to the same memory location anymore. In the nutshell, if we sent a primitive value through PBR then value would be changed in the sender method too and if a reference is sent then that reference itself could be changed and will be other memory location. 

||Java Strictfp Keyword||
This keyword is used to provide a better arithmetic of the floating point data on different platforms. Since, different platform may have different precision so to overcome this difference we can use strictfp keyword. It can be used with class, interface and concrete method i.e. written in the signature of class, interface and concrete method. This can also give error when used at wrong places like using it with abstract classes, with variables or with constructors. 

||Creating API document by javadoc tool||
API document is the document contains the information about the API and project. It is needed to help the other programmer to know about the code. Javadoc tool is available for creating the API document in the HTML format from comments in the code. 

||Java Command Line Argument||
Command line argument are the argument that user can pass during the runtime. It can be taken as user input. This is only done through command prompt. 

||Object VS Class||
Class does not get memory when created but object gets the memory when created (well, I doubt on that). There are many ways of creating an object but only one way for creating the class. 
Doubt: Class does not get its memory when it is created while object gets. Is it true or false and why?
Take complete understanding of Heap and Stack.
Few words on memory management in Java
Heap – Heap memory is used by Java Runtime to allocate memory to java objects and classes. Whenever we create any object then it gets the memory in the heap space. That is why garbage collection runs on the heap memory for the objects do not have any reference. Also, the heap is divided into two parts (generations) which are young (nursery) generation and old generation. Young generation contains the new object created and if they continuously referenced then they are moved to old generation to make space for other objects to be accommodated. When any of the generation gets full, then garbage collection takes place. So, this much about the object which are the object related data while the class related data like static methods (infect all the methods) and static variables are stored in the special memory of the heap called permgen (permanent generation). However, if the static variable is a reference of an object then it is stored in the normal heap memory. 

Stack – This memory is comparably very smaller than heap. Stack memory used for the execution of the thread. They contain the value related to the methods which are short lived. Whenever a method is invoked then a new memory block in the stack is created to hold the local primitive values and references of other objects in the method. As the execution of the method gets over then that block of the memory gets destroyed. Also, every thread starts a new call stack.

||Overloading VS Overriding||
Overloading aims to provide more readable code and Overriding aims to provide a specific implementation. Overloading is a compile time polymorphism while Overriding is runtime polymorphism. Overloading cannot be performed by changing the return type while overriding can be done by changing the return type. 








Concepts of oops – 
1.	inheritance ek class k methods ko dusri class ko use karne deta hai (jaise API karte hai apan use wo sabs bada example hai inheritance ka).
2.	Polymorphism matlab ek name k methodsko alag alaf tarike se use karna. Jaise ek mehtod mai same name aur different argument hone se hume same method agal alag form mai mil jata hai. Agar inter class bat kare to super class k method ko child class mai change akr skate hai. Jaise ki inheritance mai ye feature hia k super class ka use karo method lekin change karkke use karna hai to polymorphism ki help leni hai.
3.	Fir hai abstraction. Abstraction possible hai abstract classes se, interfaces se aur bhi new technology se. Abstraction se app implementation hide kar dete hai. Jaise collections hai. Set interface k sare method kai class mai implement hai lekin hum unko kahi bhi use kar sakte hai. For example, add() method jisse set mai value add karte hai lekin wo add() function ki implementation thodi na show hoti hai. To humne bina implementation show kare kahi bhi kisi ko bhi wo functionality use karne di hai. Ye hum abstract class se bhi kar sakte hai bus abstract class se 100% abstraction nahi milta bal	ki kam less than 100% hota hai. 
4.	Encapsulation - 	Encapsulation is about restricting the access to the implementation of the object’s components (component are methods here) and state of the components (component are variable here) as well as binding the data and methods operating the data. 
Note: 
1.	Difference between abstraction and encapsulation – In abstraction, we just use the interfaces and abstract classes to let the user use the functionality without bothering about the implementation just from the sake of preventing complexity. In encapsulation, we restrict the user to see the implementation or state of the object’s component and bind the data and method operating the data. Now, why we gets confused in this is because few things are similar in this. Both involves the hiding of implementation and makes the code more maintainable. Let’s look at it. In abstraction, though the sole purpose is not to hide the implementation but to remove the complexity. However, still the implementation gets hide here too. In encapsulation the sole purpose is to restrict the user to see the implementation. In abstraction and encapsulation, the code become more maintainable as it is hidden from the user.  









=====================================================================================
Java String

What is String?
Generally, String is called as sequence of character. But in java it is an object that represents a sequence of character. String class is used to create a String object. There are two ways of creating a string. 
1.	By String literals – Check the syntax first “String s = “StringCreated””. Each time we create a string then JVM checks if there is any string already the value given (Stringcreated in this case). If there is no such string then it will create string s otherwise use the same string location to be pointed by the new string. String objects are stored in a special memory area known as string constant pool. Java uses the concept of literals to make itself more memory efficient.
2.	By new keyword – Check the syntax first“String s = new String(“stringcreated”)”. In this case, JVM will create a new string object s in normal heap memory and the literal “Stringcreated” will be placed in string constant pool. The variable s will refer to heap memory though.
3.	I would say there is third way by converting the string from an array. Check this. Do not convert the array to string through the toString() methos (only here) but convert through new keywordand passing the array as an argument. With toString() method, the output array is shown in the bracket and values separated by comma so does not given feel of the string.
Note: 
a.	When converting array to string then use new keyword but not toString method. If we use toString() method then we get hashcode. 
b.	When converting string to array then we have to use toCharArray() method. It works fine.  

||Immutable String||
•	In Java, Strings are immutable which means not modifiable. But we can create a new String. In the example given, it shows that string remains the same. 
•	[s] How strings are immutable in java? Once a string is created and later if it is changed then actually it does not get changed but a new string is created at a new memory location while the older string will remain at the same address. The older string gets garbage collected when no reference points to it. Lets understand the same thing with an example. String a = ‘’rishav’’ code will create an string with content “rishav” in an address in memory address in string constent pool. If we do a+” mishra” then a new string ”rishav mishra” will be created in the string constant pool at a new memory location and referece a will point to that address. While the noticable thing is that “rishav” will still exist at the older memory address. Therefore, it is said that strings are immutable in java. 
•	[III] Concept of interning in java: Intering is a concept of computer science which advocates the creation of only one object of anything in the memory. String in java can be created as string literals or through new keyword. String literals are kept interned by default. This means once a string literal is created then that object is created in string constant pool and if any other string literal is created with the same content then it will point to the same memory location where the string with same content already exist. Let’s understand the same with an example. If string a = “rishav” is created then an object with “rishav” will be created in string constant pool. If another literal String b = “rishav” is created then b will also be pointing to the same memory address where a is pointing already. Now, the string created through new key word is not interned automatically. When we create a string through new keyword then an object is created in normal heap area. When we explicitly intern a string created in string constant pool then an object with the same string content will look for an address in string constant pool with same content. If it finds it then it will point to the same location and if not then a string with that content will be created at a new address in string constant pool. If another string is created through new keyword with the same content then its new object will be created in the normal heap. It is not interned yet. If we call intern method on it then it will look for the address with same content. As a string already present with the same content then it will point the same memory location. Lets understand it with an example. String a = new String(“RIshav”) is not interned. For calling intern method on it we have to create do String a = new String(Rishav).intern(). A.intern() will not give compilation error but will not intern as well.  If another string like string b = new String(“Rishav” ) is created then its object will be created in normal heap. If it is also interned like string b = new String(“Rishav”).intern() then it will point to the already existing string with same content in String constant pool. 
•	[III] Also, if a string created like string a = b; then it a will be a string literals getting the content from the address where b will be pointing. If b is interned (which means already in constant pool) then it will point to same memory location otherwise an object will be created in string constant pool. 
•	[III] Now, why strings are not mutable? Well, there are multiple reasons for it. First, when a string is made whose value already exist in the string constant pool, then the new string is referred to the old string location. If the string is not immutable then change in a string made can do similar changes in the other string too which are pointing to the same address. Second, Strings are widely used as parameter in java class. So, if strings are mutable then the parameter could be change and could cause serious security threats. There are other reasons as well. For more jigyasa: http://www.programcreek.com/2013/04/why-string-is-immutable-in-java/.
Note: String can be created in two ways which are String s “Rishav” which is called as string literals and other is String s = new String(“Rishav”) which is through new keyword.  


||Java String Compare||
We can compare the string on the basis of content and reference. String compare is used in authentication, sorting and reference matching etc. There are three ways of comparing the string. 
•	String compare by equals() method – It compare the original content (values) of the strings. It also has two types. First, public Boolean equals(s.equals(s1)); this compare without ignoring the case. Second, public Boolean equals(s.equalsIgnoreCase(s1)); this compare ignoring the case. Also, we can pass the any other string like s1, s2 or directly write in the method as this: s1.equals(“ayushi”). 
•	String compare by == operator – the operator == compare reference but not values. This means that it will be checked whether to two string object point on the same memory block or not. This has nothing to do with the value. 
•	String compare by CampareTo() method – this method compare the two strings lexicographically which also mean to compare the values with their unicodes. If the strings differ through this method then either they have different character at an indexed position or they are may be have different length. The result of this method comes in integer form. 0 indicates that the strings are equal, positive indicates that the first string is greater and negative indicates that the second string is greater. This also has the option for ignore case i.e. compareToIgnoreCase(). 
Note: compareTo() method is showing negative vlue even if the first string is greater. Why? This may be happening because it checks the first element and gives the result if found the difference in the first element itself.

||String Concatenation||
The string concatenation is used to create a new string from connecting multiple strings. There are two ways to doing it. 
•	By + operator – It is very simple method. Try it. However, its compiler transformation is quite interesting. The concatenation becomes possible because of String builder or String buffer class and its append methods. + operator can also concatenate the primitive data type too. All the primitives are added when used prior to the Strings and considered String when used after them. For example, “String s = 50+30+”Rishav”+40+40” results 80Rishav4040.
•	By concat() method – This is also simple. Try it. 
Note: [III] when + operator is used for concatenation, then there is a little code transformation by the compiler happen which is like this – “String s = (new StringBuilder()).append(“String1”).append(“String2”).toString();”. This is because concatenation is defined in the Stringbuilder class. 

||Sub-String||
The sub-string is nothing but the part of a string. We can make a new string object from an already existing string. This can be done by using the startindex and endindex. While creating a substring, we need to mention the start index and end index. Start index is inclusive and end index is exclusive. 
Note: 
1.	“subsquence()” is a method which is similar to substring with two arguments. 
2.	[III] String class has three field which are char array, offset and count. Since, string is backed by char array then char[] of String class point to an address where the backed array is created. In java 6, whenever substring method is called then a new string is created at new address. The new address will also point to the original array char[] content while will be having offset and count different values. This way in scenarios where substring is refereced while original array is ready for GC, then actual backed array cannot be garbage collected. This is bad beause substring is smaller than original String and but hold the array of same size in memory as original Sring. In Java 7, came as improvement on this by only keeping a needed char out of the original array and making actually a substring. Therefore, GC can now collect the original backed char array even if substring is not eligible for GC. Check diagram, if still confused: https://www.programcreek.com/2013/09/the-substring-method-in-jdk-6-and-jdk-7/. 

||Java String Class Methods||
Java.lang.String is the class that contains all the methods which are used to perform operation on String for concatenation, comparison, converting, trimming and replacing them. Well, without doubts, String is very important topics since almost all the web application, mobile application, and window based application treat everything as a string. So, here are a few important string methods. 
•	Java String toUpperCase() and toLowerCase() – these are used to convert the lower case values of a string to upper case and vice versa. Also, if few value out of all values in a string are already upper case and toUpperCase() is applied. Then, uppercase values will remain the same and rest will covert to uppercase too which means every value will be upper case. Also, it has got the same method with the additional parameter “locale” and its for the language which is not necessary to use as the system will pick up the default language (English in our case).
•	Java String trim() method – trim removes the white spaces  (Simple spaces/blanks) are removes before and after the string. Try it. However, it does not remove the white space between the String values. For ex – “Rishav Mishra”, will not remove the white space between rishav and Mishra. 
•	String startsWith() and endsWith() – these methods are used to check whether a string start and end with against the value checked and give Boolean output. Try it. When the string ends with a white space, then mentioning the white space, it is important. Also, if string start with “R”, then we will receive false for “r” which means it is case sensitive.
•	Java String charAt() method – it is used to print the value at an indexed place. Try it. It prints the white space also. 
•	Java String length() method – this method is used to print the length of the string. 
•	Java String intern() method -  this method is used to intern the string created by new keyword. If this method is used only while creating any string with new keyword then the it will first check as if any other location have the same value. If atleat one location is found then the new object will be pointed towards the same memory location containing the value or else it will get new memory location. Check example for understanding. Also, for pointing to same location, both the object must be interned either implicitly or explicitly.
•	Java String valueOf method – This method covert the primitive type of data into string. When we try to add integer or any other kind of primitive data type it treats everything a string (same type of data type will be written simple and other type in double quotes).
Note: In simplest words, it just creates the string version of any primitive data type and then we can use it whichever way we want. 
•	Java replace Method() -  this method replaces the whole string data or some part of string data with a new data. 
Note: It has different version which are related to regex. Do it later when get time.

||Java StringBuffer Class||
The java StringBuffer class is used to create mutable string which is synchronous as well (Synchronous means multiple thread use the StringBuffer without making program inconsistent). They are same in every other manner to a normal string. This class is thread safe (multiple threads can use StringBuffer without making program inconsistent, due to synchronization). It has three important constructors. 
•	First, StringBuffer() constructor creates an empty string buffer with initial capacity of 16 indexes. Second, StringBuffer(String str) which creates a string buffer with the specific string. Lastly, StringBuffer(int n) creates a string buffer with specific capacity at length. Please check the important string buffer methods.
•	As we know, mutable strings can be created by the help of stringbuffer and stringbuilder classes. Below are some important methods. 
1.	Stringbufferappend() method – This method is used to append the two stringbuffer. But how is this different from concat() method? In append, when one stringBuffer is appended to a sequence of values then the stringbuffer gets changed and values get added in the same stringbuffer whereas added values does not reflect in the old string object in concat() method.
2.	StringBuffer insert() Method – this method is used to insert a string into another string from a provided index. The provided index will be taken as offset argument which is excluded while inserting. Also, do not get confused with replace, this method will inert something and will keep the original data as well.
3.	StringBuffer replace() Method – This is same as the replace method in the string class. This replaces a portion of string  buffer and puts the replacement from the start and end index provided. Start index is included while the end index is excluded. 
4.	StringBuffer delete() method – This method delete the part of a string froma startindex to an endindex where the endindex is excluded from the deletion process. 
5.	StringBuffer reverse() method – the reverse method of the StringBuilder class reverse the current string. Try it. 
6.	StringBuffer Capacity() method – this method is used to print the memory capacity of any string buffer. According to the tutorial, the default capacity of a normal string buffer is 16 and when characters become more than 16. Then, the capacity increases by this formula: newCapacity = (oldCapacity*2)+2. However, when I tried it shows that the default capacity is 16. When I add one char to the stringbuffer then capacity becomes 17 and then likewise. Capacity includes the white spaces too.
7.	StringBuffer ensureCapacity() method – this method is used to ensure the minimum capacity of the string buffer. Check tutorial if not remember. Little complicated to undertand through words. We do not print the “ensurecapacity”. The formula mentioned in the string buffer works in ensuring the String. 
Note: See! This is not easy to clarify but I am trying my best. If it’s only about capacity method, then anything written in its description is correct. But when ensure capacity is used then there are two cases. First, if we try to ensure the capacity more than the current capacity of the stringBuffer. Then, {(2*c)+2} will be applicable where c is the current capacity. Second, if the ensuring capacity is equal or lesser than the current efficiency of the stringBuffer then the ensured capacity will be same. I hope this observation is correct. 

||Java StringBuilder Class||
StringBuilder also use to create mutable string but they are non-synchronous. It also has three constructors which are StringBuilder(), StringBuilder(String str) and StringBuilder(int a). They are same as in StringBuffer. Please check the important buffer method. Some of the methods of the StringBuilder class are below. 
1.	StringBuilder append() Method – it is the same as the append method of the StringBuffer. 
2.	StringBuilder insert() Method – It is same as the insert method of the StringBuffer.  
3.	StringBuilder Replace() Method – this method is used to replace a part of the StringBuilder by some other sequence of char.
4.	StringBuilder Delete() Method – this method is used to delete some part of the StringBuffer. 
5.	StringBuilder reverse() Method – this method is used to reverse the StringBuilder values. 
6.	StringBuilder capacity() Method – this method is used to print the capacity of the Stringbuffer. It is also same as StringBuffer capacity method. 
7.	StringBuilder ensurecapacity() method – same as Stringbuffer ensurecapacity method. 

Difference between String and Stringbuffer
These are the differences between the two –
1.	The basic difference between then is that the String is mutable and StringBuffer is non-mutable.
2.	Second, String is comparatively slow than the StringBuffer. This is because everytime we concat something then it calls a new instance. However, in StringBuffer, the same instance adds the append part it the existing string. Also, Stringbuffer takes less memory.
3.	String class overrides the equals() method and that is why string can be compared by equals(). However, StringBuffer do not overrides the equals() and so cannot use it. 
Please review later the programs for testing performance of String and StringBuffer. The difference mutable and non-mutable is also shown by printing the hashcodes for the objects. By the way, hashcodes are code which codes to find the objects in the hash table. Hashcode is made some logic. 

Difference between StringBuffer and StringBuilder
They have some differences which are as follows. 
1.	StringBuffer is synchronous while the StringBuilder is not Synchronous. 
2.	StringBuffer is thread safe and StringBuilder is not thread safe.
3.	StringBuffer is less efficient and StringBuilder is more efficient. 
Please check the performance test between both. 

Note: When to use String, StringBuffer and StringBuilder
1.	String – it is immutable. So, you should use it in a program where the values of the string are not required to change. 
2.	StringBuilder – It is mutable but it is not thread safe and synchronous. So, it should be used in a program where the values of the string are changing because of program logic or any other reason but only be used by a single thread. This is because synchronous adds extra overhead and if not used will decrease the efficiency unnecessarily.
3.	StringBuffer – It is mutable, thread safe and synchronous. So, it should be used in a program where the value of the string is changing because of program logic or any other reason and used by multiple threads. Since, its being synchronized ensures that the threads will use the stringBuffer in a consistent way. 
4. [III] In case of frequent modification, should we use String or StringBuild/StringBuffer? We should use StringBuffer or stringBuilder when we are dealing with a lot string concatenation (or manipulation in any other way). StringBuffer object is a general object and resides in normal heap area. 

[III]How to create an immutable class?
An immutable class is the once whose object once then its members cannot be changed.
If you follow few rule then can create your own immutable class. These are the few rules. 
1.	Make your instance variable as final. 
2.	Use final keyword with your class too. 
3.	Do not give setter method. 
Immutable classes can be made to make few things unchangeable in the project which may be used sometimes. 

||Java ToString() Method||
This method comes in existence when we think of representing an object as a string. The sole purpose of thinking about this is to print the value of the object by writing less code. 
The best way to understand this is to first make a program which prints the value passed while creating an instance. For that you need to create a constructor and use the display method (or you can also write print statement in constructor itself). In the same program, literally print the object of the class then it will print the hascode. Now, instead of representing the object with hashcode, we can represent the object as string. This is done by overriding the toString() method whose return type is String. Also, that will be involving less code to represent the clause of the object that the usual way which is its second advantage. In the nutshell, to literally print an object as string and write less code to print the values, we can use toString() method. IT’S NOT ABOUT CONVERTING THE ARRAY TO STRING. 

||StringTokenizer Class in Java||
•	Java.util.StringTokenizer is a class that allows you to break a string into tokens. Though it does not provide a facility to differentiate between numbers, quoted strings, identifiers and etc, but it is simple way for breaking string into tokens. Example of quoted string is “Hello”. 
•	StringTokenizer has three constructors which are StringTokennizer(String str) i.e. string tokenizer with specified string, StringTokenizer(String str, String delim) i.e. string tokenizer with specified string and delimiter and StringTokenizerI(String str, delime, return boolean) which has got additional Boolean return type which if true then the delimiter is taken as a token to be printed otherwise not. 
•	Now, to use this we have to make the instance and pass the string which we want to break. Then, use its method “hasmoretokens()” in the while loop  and nextToken() inside the print statement. Check example for further clarification.
Note: you can check more methods later if want to learn more on this. 

||Java String Methods(left out)||
1.	String contain() Method – This method search the sequence of char in a string i.e one string into other. If found then returns true otherwise false. We can even search any other string in the other. If the sequence is null then it will throw the NullPointerException. 
Note: we call character sequence to this: String s = “Rishav”;.
2.	String Format() Method –this method is used to format the string in java by giving locale, format and argument. It can throw NullpointerException if format in null and illigalFormatException if format is illegal or impossible. Also, we have different formatting style for int, float, char etc which is out of scope right now. 
Note: In case of printing the index of the searched string the index returned will be the first appeared character with searched string in the main string. Check javatpoint example for this.
3.	String IndexOf() method – This method is used to find the index of character or sequence of char in a string. It can receive from Index parameter which takes the index value to start the search start inside the string.
4.	String isEmpty() Method – This method is use to check if the string is empty or not. 
5.	String join() Method – This method is used to join multiple string but with delimiter in between. Two parameters are passed. First is the delimiter type and other is the strings. Though it will seem as in you can put one string but you can put multiple separated by comma. If we have to join an existing string then pass it as an argument with double quotes.
Note: I am not able to run this method on eclipse kepler. Also, in oracle docs it is mention 1.8 java so dose this means that it can be used from java 1.8? Also, I can see the error for this method. Please find out on this later.
6.	String lastIndexOf() Method – this method is used to print the last index of the parameter given. It can be given a character to find the index of the place where it is last appeared in the string, a string can also be given accompanied by fromindex parameter which defined the start index point of the search. 
7.	Java String replaceAll() Method – this method is use to replace a regular expression wherever found in a string with a sequence of chars. Both are passed as the parameter. Note: this  \\s is a single white space and \\s+ more than one white spaces.   
8.	String split() method – This method is used to split a string against given regular expression and return a char array. It takes two parameters which are regex which is the expression makes basis of split and int limit which is limits the number of string in an array. If it is zero than no string, one than as it is one part and 2 then in two parts. Also, we have to create an string array and put all the parts in that and print it with the help of for loop.
Note: This method returns string array and thus we cannot simply print it but we have to print it like we print an array.
9.	String toCharArray() Method – it is a method used to convert a string to char array. To implement it, create a string and convert it into tocharArray() method and then print it through a for loop. 

Note:
1. [III]String, string buffer and string builder are final.
2. [III] Why StringBuffer and StringBuilder classes are introduced in java when there already exist String class to represent the set of characters?
The objects of String class are immutable in nature. i.e you can’t modify them once they are created. If you try to modify them, a new object will be created with modified content. This may cause memory and performance issues if you are performing lots of string modifications in your code. To overcome these issues, StingBuffer and StringBuilder classes are introduced in java.
3. Write a java program to reverse a given string with preserving the position of spaces?
4. Write a code to prove that strings are immutable in java? solution: http://javaconceptoftheday.com/example-to-prove-strings-are-immutable/
5. [III] How string has special feature to be created without new keyword? JVM creates special memory area for string in Heap which is String Constant Pool. Thus, string can be created without using new keyword as well. 
6. [III] String comes in lang package. Thus, we do not need to import it as well. 
7. [III] Char Sequence is an interface in java. Subsequence method of string returns the part of the string in charsequence format. Charsequence interface is implemented by many classes like string, stringbuffer, charbuffer and other. charsequence is hardly been made in use. 
8. [III] Well, i am gussing that intern method is maninly used while creating a string with new keyword which are not interned by default like string literal. 
9. [III] String concatenation and substring method causes creation of a new object. 
10. [III] Well, I have read a lot of argument presenting both the standpoints that String s = new String(“ABC”) creates one object or it creates two objects. First standpoint is that it creates two objects argues that this is a constructor of String which needs a string as argument thus we must have a literal created in CP and passed in this constructor as argument. Also, we can check the memory before and after the created of object with new keyword. With new keyword, the reference though points to the object created in heap but results in creation of string literal in CP too (obviously, if it does not exist already). Also, to note string internally uses char[] which could too be considered another but object we hopefully not when we are speaking about object of string. 
I think both are correct. Like String s1 = new String(“Rishav”) will create two object which are in string CP and heap. String s2 = new String(“Rishav”)  will only create a new object in heap which s2 reference will point to while no object will be created in CP as same content is already created when s1 was created. Refer point b and c for example. Thus, both reasoning is correct. The final answer is dependent on complete situation. 
11. [III] Check the below for the clearest understanding on string object creation with the below examples
a. String s1 = “Rishav”; Object created in string constant pool and s1 point the same object. 
b. String s2 = new “Mishra”; Object (“mishra”) created in String constant pool first, if not exist already and passed as argument in string constructor. Another object will be created in Heap. S2 will points to object created on Heap.
c. String s3 = new “Mishra”; Object “mishra” already exist in Constant pool and thus same object will be passed as argument in string constructor and one object will be created in Heap. S3 will be pointing to new object created in Heap. 
d. String s4 = new “Mishra”.intern(); Here, no new object will be created if an object “mishra” exist in constant pool. S4 will point towards object with “Mishra” already in CP.
 e. String s5 = “a”+”b”+”c”; Total 5 object will get create which will be a, b, c, ab and abc.
12. [III] String constant pool from java 7 onwards lies in heap area. Garbage collection in constant pool happens in the same way as in other part of heap. However, String literal inside string constant pool generally be needed by your program. Also, not all strings are interned in java, but the interned are always be needed for your program execution. One good scenario where string literal be garbage collected when the class loaded through custom class loader gets unloaded. Garbage collection of string with new keyword or un-interned and stringbuffer and Stringbuilder happens in the usual way. 	


=====================================================================================
||Java Regex||
(Over to java oracle docs: https://docs.oracle.com/javase/tutorial/essential/regex/)
Java regular expression (Regex) is used to define String Pattern that can be used for searching and manipulating a text. Java provides java.util.regex package for pattern matching with regular expression. It is very useful in defining constraint on password and email verification. This java.util.regex has mainly got one interface MatchResult interface and three classes which are Matcher, Pattern and PatternSyntaxEception class. 
1.	Matcher Class – This implement MatchResult interface. This is basically used to perform the match operation between the pattern and expression. Check all of its methods while Boolean Matches() being mostly used and solves the purpose of matching the regular expression with the pattern. 
2.	Java.util.regex.pattern Class – This class basically helps define a pattern to the regex engine. Let’s study some of it highly important methods. 
•	Pattern.matches(String regex, charSequence input) method – this method is a most simple way to searching a string in a text using regex. I have made a program and figured out that we call this method with its class. Pattern string and content are given as parameters. However, I still have to learn to build pattern. With this we can just search the single occurrence in the content (text) and case sensitive.  
•	Pattern.compile() method - For case insensitive and searching multiple occurrence, we have compile method of pattern class. While writing the code I observed that we call compile method with pattern class. The parameter passed in the compiler method are regex i.e. the pattern string and a CASE_INSENSITIVE flag. We can use other flag for getting this done. We gets an instance of pattern class. But match making is still not complete. For this, we have to make a matcher instance. 
•	Pattern.matcher() method –this method is used to create an instance of matcher class. So, for that we use pattern instance with matcher method of the pattern class. Then, with the help of matches method we get the result. So, in the nutshell, to search a string (string pattern formed of regex) in the content (text) by the regex classes which are matches, compile, matcher. 
•	Pattern split() method – to split a text into multiple string based on delimiters (here based on regex), we can use split() method. Checkout the example. Firstly, the text and pattern were declared and initialized. Then, the pattern instance was created with the use of compiler method. Now, something new happens. An array of string is created which is feed by the spilt part of the text string. Then, we used a for loop in this way: “for(String temp : myString)” where myString is the array of spilt part and this means to get the myString value one by one till its last. 
3.	Java.util.regex.mather class – we have already leaned the way to create the instance of matcher class. Let’s understand some of its main methods. 
•	Matches() – this method is used to match the string against the text passed to pattern.matcher() method while creating matcher instance. 
•	lookingAt() – it is also similar to matches() but it search the String only at the beginning of the whole text.
•	Find() – this is mainly used in the case of multiple occurrence search. 
•	Start() and end() – both these method are generally used with the find method to get the start and end index of the match being found using find() method.

Writing Regex –

So far, we got to know that the ways we have to match the pattern string with a text using regex. Now, we will look at the options we have to define the pattern string or regex. 
a.	String literals – String literal means string like “abc”, “123” or similar like this. If the same string is found not less or more than one time in the other string then result will be true otherwise false. Infect, if the regex contain only string then the other string should be identical. Check example “basicregexdemo”.
b.	Character String–A character class matches a single character in the text against the multiple allowed characters in the character class. For example, Pattern.matches(“[pqr]”, “abcd”) it will give true if only one character is search against this and contained only one time. Below are all the character cl	ass and its descriptions. This class search only for one character. @@@practice examples.
No.	Character Class	Description
1	[abc]	a, b, or c (simple class)
2	[^abc]	Any character except a, b, or c (negation)
3	[a-zA-Z]	a through z or A through Z, inclusive (range)
4	[a-d[m-p]]	a through d, or m through p: [a-dm-p] (union)
5	[a-z&&[def]]	d, e, or f (intersection)
6	[a-z&&[^bc]]	a through z, except for b and c: [ad-z] (subtraction)
7	[a-z&&[^m-p]]	a through z, and not m through p: [a-lq-z](subtraction)

c.	Predefined character classes – These are like a short code while writing the regex. \s is the white spaces while the[^\s] is characters except white spaces. \w is the word character which includes the alphabets, digit and one special character which is under score. \W is any character except the word character. \b is like an anchor and it matches a position that is called word boundary. Also, there is one meta character left which is a “.” (dot). This dot indicates any character. @@@practice example. 

Regex	Description
.	Any character (may or may not match terminator)
\d	Any digits, short of [0-9]
\D	Any non-digit, short for [^0-9]
\s	Any whitespace character, short for [\t\n\x0B\f\r]
\S	Any non-whitespace character, short for [^\s]
\w	Any word character, short for [a-zA-Z_0-9]
\W	Any non-word character, short for [^\w]
\b	A word boundary
\B	A non word boundary

d.	Quantifiers – the quantifiers specifies the number of occurrence of a character. 

Regex	Description
X?	X occurs once or not at all
X+	X occurs once or more times
X*	X occurs zero or more times
X{n}	X occurs n times only
X{n,}	X occurs n or more times
X{y,z}	X occurs at least y times but less than z times (less than or equal to z times?)

Moreover to the table above, quantifiers are of three types which are greedy (simple pattern), Reluctant ((simple patter)?) and Possessive ((Simple pattern)+). These are basically different in the approach they search the pattern. Check them in detail later if required.   

Summary
We first have seen the way of checking a string against a regex pattern. We have found that matches(arguments) of pattern class is not the only way but the easiest way of doing the same. After this, we learned as how to make the regex pattern. For this, we have seen character class, predefined character class and quantifiers. With all these classes, we can create versatile patterns to be used against the input string. We can explore more on this at this link below. 
https://docs.oracle.com/javase/tutorial/essential/regex/

Important link for practicing some of its examples: 
http://www.tutorialspoint.com/javaexamples/java_regular_exp.htm








=====================================================================================
Garbage Collection

In languages like C or C++, programmers are not just solely responsible for creating an object only but for destroying the object (variable) as well. However, it is done automatically in java. Isn’t this cool? We are not bothered about destruction of objects that we do not need anymore. But, how actually does java manages the destruction of object itself? Well, java has a concept of Garbage Collector which is like a daemon thread that is running in background and destroying the object which are no more needed or are eligible for garbage collection. 
Now, we come to a crucial point, which is, how does GC will identify if an object is eligible for garbage collection? In simplest term, when all the references of an object are discarded or no more referencing to that object is valid then that object will be called as unreachable. We can have several scenarios where an object becomes unreachable. Let’s look at each of them.
1.	[III] When an object is created inside a method: When a method is called then it goes inside the stack frame. Once its execution is done then it goes out of the stack frame and its members dies. Therefore, if any object is created in a method then it becomes eligible for GC when execution of that method gets over. 
2.	Island of isolation: When a group of object reference to each other and are not referenced by any other reference then they create an island of isolation. Practically, even single object create an island of isolation. Below is the example for showing island of isolation where when an object which is placed null is not garbage collected until all its member references are not null. 
Public class Test{
	String name;
	Test t;
	publicstaticvoid main(String args[]){
		Test t1 = newTest();
		Test t2 = newTest();
		Test t3 = newTest();
		t1.name="t1";
		t2.name="t2";
		t1.t=t2;
		t2.t=t1;
		t1=null;
		t2=null;
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.name);
	}
}
Note:
a.	Object is used every time its reference is used. Like i.someVariable, allows the use of someVariable of the object through the reference thus we must have all possible reference to be discarded for an object to become unreachable. Below is a program displaying object that is  garbage collected. Also, we will see that t2 object will be collection first because its execution will end first. 
Also, if a method returns an object created inside it and we store this object as reference type variable then it is not eligible by the GC. 
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid show(){
		Test t1= newTest("t1");
		System.out.println("myVar value from object in show:" +t1.myVar);
		display();
	}
	publicstaticvoid display(){
		Test t2 = newTest("t2");
		System.out.println("myVar value from object in display:" +t2.myVar);
	}
	publicstaticvoid main(String args[]){
		show();
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
b.	Reassigning of reference variable: When reference variable of one object references of reference variable of some other object then the previous object does not have any longer reference to it and hence become unreachable. 
publicclassTest{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		Testt1 = newTest("t1");
		Testt2 = newTest("t2");
		t1=t2;
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
3.	Nullifying the reference: When the reference is made null then the object gets eligible for garbage collection. 
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		Test t1 = newTest("t1");
		t1 = null;
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
4.	Anonymous Object: When an anonymous object is created then it is not referenced by any reference thus if we call the garbage collector then it should be garbage collected. 
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		new Test("t1");
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
So far we have seen different scenarios where object will get garbage collected. However, there can be other such scenarios as well.
[III] Garbage collection happens automatically in java and is not controlled by programmer. We are not sure when exactly JVM will run GC. Maximum, we can request JVM to run garbage collector for GC. There are couple of ways for request JVM for running GC. 
1.	We can do it through static GC() method of System class. Below is a code example:
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		Test t1 = newTest("t1");
		t1 = null;
		System.gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
2.	We can also use gc() method of Runtime class. We have to create its instance and then we can use gc() of runtime since it’s an instance method.  
packagearrayrotation;
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		Test t1 = newTest("t1");
		t1 = null;
		Runtime.getRuntime().gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		System.out.println("Garbage Collected: "+this.myVar);
	}
}
Both the ways are equivalent for requesting JVM for running GC, however any of it does not guarantee when JVM will process the request. 

||Finalization||
Now, we will move to another important topic of GC which is finalization. Finalization is an activity that happens before GC destroys an object. This clean-up can happens through a method called as finalize() present in Object class with signature “protected void finalize() throws throwable”. Importance of this method for a programmer is that he can override this method to perform something before JVM destroys an object. 
Note: 
1.	Garbage Collector is just one module of JVM. Finalize method is called by JVM. 
2.	Finalize method is with empty implementation and thus recommend to be overridden in a class needed. 
3.	Finalize method is never invoked more than once for any object.
4.	Old generation is also called as tenured gen. 
5.	If finalize methods throws any uncaught exception then it is ignored and the execution of finalize method get stopped there itself. Below is the example shows how if exception occurs in finalize method than further lines of code does not execute. 
publicclass Test{
	String myVar;
	public Test(String myVar){
		this.myVar=myVar;
	}
	publicstaticvoid main(String args[]){
		Test t1 = newTest("t1");
		t1 = null;
		Runtime.getRuntime().gc();
	}
	@Override
	protectedvoid finalize() throwsThrowable{
		inta = 10/0;
		System.out.println(a);
		System.out.println("Garbage Collected: "+this.myVar);
	}
}

||Garbage Collection Logs||
To diagnose any memory related problem it is highly important to check the garbage collection log. 

Talking of memory:
For a computer, ROM, RAM and Hard drive are main memory block. ROM is Read Only Memory which is non volatile (contains data even when device is powered off) in nature used to store firmware. Firmware is a software that is closely tied to any hardware. ROM is a memory which is very hard to change the data and therefore most suitable for firmware since hardware related software is very rare to be upgraded. RAM is Random Access Memory which is volatile memory (memory losses data after power off) used to store currently running program and its related data. Ram allows read and write of the data is same amount of time irrespective of the physical location of data in memory. Lastly, we have HardDrives, CD drives etc which are direct access memory category. These are non volatile and used to store the data permanently. Hard drives are better to be called as storage space.
In programming view point, we are most concerned about Stack and Heap which resides on RAM. Stack is for execution of threads. When a function is called, a block of stack is reserved. When the function returns then that block of memory gets free. The stack always works in LIFO. Imagine a situation where four functions A, B,C and D calling in a order of A,B,C and D. Then the first block in stack memory will be reserved for A then B, then C and finally for D. The stack blocks will get free in the order of D, C, B and A. Stack traces of program execution is a classical example of stack memory real time experience. 
Heap is a portion of memory where dynamically allocated data resides i.e. memory allocated via malloc. When I say that allocation is dynamic then I mean that there is not pattern of allocation memory and freeing it. Any block of memory can be allocated or freed in any order. Memory allocated in heap will remain allocated until memory is freed (garbage collected in case of java) or program terminates.	
Also, language runtime controls the allocation of memory rather than OS. Heap is comparatively much larger memory area than Stack. Each thread gets a stack while heap is same for an application. Stack is reclaimed when the thread exit while heap can be reclaimed when program/application terminates. Stack is faster then heap majorly because of the easier allocation and deallocation of memory area.
Extending discussion of memory with respect to Garbage Collection:
Garbage Collection happens only for Heap while ignored for Stack. GC does scan the stack just to know what is being used or pointed in heap. Everything in the stack is considered to be useful and subject to discard only when the program terminates. It is really that simple and thus we do not even need garbage collection in stack. On the other side, its definitely not necessary if everything on heap is useful and considered for garbage collection. 
Heap is also divided into multiple spaces which are represented in the below image:
[III] When the program execution begins, the objects is created in Eden. At some point in time, when eden starts to get full then first minor garbage collection runs. The object in eden which are not referenced are garbage collected. Heap has survivor 0 and servivor 1 after eden. Thus, the object which are not garbage collected in servivor 0 will move to survivor 1. By the way, most of the object die young. After certain number of GC cycles, the object in survivor are moved to tenured or old generation, if not collected from survivor itself. This is also called as tenuring threshold. Then major collection happens where object in old generation are checked for collection. Heap does also have perm gen which stores the data related to the class and other metadata.  
Note:
1.	[III] In GC logs, “PSYoungGen”, “PSOldGen”, “DefNewGen”, “ParOldGen” shows different GC. PS stands for parallel scavange and not sure about Def GC full name. While the later part simply shows the generation of heap. 
2.	[III] In GC logs, after eden space we can see to space and from space are nothing but survivor 0 and survivor 1 space.
3.	[III] Does JVM has only one GC? A JVM does not have just one GC but all four GCs we have studies and thats why you can select any of them. The default GC until java 8 is Parallel GC.  
4.	[IIII] From java 8, permgen is completely removed and MetaSpace is the new memory space which has taken its place. The initial capacity of MetaSpace is subject to native memory availability. A new flag MaxMetaspaceSize allowing to limit the size to a certain point and if this is not set then the re-sizing happens depending on the available memory at the runtime. The key advantages of having metaspace over permgen is auto tuning, auto sized according to underlying OS and concurrent deallocation of data and not during GC pause. 
Memory Fragmentation:
Once an object is removed from memory then it leaves that memory as empty. Such empty memory block gets appeared across the heap area which is called as fragmentation of memory. For faster memory allocation the defragmentation of memory is quite necessary. How the memory gets defragmented is subject to the type of garbage collector. 
Different type of collectors
Java has 4 types of garbage collectors. All the collectors has their own advantages and disadvantages. We can select the garbage collector to be used by JVM by passing an appropriate argument to JVM. Let’s discuss each of them. 
1.	Serial Garbage Collector: It is a single threaded garbage collector which pauses the application threads while garbage collection process. This is primarily designed for single threaded environment. We can pass argument –XX: +UseSerialGC. You would never want this GC on server JVM. 
2.	Parallel Garbage Collector: It is a multithreaded garbage collector which uses multiple threads for garbage collection however this also stops the application threads while garbage collection process. This is the default collector of JVM and is also called as throughput garbage collector. We can pass argument –XX: +UseParallelGC.
3.	[III] Concurrent Mark and Sweep Collector: This collector uses multiple threads to scan the memory for marking the block of memory for eviction and to sweep the marked memory blocks. CMS collection pauses application threads in only two cases which are while marking the referenced objects in tenured generation and if there is a change in heap memory during the garbage collection. CMS uses more CPU as compared to parallel thus if we can compromise of CPU allocation then we should choose CMS over parallel. We can use the argument: -XX: +UseParNewGC. CMS GC can also run into promotion faliures which is a race condition between clearning young gen and old gen. This can be overcome by increasing the size of old generation though. This GC is good for heap size less than 4 gb. 
4.	[III]G1 Collector: It is the latest garbage collector which was introduced in jdk 7. It divided the heap area into regions and does prioritise the garbage collection of the region which has the most garbage. This strategy reduces the chances of heap gets depleted before other thread can scan the unused object. This reduces the chances of STW as well. It also compacts the memory area on the go unlike of any other collector. Other collector put stops the world is such case. We can use argument: -XX: +UseG1GC. 
Note: In java 8, we can use an argument –XX: +UseStringDuplication while using G1 garbage collector. This optimizes the heap by moving the duplicate string to an array of string.

[IIII] Garbage Collection Monitoring
Garbage Collection Monitoring is all about figuring out how does the JVM is running. Based on the information received by monitoring the garbage collection, we can decide if garbage collector tuning is needed or not. JVM are of different type, oracle uses HotSpot JVM. GC monitoring is possible through CUI or GUI. 
In java, we have a tool called jstat in Hotspot JVM for GC monitoring. We will now see a basic command that we can run on CMD for getting some basic information regarding the garbage collection activities. 
The command is jstat -gc $<vmid> 1000 10. Here, jstat is the command name and -gc is the argument. Vmid is the virtual machine id however if java app is running on local machine then we need to know the lmvid i.e. local vmid. We can get to know lmvid through command but using jps for the same considered safe as pid shown by ps command is not always the same as lvmid. 1000 denotes the time which is equivalent to 1 second while 10 denotes the number of times we want to show the GC infomation.  
As we have seen the -gc is the argument that we have passed and that will show information like current size of each area of heap, current usage of each heap area, number of GC cycle performed and accumulated time for all GC cycle. We can have other different arguments like gccapacity, gcnew, gcnewcapacity and others. The bottomline is that with different arguments we gets different columns with GC information. Let's look at the columns we see with gc argument. 
1.	S0C, S1C: Current size of first and second survivor.
2.	S0U, S1U: Current usage of first and second survivor. 
3.	EC, EU: Current size and usage of Eden.
4.	OC, OU: Current size and usage of Old generation. 
5.	PC, PU: Current size and usage of Permanent generation. 
6.	YGC: no. of garbage collection happened for young gen. 
7.	YGCT: Accumulated time of garbage collection cycle performed. 
8.	FGC: no. of full garbage collection.
9.	FGCT: Accmulated time of full garbage collections.
10.	GCT: Accumulated time of all types of garbage collection.
Similarly, we may have different columns appearing as information of GC according to the argument passed. 
With jstat -gc argument we gets to know the accumulated time for different types of GC while we still do not know time taken for an individual garbage collection. To solve this problem, we have another command which is -verbosegc. With -verbosegc we need to mention it as an JVM starting option from the beginning while jstat we do not need to have any option passed from the beginning. with -verbosegc we can monitor each GC individually. We can have different options passed along with -verbosegc. Below is the format of information shown with verbosegcoption:
Information shown in case of minor GC - 
[GC [<collectortype>:<initial occupency1> -><ending occupency1>, pausetime1 in sec], <initial occupency3> -><ending occupency3>, pausetime3 in sec]
Information shown in case of full GC - 
[Full GC [<collectortype>:<initialoccupency1> -><ending occupency>, pausetime1 in sec], ..perm related information..<>]. (this is incomplete format). 
For GUI based garbage collection monitoring, we can use Java VisualVM + VisualGC tool. Actually with VisualGc tool or plugin present in VisualVM is used to check jstat equivalent information. Likewise, for -verbosegc equivalent information we can use HPJMeter. HPJMeter is a tool created by HP. Garbage collectiom monitoring is just one task out of many for HPJMeter.

Garbage Collection Tuning
So far, we have understood few ways to monitor garbage collection. Now, we need to understand the factors crucial to decide if we need GC tuning or not. We will try to keep it simple. Below are the factor we can check upon to take decision for GC tuning.
1.	Minor GC should be processed within 50ms. 
2.	Minor GC should not be frequent than once per 10 seconds. 
3.	Full GC should be processed within 1 second. 
4.	Full GC should not be frequent than once per 10 minutes.
If all the pointers above get satisfied then we ideally do not need GC tuning. However, exception can be possible. 
Once we decide to tune GC then how should be go about it? Mainly we can tune the GC by using appropriate garbage and set the memory size of different generation of heap. We can try giving different memory size of heap parts and analysing the result. Also, we need to keep in mind that if we decrease the size of old gen for bringing full GC time down then we might encounter OutofMemoryError. On the other hand, if we try to increase the old gen space for less number of full GC (frequency) cycles then we might face longer time of full GC processing. Therefore, we need to try with different value of memory and find out the appropriate one. Check the note point for the options available for adjusting the GC type and memory of heap. We should try different values of heap and deploy the code in different environment. In 24 hours, we can check the result and if we find the result as optimized then we can finalize the same options on all server. This way we can tune the GC. 
Below are the commands we can use to tune the GC.
a.	We can use –XX: +UseG1GC for selecting different garbage collector. 
b.	–Xms: Heap area size when starting JVM. 
c.	–Xmx: 	Maximum heap area size
d.	–XX: NewRatio: Ratio of the new area and old area. 
e.	–XX: SurvivorRatio: ratio of eden area and survivor area. 
We can definitely use different other options but the above listed are basics. 
Note: Example –Xms512! Here, the complete command is –Xms512m where we are setting size of heap as 512 mb. Here, m is for megabyte. We can have other size units like k for kilobyte or g for gigabyte. The default size of heap is 256 mb by the way. 


=====================================================================================
Exception Handling

||Exception Handling in Java||
[IIII] Codewise what happens when an exception occurs? When an exception occurs in a program an exception object gets created. The exception object has alot of important information about where the excetion occured (class, method and line number), which exception has occured and other details. The process of creation of exception object and passing it to runtime exvironment is called as throwing an exception. Then JVM will look for the exception handler block. Once the exception handler block is found then the exception object is passed to it. This process of passing the object is excetion handler is called as catching the exception. This is most basic flow when an exception occur in a program.
•	The exception handling is a powerful mechanism to handle the run time errors and to maintain the normal flow of the application. Firstly, what is exception? Dictionary meaning of it is an abnormal situation while in java it is an event that disrupts the normal flow of the program. It is an object thrown at run time.  
•	The core advantage of exception handling is to maintain the normal flow of the application. In an application, code stop running from where an exception occurs.

Well, exception has got hierarchy as well. But, this goes really out the scope as it is more for learning. Now, let’s look at different types of exceptions. The exceptions are basically of two types which are Checked and Unchecked Exceptions. The Unchecked Exception is also divided in two types which are Runtime Exception and Error.
•	Checked exception – These exceptions are found at the compile time i.e. the compiler will found then while compiling the program. The super class of all checked exception is IOException. Some examples of checked exceptions are SQLException, DataAccessException, ClassNotFoundException etc. 
•	Unchecked exception – These are exception which are not found at compile time but will be found at runtime. These are of two categories, which are described below. All the Unchecked exceptions are the sub classes of the Runtime Exception.
a.	Runtime Exception – These are due the mistake of programmer. It may be because the programmer trying to access an element which does not exist or any other mistake that looks fine at compile time but will create an abnormal situation. All the runtime exception has a super class called as Runtime Exception class.
b.	Error – These are the exceptions that an application cannot deal with. It happens even when the coding is done correctly. One example of it may be when the JVM runs out of resource. The errors are catchable but typically an application will be closed until the problem is not dealt.
•	Common scenarios where exception may occur – First, where a number is divided by zero causes airthmaticexception. Second, if we have null value in any variable (primitive or reference type) then NullPointerException will occur and that is because of length. Third, when wrong format of any value is used (like int in place of string). Fourth, when wrong value of index is entered (like negative or more than the size of array) then arrayOutOfTheBoundException will occur. Well, this is not it but we have other exceptions too.
Note:
1.	Errors are of two type which are syntax error (compile time error) and runtime error (unchecked exception). The syntax error is because of typo error that we make while writing the program and hence we encounter them while compiling the program. The runtime errors are nothing but the unchecked exceptions that happens while program is running (MemoryOutOfBound error).  
2.	If an arithmetic Exception occurs, then we catch it by the print statement printing the “exception is caught” message. Well, this does not happen in actual application. We do write some remedial code in the catch block. So, do not think that what is the advantage we are just printing and the calculation is still not performed. This happens only in the sample program just to make us understand that the control goes over from try to catch block if exception occurs. 
3.	We can print exception message in three ways in java. First, by printing the “e” of exception e. Second, e.printStackTrace(). Also, do not put it inside print statement. Third, e.getMessage() can be used inside the print statement. [III] e.getmessage still println method and only gets you the exception message while e.printstacktrack does not need println method and also gets you the line of the exception along with the message.
4.	Parent class of exception and error is throwable class.
5.	It is not possible to catch Errors by catch block. Error example can be OutOfMemory error or written like new Error()..
6.	[III] When exception comes then the info of exception then after exceptio is occurred then finally block will be executed. Then, flow of program will stop. 
7.	If any variable is declared inside try block then it cannot be accessed outside the try block. 
8.	Default handler handles the exception when no catch block is written. This is provided by jVM. 
9.	If the exception comes at line written inside try block and caught by catch block then all the code written after catch (stack trace printed) or finally block will execute. Code inside the try block after the line where exception occurred and caught will not execute. 
10.	If the exception comes in the called method then that can be caught inside the catch block of the try block from which it is called.      
11.	Class not found exception occurs when class is not found when classloader tries to load it.
12.	Init() cause method is used to find out chained exception code which actually caused the exception.  
13. [III] Example of checked and unchecked exception! Parent class of check exception is IOexception while sub classes are fileNotFoundException, ClassNotFOundException, SQLException. Parent class for unchecked exception is RuntimeException class while sub classes are AirthmaticException, NullpointerException,ArrayOutOfBoundException, NoClassDefFound and other.
14. [III] Important piece of code to understand what happens if an exception occurs:
public class Test3 {
	public static void main(String args []) {
		Test3 t = new Test3();
		t.A();
		/*o/p: 1,2,4,excp caught, 6*/
	}
	public void A() {
		try {
			System.out.println(1);
			B();
			System.out.println(5);
		}catch(Exception e) {
			System.out.println(4);
			System.out.println("Exception is caught");
		}
		System.out.println(6);
	}
	
	public void B() {
		System.out.println(2);
		int a = 10/0;
		System.out.println(3);
	}
}
15. We can only throw exception which is a subclass of throwable class. Also, we can throw an exception which is a subclass of custom exception. This is because that class will also come in the throwable class tree.

||Studying different Exception|| [III]
1. IOException: IOException occurs when you are dealing with input or output stream and something abnormal happens. Few examples, when you reading a file locally and file is deleted in between, writing into a file while disk space is full, reading from a network file and lost the connection mean while. All these instance something abnormal happens after the IO transaction starts.
2. FileNotFoundException: Object, throwable, exception, IOException and then fileNotFoundException. When you try to read or write a file and gives a wrong path by mistake. Also, if a file is not found and any of IO activity havnt started then filenotfoundexception is given but if IO activity starts and file becomes unavailable for some reason then IOexceotion is thrown. 
3. ClassNotFoundException: When classloader does not find a particular class in classpath for JVM. Then, this error is thrown. Also, NoClassDefFound exception comes when class is present at compile time but not at runtime. Be clear on this. 
4. SqlException: Whenever we have difficulty in accessing data or any possible issue related to database then sqlException is throw. A simple example, when wrong table name is hard coded by mistake and table could not be identified. Then, we will be receiving SQL exception. 
5. Runtime Excpetion: Any exception that is not checked during compile time is runtime exception. It is sub class of Exception. You can typically use this in catch block then either you do not want to reveal about the exact runtime error that you are suspecting or you are not aware at all.
6. NullPointerException: Null pointer exception occurs when a reference pointing to nothing or is null tried to be used. It only occurs when we try to use a reference which is null, we get null pointer exception. Remember, printing a null reference prints null, we only gets a null pointer exception when that null referenced is used. The fundamental way of avoiding this exception is to null check every object before using. Especially, try to check all the arguments of a method for null check first. We can use ternary operator as well returning default value in case of null and placing value only when value not null.
7. Airthmatic Exception: Whenever bad arithmetic logic is written by a programmer then arithmetic exception is thrown. The classic example is anything divided by 0. 
8. ArrayIndexOutOfBoundException: When a negative index or greater or equal to the length of Array is called then we get this array. Similar error for String is StringIndexOutofBoundException. 
Note: 
1.	[III] Some important errors are OutOfMemoryError (Heap out of memory), StackOverFlowError (stack out of memory). We can resolve OutofMemoryError by providing JVM more heap through the arguments like –XMS, -XMX, -XX:Permsize and etc. 
2.	I have observed that any exception (checked and unchecked) that if not catched and came at runtime then program stucks while if you catch it then logs for that error is printed and nothing executes further in the same try block while program executes right after the try block. 

||Java Try Catch||
•	The code which is prone to give exceptions is written in try block which must be followed by catch or final block. These blocks are within the method. Check the syntax. Catch block is used to handle the exception and it must be used after the try block. We can use multiple catch block. Check the example for better understanding. 
•	Internal working of try catch block – It is pretty simple. When the exception occurs, an object will be thrown. Now, either that will be handled or not handled. If handled, then rest of the code will execute otherwise JVM prints the exception description and will terminates.

||Multiple Catch Block|| 
If you suspect multiple exceptions in the code written in the try block then you can use multiple catch blocks. But one exception comes at a time and handled at a time. Also, the catch blocks should be written from most specific to general. 

||Nested Try Block||
The concept of one try block into other is nested try block. The need arises when one part of a block may cause one exception while the entire block causes a different exception. Check the syntax. Try a program for better understanding. 

||Finally block||
This block is used to write the cleanup code. Now, what is cleanup code? cleanup code are the code written to properly close any file, database connection  or anything else that was used for running the program but not required anymore. For example, this closes the database connection so that other users can easily make connection. For a user to make connection a sufficient number of open database connection should be closed. Finally block is always written even if the exceptions are handled or not which means if catch block is present or not. The only condition is to have a try block before a finally block. Another point of view to understand finally block is that it will definitely be executed if the try block in called. We cannot handle the exception in finally block and we cannot write it before the catch block as well. 
Note: we already know that whatever happens except system.exit or JVM crash, finally block will always be executed. Also, when we have return statement in try and catch block then also finally block will be called and then return statement of try and catch will be executed. But, if finally block also have return statement then also finally block will be executed and try catch will not be executed. Though, writing return statement in finally is considered as very bad habit. 

||Java Throw Keyword||
At first glance, it did not make any sense to me. But yeah it did later. I was not able to understand it before because why we want to create an exception? It is abnormal condition that stops the program’s execution. Then, why do we need it? Exceptions are needed for implementing some business need related to the program. From the example given, suppose we have to build software for machine that allows or stops a person to vote according to their age. So, when you have the age below 18 then an exception should be thrown. The facility of throwing our own exception (custom exception) helps us to maintain some business requirements like age of the voter should be more than 18. If age is less than 18 then we can take some alternative actions in the catch block. In the nutshell, to implement some business requirement we need to throw self-made exception. 
Now, Throw is a keyword use to explicitly throw an exception in java program which we will catch also. It is mainly to throw our own created exception called custom exception but it can also throw the predefined exceptions.
Note:
1.	How to create your own exception? Well, for this, create a class giving the name you want to give to your exception. Then, extend the exception class. Then create a constructor and pass a string as parameter with the message (or any random short string). Lastly, make use of Super() function and pass the massage.
2.	Syntax for Throw keyword: “throw new AirthmaticException(“myMessage”)” or “throw new CustomExceptionName(“MyMessage”)”. 
3.	We can rethrow an exception by using throw keyword inside catch block. 
4.	Even after knowing that an exception must be catched, If we do not. Then, that’s called Ducking the exception. 
5.  [III] Throws with Exception and RuntimeException! While throwing runtime exception its not mandatory to use throws (but we can). While throwing checked exception we must have to mention in signature of method through throws. Same goes with custom exception. Now, understand it this way. Any compilation error get notified to programmer during compilation and it is mandatory to handle it. We can handle it through try catch or throws. Thus, if we are explicitly throwing a checked exception (mostly for implementing certain business logic), we must have to mention in signature through throws keyword. Also, compiler will only get to know the compiler error thrown through throws keyword.

||Exception Propagation||
Exception Propagation is simple process where once an exception is thrown then the runtime system looks for a block containing exception handling code. The search starts from the block throws the exception to the block next (below) in the calling stack. For example, if a calls b, b calls c and c calls d. If d throws an exception then the compiler will look in the order d to c to b to a. Check for deep explanation: http://stackoverflow.com/questions/10633664/what-is-exception-propagation.
Note: 
1.	If sub classes of exception is catched after super classed then unreachable catch block error will be shown. 
2.	We can chain the exception by throwing one exception on another exception is already thrown. 

||Throws Keyword||
We have just studied throw keyword which is mainly used for throwing the custom exceptions. Though, we cannot throw the custom exceptions with “throw” keyword alone. We need to use throws keyword as well while declaring a method (not while declaring a class) which use throw keyword to throw a custom exception. Since, custom exceptions are not known by java that is why we need to use throws keyword for a custom Exception. If we throw a predefined exception by using throw keyword then throws is not required.
Sometimes, throws keyword is also used to indicate that the code in the method might throw certain exceptions. Therefore, if anyone use those methods can properly catch those exceptions. This is another view point for throws keyword. 
Note: Also, try to understand the difference between try and catch and throw and throws. Try and catch is used to handle the exceptions with or without throw and throws. With throw and throws keyword, try and catch block will be used in the method that calls the method that throws the exception.  @@@Practice Example. 

||Difference between throw and throws|| 
Below are some difference between throw and throws keyword. 
•	Throw is used to throw an exception while throws is used to declare an exception in any method. 
•	Checked exception cannot be propagated with throw only and it can be propagated with throws. 
•	Throw is followed by an instance and throws is followed by a class. (look at the syntax literally)
•	Throw is used within a method while throws is used as a signature in declaring a method. 
•	You cannot throw multiple exceptions with throw but we can declare multiple exceptions with throws keyword. 

||Difference between Final, Finally and Finalize||
Below is the description exploiting the difference between each of them.
•	Final – it is a keyword. Final is used to restrict a class, method or variable. Final class cannot be inherited, final method cannot be overridden and final variable cannot be changed.
•	Finally – Finally is a block. It is used to write code to terminate the connection and file used to run a program. 
•	Finalize – Finalize is a method. Finalize method is called by Garbage collector when a garbage collector finds that there is no reference to an object.   

ExceptionHanding with methodOverridng in java [IIII]
There are few rules for exception handling in case method overriding which are described below.
•	Rule 1 – if the parent class does not declare an exception, subclass overridden method cannot declare a checked exception but can throw unchecked exception. I have checked it myself. It only let you throw unchecked exception. 
•	Rule 2 – If the superclass throws an exception (checked/unchecked) then overridden method of subclass can declare same(checked/unchecked respectively), subclass exception but cannot declare parent exception. Here parent exception is simple “exception e”. It is very simple. Try it. 

||Java custom Exception||
Exception created by user itself is called Custom Exception. It is very simple to create your own exception. Try it. Then you can use that exception in the same way we use the predefined exception. Throws and throw are for declaring and throwing the exceptions but we can handle them as well. Also, when we handle the exception then look at what is printed on the console. It is interesting. 
Note: 
1.	If we need to create a checked exception, then we need to extend Exception class while runtime class is extended to create a unchecked exception.
2.	[III] Custom Exception with Exception or RuntimeException! If we create custom exception by extending runtime class then not catching or not using throws does not show error while if created by extending exception class then not catching the custom exception or not using throws shows error. Now, since runtime exception are not necessarily need to be catch thus need to be used very carefully. The fundamental behind extending exception or runtime exception class is that if your code cannot do anything if the custom exception occur then we can use Runtime exception but if it can or it should then we should extend exception class. 

[III] ||Java Exception Classes brain storming||
Throwable class is the parent class of all the exception classes. We can only throw an exception which is a sub class of throwable class. A throwable object contains a snapshot of the execution stack of its thread at the time it was created. It is classified into Errors and Exception. 
Errors are something more serious which can cause application crash and should/cannot be handled by better coding. Errors like OutOfMemoryError and StackOverFlow error has the potential to crash your application and just cannot be handled in by your code. 
On the other hand, Exceptions are the abnormal situation that can stop the execution of program and which should or can be handled. Exception is classified into checked and unchecked excetion. 
Checked exception are those which are checked or can be found by the compiler during compilation and must be handled by programmer for successful compilation. Now, how does a compiler finds out checked exception during compilation? Simple! it looks for all the methods called in the program if they throws any exception or not. An example is FileWriter class constructor throws IOException. So, compiler will only successfully compile the code if you catch the IOException while using FileWriter constructor. 
Unchecked exception are those which are not checked by the compiler during compilation. This also means that compiler will not force to be catched like checked exception. Like, if any method is throwing RuntimeException then other method using this method will not be forced to catch the exception.
Also, we should understand that every exception occurs in runtime be it checked or unchecked. We should not get confused with checked (also called as compile time) exception that it occurs in compile time. It is called as compile time since they are checked by the compiler during compile time.   






=====================================================================================
Java Inner Class
What is java Inner class? 
A class inside another class is called as nested classes but we have different categories of nested classes. Nested classes are majorly classified into two categories which are static and non-static class. Non-Static nested class is called as inner class which is further classified into Member inner class, Anonymous inner class and local inner class. We will also study about the static nested classes. 
The class that holds an inner class is called as outer class. Let’s understand the advantages of the inner classes.
•	Inner class can access the outer class methods and variables even if they are private methods. 
•	Inner classes are used to create more readable and maintainable code because it logically group classes and interface at one place. 
•	It requires less code to write so it is more optimized code. 

Member Inner class
A non-static class that is created inside a class but outside a method is called as Member inner classes. This is pretty simple. I just need to take care that the inner class used the main method of the outer class. Also, I should remember the syntax for creating the object of the inner class in the main method of the outer class to call its method. I have tried working with main method of the inner class but, firstly, you cannot create it static since your inner class in non-static and secondly, if you try to call any other method in the main method does not make much difference because ultimately main method of the outer class will be handling the program. Also, it can access even the private members of the outer class. 
The syntax for creating the object of inner class is “OuterClassName.InnerClassName in = out.new InnerClassName();” where “in” is the object of inner class and “out” is the object of outer class. 
Note: 
1.	We can use the members of outer class in inner class but we cannot call the member of the outer class by creating the object of inner class. @@@try Example. 
2.	[III] How many class files for class having an inner class? Java compiler creates two class files. The name of java inner class is “Outer$Inner”.
3.	[III] How outer class can access member of member inner class? For outer class to use members of inner class, it needs to create object of inner class and call it through it. 
4.	[III] Member inner class and static member? We cannot create static members inside inner class since we cannot have static reference from non static source. However, member inner class can access static as well as non static members of outer.
5.	[III] MemberInnerDemo.InnerMemberClass innerRef = ref.new InnerMemberClass();
While creating member inner class object, the object of outer is created and then an object of inner class is created inside the just created outer object. 
6.	[III] when we change value of instane variable of outer class from inner class then the value changes for that particular outer variable instance using which inner class instance created. If static variable is changed, then it is changed for all instances of outerclass since it’s a static variable. 
7.	[III] Outer class can use the private member of inner class too as inner class can use private members of outer class.

Anonymous Inner Class
Anonymous inner class does not have name. It is present inside the main method of the class to override the method of other class or interface. An object of the class whose method needs to be overridden is created inside the main() which is followed by a block which overrides the method and ends with a semicolon. That block is considered as Anonymous inner class. It is accessible only at a point where it is defined. It does not have a constructor since it does not have a name. Compiler creates an anonymous class and gives it a name for its reference. Check below for understanding. @@@try Example.
Note: 
1.	We should understand that the main use of anonymous class is to override a method without extending the class or implementing an interface containing that method.   
2.	[III] Why would you ever want to use annonymus class? We can call the overriden implementation by the anonymous class anywhere in the outer class directly without extending the other class. 
3.	Annonymous inner class can be of three types. First, it can created by overriding method of a class. This class would be super class of anonymous class. Second, it can be created by overriding method of an interface. This interface would is implemented by the anonymous class. Third, anonymous class could be implementing a class/interface being present in the sub class of that class/interface. Check the example here: http://java-questions.com/InnerClass-interview-questions.html


Local Inner Class
This is a type of inner class (which means non static in nature) which is declared inside a method of the outer class. Though for calling a method of the local inner class, we must only create instance of local inner class inside the method in which it is created but outside itself (local inner class). Local inner class cannot be invoked outside the method in which it created. Check the example and practice some. We cannot declare local inner class as public. @@@Try Example.
Note: 
1.	Usage of local inner class with outer and vice versa! We can directly use any member (static and instance) of outer class as it has implicit reference to the outer class object. It can modify the instance member of enclosing class but cannot modify the class local variables of the enclosing method. [IIII] But to use the local inner class member inside method in which they are written is through by local inner class instance. Although, we cannot have (or create) static members inside local inner class but we can only have if we make static member final as well to show then as constants. Also, local inner class members cannot be accessed outside method in which inner class is created.
2.	This is for all the inner classes. They cannot contain any static member since they belong to an object of outer classes. Confirm this though. 
3.	Local inner class can be written inside a for loop or an if condition.
4.	[III] Access modifiers with local inner class! We cannot use private, public or protected access modifiers because this does not make sense as the member created inside a class are just local to the method. A local class can be declared abstract or final. 

Static Nested class
Static nested classes are the classes which are inside any other class and declared as static. It cannot access the non-static methods and variable of the outer class. Though it has the advantage of being called by the outer class object but can only access static member of the class. Also, to call the methods of the static class it should be given proper syntax. The syntax is: OuterClass.InnerClass obj = new OuterClass.InnerClass(). Use this object obj to use call the static inner class methods. Also, if the method of inner class is static as well then syntax for calling it will be “outerClass.InnerClass.Method();”.@@@Try Example.
Note: [IIII]
1.	Static nested class use outer class member and vice versa! Static nested class can access the static member of outer class directly including private member while it cannot use the non static member since nesting class reference is not available inside the static nested class. Outer class can use static member of nested class directly while need nested class object to access non static memebr. We can create nested class object like “Outer.Nested restedref = new Outer.Nested();”. Outer class can also use the private member of nested class. 
2.	Static inner classes behaves like a top level classes as they can be accessed like any other static member of the enclosing class within enclosing class. Like this, OuterClass.Static.member.

Java Nested Interface
An interface that is declared inside any class or other interface is called as Nested Interface. A class which implements an interface by-default implements its inner interface as well. It has to define the method of the inner interface methods but for calling those methods from the implementing class, a different syntax is given than the usual. The syntax is: “OuterInterface.InnerInterface obj = new ClassName();”. The same happens when an interface is nested inside a class. 
Note:
1.	A class can nest a class or an interface. Likewise, an interface can nest an interface or a class. 
2.	Nested interface does not has any method implementation thus it never use the members of outer class or interface. It is more about how to use the nested interface. 










=====================================================================================
Java Multithreading

||What is multithreading?||
Multithreading in java is the process of executing multiple threads simultaneously. Threads are the smallest unit of processing. The core advantage of multithreading is that the threads uses the same memory location and separate memory is not allocated to each thread. Context switching between thread takes place in less time than the process where context switching is switching from one thread or process to other without any conflict. 
•	Multitasking is a process of carrying out multiple tasks simultaneously. It can be carried out in two ways which are multiprocessing and multithreading. Multiprocessing is also a similar concept but it is simultaneous execution of multiple process rather than threads. In multi-process, each process gets its own memory space while each thread uses the same memory address in multithreading. Process is heavy weight, compared to multithreading, since it is bigger unit. Also, the cost of communication between threads is lower than processes. Lastly, the context switching is fast between multiple threads than multiple processes.
•	Thread in detail – A thread is a lightweight sub process. It is the smallest unit of processing. They are independent and if error comes in one thread then other thread is not affected. It shared a common memory. So, basically, an OS may have multiple processes while a process have multiple threads. In thread safety, threads uses memory one by one through synchronization. 

||Life Cycle of thread|| 
A thread has five states in its life cycle which are called as threads states. These are New, Runnable, Running, Non-runnable and terminated. The thread will be in new state when an instance of a thread class is created but only before the start() is called. [IIII] Thread is in runnable state when its start() method is invoked, but the thread scheduler has not selected the thread as the running thread. The thread is in the running state when the scheduler selects the thread. The thread comes in non-runnable state when the thread is still alive but is currently not eligible to run due to any reasons like waiting, sleeping or blocked. Non runnable thread is also said to be in blocked state. When the thread is terminated or become dead is known to be terminated. 

||How to create a thread?|| [III]
There are two ways to create a thread. It can be by extending the thread class or by implementing the runnable interface explicitly. 
•	By thread class – what is a thread class? A thread class contains constructors and methods to create and perform operations on a thread. The thread class extends the object class and implements the runnable interface where object class is the top most class in java and by default extended by every other class in java. Check the commonly used constructors and methods of thread class while few are thread(), thread(runnable r), run(), start(), sleep(), suspend(), resume(), stop() etc. Start() method is used with the run() method of the class extending the thread class (same or the other). The run() method will contain the working of the thread. [IIII] Also, we create the object of the class extending the thread class and calls the method (Start()) from thread class. So, the compiler automatically converts the extending class object to thread class object through thread class constructor. We do not need to create thread class object explicitly in this case. 
•	By implementing the runnable interface – In this method, we implement the runnable interface and the entire program is same as by extending the thread class except that we have to create a thread object by passing the class object. We need to create the thread class object for sure here since we have to call its method start or otherwise when we extend thread class then its not mandatory since we can access member of parent class from subclass without creating parent object. Try one example for better understanding. Runnable interface just has one method which is run().
Note:
1.	Main thread always start the execution of the program and it is created by JVM. 
2.	Thread class has 7/8 constructors. Two important of them are Thread() and Thread(target).  
3.	If we are creating thread by extending thread then also we can create class object and then pass it to thread. It will not give compilation error. If we do so then we will be calling parent class method through parent class object. 
4.	Thread Class implements runnable interface. It overrides run method of it as empty body method. 
5.	If a thread is printed like this “System.out.println(Thread);”, then we get output like Thread[ThreadName, Priority, TypeOfThread]. 
6.	If run method is not present while start method is called then compilation error will come provided thread is created by implementing the runnable interface. This will come because runnable interface has abstract run method which need to be overridden while thread class has a run method which is empty body. 
7.	When a thread calls wait then its on sleep by giving its lock as well. Now, at this point in time, if we try to check if that thread is alive through isAlive() method then we will get exception. I guess this is because the thread is neither running nor terminated. Thread is in non runnable state.
8. Runnable interface is a functional interface which has just one method i.e. run(). That's when a class implements the run interface works fine.
9. [III] Why do we have to call run method through start method? Run method is a normal method which is just overridden in your class. While Start() method has its implementation in thread class which provides the functionality of multithreading in java. Start method will ask JVM to create the new thread and call the run method through the new thread call stack.
10. [III] Thread vs Runnable: In java, we can create thread in two ways which are through thread class or through Runnable interface. Let's discuss which one to pick and why. Runnable interface way should be preferred for creating thread for these reasons. Firstly, since multiple inheritance through classes in not allowed in java thus when we extends Thread class then we lose the chance of extending any other class. Second, Extending a class is generally to use specialize the behaviour of the parent class while here we want to just use the start method which we can do by creating an instance only.
11. [IIII] Tell about suspend method! Suspend method, though now deprecated, puts the thread to non runnable state which is uninterruptable. The thread suspended goes to non runnable state without releasing locks it already holding. Thus, suspend method is deadlock prone. We can put the thread to runnable state after suspend is called using resume() method. 
12. [III] When we implement runnable interface then we create thread class object using Thread(target). Why can we simply create object of thread class using no args constructor of it? This is because with target argument we specify which class run method to call. Whereas when we prefer to extend thread for thread creation then subclass relation of the user class with thead class explains whose run method implementation to call. 

||Thread Scheduler in Java||
Thread scheduler as the name suggest schedules that when to run which thread. It is a part of JVM and selects a runnable thread to run. Only one thread can run in a process (while multiple threads can run of different process). The thread scheduler mainly uses preemptive and scheduling or time slicing. In preemptive scheduling, the thread with the highest priority is executed first until it enters the waiting or dead state or even higher priority thread becomes runnable. In time slicing, a task executes for a certain time slice and then again another thread is selected for a slice of time on the basis of priority and other factors.    
Note: [III] Little insight on Thread Scheduler: Thread Scheduler is a part of java (JVM) which is used to schedule or manage which thread should run at what time? Thread scheduler under the hood has some algorithms like preemptive, time sclicing or other. The thread schedular take few things in consideration like priority of thread, waiting time of thread and nature of thread. Whenever main methods executes, its thread scheduler that provides the main thread for execution. Not only main thread but other threads like thread for garbage collection, thread for event handler or thread for timer to take care of sleep.

||Sleep Method||
Sleep() method is a thread class method which is used to sleep a thread for a specified amount of time. It has two implementation which are sleep(long miliseconds) or sleep(long miliseconds, int nanos). Try an example, the sleep method written inside the run method and then run method is called by the start() method. [III] When a thread sleep the scheduler picks up the other thread and then runs the other thread but only for the time the first thread sleeps. Also, remember to catch the Interruptted exception thrown by the sleep method. 
Note: 
1.	Yield moves a thread to state which I think is runnable state. 
2.	[III] Can we override wait method? We cannot override wait method of object class. Wait method (just like notify and notify methods) is final method implemented in Object class. Hence, we cannot override it. Why would it be made final because may be the designer does not wanted the implementation of wait to be changed as it provides the core functionality. 
3.	We know that when sleep is called in the run method then thread currently using run method goes on sleep. What will happen in a situation where sleep method is called outside the run method? This will make all threads of that class to sleep for the specified time. Hence, isAlive() will return false. Since, the thread is temperorily suspended so false will be returned. 
4.	Difference in Yield, Join and sleep
yield() method pauses the currently executing thread temporarily for giving a chance to the remaining waiting threads of the same or higher priority to execute. If there is no waiting thread or all the waiting threads have a lower priority then the same thread will continue its execution. The yielded thread when it will get the chance for execution is decided by the thread scheduler whose behavior is vendor dependent.
join() If any threads calls join method then all other thread waits for the thread that has called the join method. 
sleep() Based on our requirement we can make a thread to be in sleeping state for a specified period of time (hope not much explanation required for our favorite method).
5. [III] Sleep and yield method does not have any semactics of synchronization. Also, remember that the compiler does not flushes the caches data (thread data) into the shares memory before the call to sleep or yield method and also it does not load the value from the shared or main memory to the cached memory of thread. Thus, we need to take care of proper synchronization with sleep and yield. 

||Start a thread twice?||
No! We cannot start a thread once it is started. If we try to do so then we will receive an illegalThreadStateException. The thread will run for the first time but will throw the exception on the second time. Though, we have to understand that the class extending the thread class and having the run() method will be one thread for one particular object created while if other object is created for the same extending class then it will considered as another thread. This can be checked by running one object twice and running two different object of an extending class. 
Note: This happens because the thread once started comes in running state and cannot be started again because it is not be runnable state. 

||What if we call run() method instead of start()?||
Each thread will start in different call stack where the call stack is the data structure that stores the information of current active thread (program). This mean when the run() is called in the main method, then the run() method goes to the current stack instead of getting to the beginning of the new call stack. Well, recall the program where you have used the sleep() function. There we have called the start method and hence the sleep of first thread gives the active state to other thread and the other threads starts executing until the first is sleeping. Now, in the same example, if run() method was called then sleep would have worked and run() will be executed by the first object with sleep method and once it is completely done then only the run method with the other object will be executed. This means, the object will behave as the simple object, not like the thread object. Check examples for better understanding. 
Note: you make object of class and call the start() method. Then we get the functioning of a thread but if you call run() method then the object of class will behave as simple object.

||Join() method||
Join() method waits for a currently running thread to die so that the joined threads can be executed. This method waits until the thread on which it is called does not terminates. So, in the example given in javaTpoint tutorial, the join method called t1 by “t1.join()”. So, t1 executes first and the other threads t2 and t3 will execute only once t1 is completely executed. You can check the program. Also, we have an option to specify the time until which join should wait the t1 method for execution of t2 and t3. In the nutshell, join() method is used to wait until the thread does not completes its execution to which it is called and we can also specify the time to which the method should wait. 
Note: 
1.	While implement this, make sure that thread which you want to execute is alone i.e. next thread waits for its execution to start() before it is joined. First, start() is called and the join the next thread automatically joins. 
2.	[III] Join method must be placed inside a try catch block otherwise it gives InterruptionException.
3. [III] On which class to class join? Join method whenever called on any thread then the currently running thread has to wait for it. T1.join() simply means that current thread has to wait for t1 execution. 

||Naming a Thread||
The thread class provides the methods to change or get the current name of the thread. By default the names of the thread starts from 0 to n as the number of threads increases of an extending class. We can use the “objectName.getName()” syntax to print the name of the thread. We can change the name of the string by “objectName.setName()”. Then, we can check by printing the name again. 
We have a method called currentThread() in the thread class through which we can get the reference of the currently executing thread. Remember that it returns the reference of the thread but not the name. So, for the name you have to use “Thread.currentThread().getName()”. 

||Thread priority||
Every thread has a priority. The priority is scaled from 1 to 10. In most of the cases scheduler executes the threads according to their priority but not always. It is dependent of JVM specification that which scheduling it chooses. Three constants are defined in the thread classes which are “public static int MIN_PRIORITY”, “public static int NORM_PRIORITY” and “public static int MAX_PRIORITY”. Min is 1, normal is 5 which is default priority as well and max is 10. We can get the priority of any thread by getPriority() and set the priority by setPriority(). We can set the priority by simply writing the number from 1 to 10 or by “Thread.MAX/MIN_PRIORITY”. By putting value of priority less than 1 and more than 10 gives exception. 

||Daemon Thread|| 
•	This thread is used to provide service to the user threads and only fulfill the background tasks. JVM terminates all the daemon thread as soon as all the user class dies. It is of lower priority thread. We have to understand the way to check if the thread is daemon thread and to set a thread as deamon thread. For checking if a thread is daemon or not, we have method called isDaemon(). For setting a thread as daemon, we have a method called setDaemon(). Try an example for better understanding.
•	If we want to make user thread as daemon thread. Then, we can only do it if the thread is not yet started. We will receive an exception even if we try to do so. See, if a thread is not daemon then it will definitely be user thread which means a simple thread. So, when to call a user thread by an object and then try to change it to daemon thread. We will receive an exception. Exception will be illigalThreadStateExcepion. 
Note: Main thread and daemon threads are created by JVM. 

||Java Thread Pool||
Thread pool contains the equal sized threads which are waiting for the job and reused many times. A thread is assigned a work by the service provider and then after work completion it again comes back to the thread pool to get a new job. It saves time since avoids the requirement of creating a new thread. One example of it is its use in the servlets and JSP container. Servlet and JSP container creates a thread pool to handle the request. 
To demonstrate that each thread of the pool handles a single task and then, if all the threads are busy in some task then the new task will be taken when any of the thread becomes free executing the previous task given. Then check: http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor. In this, a class extending thread class has run method which has print statement printing the current thread name and a message (message is actually indicating the current task which was given a parameter to one of the method and used in the run method). Then, a method is made to take a parameter of current task and that is used in the run() method. Another method is made to provide sleep of some time. This method is also used in run() method. A thread pool class is made wh0ere a thread pool of 5 five thread was created (syntax: ExecutorService executor = Executors.newFixedThreadPool(5)). Now then, we will create a for loop that runs 10 times and we will execute the current task (syntax: executor.execute(worker) where worker is the object of thread class). Also, while printing the output of the thread class each time, we will print the task number also. This way, we will get to know the thread number which performs which task and in which order. Also, the concept of thread pool will be clear.Try the program of thread later when get time. @@@Try Example.
[III] Practice creating a pool and executing some task through it in a test class. 

||Thread Group in Java||
The thread group is the set of threads. Java.lang.ThreadGroup includes many groups of threads where each group has a parent except the initial thread group. Check the constructors and methods useful in this class. Now, let’s see the way to create a thread group. Syntax: “ThreadGroup groupName = new ThreadGroup(“Group A”);” “Thread t1 = new Thread(grouypName, new className, “threadName”)”. This way we can first create a group of threads and then we can, kind of, insert the thread in the group. The advantage now is that we can apply some commands in one shot to all the threads in the group by applying it on the group. For example, we can use the getName() method on the thread group to know the names of each thread. 
Note: “System.out.println()” this gives an extra line. @@@Try Example.

||Shutdown Hook||
Shutdown hook is used to clean up the resources before the JVM is closed. When we exit from the command prompt pressing cntl c then user logs off and JVM starts to shut down. So, before shutdown of the JVM, shutdown hook works to clean up the necessary resource. Also, we can add some code that we would like to execute just before JVM shutsdown. [IIII] For this, we have to create a task class which contains the code we want to execute. Then, add that thread as a shutdown hook through addShutDownHook(runnable r) method. This method is of runtime class. So, we have to create a runtime class instance and then use this method. Also, we can halt the execution of the added shutdown hook. Check the syntax. We understood the concept of shutdown hook and just check the actual program later when you get time. 

||Performing Single/multiple Task(s) through Multiple Threads||
This section deals with performing same task with multiple threads and multiple tasks with multiple methods. For this, we must have to understand a concept that each thread runs on a separate callstack. Now, suppose we have a class with a run method. We have created two thread instances and called the start() method from both the object. Then, both threads will work on the same method. That will happen one by one (I think when the class is thread safe). Now, we have to run multiple tasks by multiple threads. So, we have created two classes having a run method. We have created third class and created threads relating to both the class and called the start method. The same is shown through the anonymous classes but that is definitely out of scope now. 
Note: This is actually an example of multitasking using multithreading. @@@Try Example

||Garbage collection||
An object which is not reference currently unnecessarily takes the space in the memory and reduces the efficiency. So, all unreferenced object must be removed or destroyed. An object can be unreferenced by nulling, assigning new reference to it, anonymous object (new Employee()) etc. In C language we have free() method and we have Delete() method in C++ language. However, in java we have even better feature of Garbage Collector which collects all the unreferenced objects. It is performed by Daemon threads. These daemon thread calls the finalize() method of Object class every time before collecting the object. Therefore GC has two main advantages which highly efficient and automatic. But GC is only applicable on collecting those unused objects which are created through new keyword. We have got GC() method of system class which is used to invoke the garbage collector explicitly. But there is no guarantee that garbage collection occurs on request and we cannot force it.  
Note: Object in java can be created in different ways. I have checked some 5-6 ways of creating object. Though, many of the ways use new keyword. So, the other ways does not come under java garbage collector. Not too sure about this. Ideally

||Java Runtime Class||
This class is used to communicate with the java runtime environment. This class has got some important method like invoking GC, get total and free memory etc. There is only one instance of this class available from one class. Check the example later when get time. Currently, it is out of scope. 
Below are some important methods:
1. getRuntime() and exit()
2. addShutDownHook()
3. freeMemory and totalMemory().
Note: we can open a notepad: Runtime.getRuntime().exec("notepad").

Note:
1.	ThreadLocal is a class through which we can create variable. The advantage of creating variable this way is that each thread gets its own copy of that variable and thus we get variable level thread safety. We need to create its instance and set() the value. 
2.	Thread leak happens when an application does not releases the reference of a thread and those thread were not garbage collected. 
3. Explore how thread pool is benefitial? How to create a thread pool? What is the risk with thread pool?
Threadpool is group of fixed number of thread which are created and waiting in runnable state to be used for processing any task. Thread scheduler picks a thread for processing a task and once task is done then the thread goes back in the thread pool in runnable state. We can improve the performance of an application with threadpool as it saves time in new thread because we already have threads in pool created and in runnable state. One real time usage of Thread pool is in web containers managing JSP and servlets. 
In web container, if for every new request we give a new thread by creating on the spot then it will be a lot of overhead in managing the life cycle of the thread only. Therefore, thread pool seems to be a good idea where a set of threads are already created in the thread pool in runnable state. This will save alot of time as skips creating and termination of a thread. In fact, the same set of threads can be used multiple times for handling new request.
In java, we have executor framework consisting of executor interface, ExecutorService sub interface and Executor class. Below is the code for crearting the thread pool. 
ExecutorService pool = Executors.newFixedThreadPool(MAX_T);
So, as we can see we have used newFixedThreadPool() api of Executors class to get pool. Now, we will process a task using the thread from a pool. 
//creating a task
Runnable task1 = new Task("Task1");
pool.execute(task1);
In above code, we have created a task through a class called Task which implements Runnable interface and override the run method. Then, we pass this task object to execute method of pool. Likewise, we can create many task and execute through pool. Once all the threads in the pool is in running state then all other received task goes in queue. 
Risk with Thread Pool: [IIII]
a. DeadLock: Deadlock can occur in any multithreaded environment while thread pool is another case of deadlock. One possible situation of deadlock in thread pool could be when all the running threads are waiting the response of a blocked thread due to unavailability of thread. There could be other scenarios which can cause deadlock. 
b. Thread Leakage: In some scenarios, running thread does not return back to the pool which causes reduction in the size of the thread. One such scenario could be an exception occurs while a thread is running and thread class does not handles the exception then that thread goes out of thread pool. 
c. Resouce Threashing: We need to be careful regarding the numbers of threads in threadpool. If we have threads more than the optimal number then a lot of time will get wasted in context switching. 
Also, we must make sure we close the thread pool explicitly by calling shutdown() method of the thread. 

5. Why wait, notify and notifyAll methods are in object class but not in thread class. 
Hypothetical Situation: We have a dark room with a lot of containers and people. Assume each container as java object and container’s handle as monitor of the object. Now, imagine different people trying to grab some container through its handle. Here, people are different threads trying to grab an object through its monitor. A thread does not know about the object which other threads are trying to acquire thus consider the room is dark i.e. one person does not know about which container other person is trying to grab. However, assume hypothetically that each container knows what different people trying to grab it. This means an object knows about different threads trying to acquire it.
Now, person 1 has already acquired a container A and person 2 & 3 are trying to grab it. Person 1 has release the handle of the container and will wait to grab the handle again after any of the person notifies. This is just like wait method where a thread leaves the monitor of an object but waits for notification from other thread to acquire it back. 
Now, after person 1, person 2 has acquired container A through its handle. Person 2 however is done with the containers work and does wants to release the handdle of container and not want to grab it back. Then, it will notify a particular person or everyone waiting for the container. However, as I said the room is dark thus one person does not know what other person needs, but containers does. Similarly, threads once done with an object would want to call notify or notifyAll however they do not know which set of threads to notify. But, object does has this info. Therefore, the thread uses the method of object class notify and notifyAll. 

Straight Answer: The implementation of wait, notify and notifyAll in Object class rather than thread class is one of the design decision taken by its designers of java. This decision can be based on multiple reasons. The key reason is that a thread does not have knowledge about which object does other threads need however it’s the object that has the wait stack associated to it which has the list of the threads waiting on it. Thus, thread cannot notify or notifyAll directly to other thread because for it must know which set of threads needs the object it is just done with. Secondly, we should see these methods as action of object class managing the communication between threads. Also, java follow the concept of monitor and each thread need to have the monitor of an object in order to acquire it. Wait, notify and notifyAll are called on an object thus they are implemented in object class. Other way of looking at it is that this inter thread communication related to every object in java thus implemented in Object class so that it can be used by all the objects. Another arugmnet is that since sleep() method does only care about a current thread and thus is it implemented in thread class. 

What if its in thread class? 
We would need a framework where a thread can get information about the set of threads that need a particular container which the thread is just done with or else it would not be possible. 

6. Producer and Consumer Problem
Assume we have two threads t1 and t2. T1 fills the data in from front of the queue while t2 takes the data out from the back of the queue. T1 is called as producer thread and T2 is called as consumer thread. Now, the producer problem statement says if the queue gets full then producer should not try to add element and when the queue gets empty then consumer should not try to remove item. Well, we can implement this in java. On a very high level, what we have to do is we need to call wait method from once queue gets full. When consumer removes an element from queue next time then we should call notify method for producer. When queue gets empty then wait method is called on consumer thread. When producer placed an element in queue then notify method should be called for consumer. This is also called as bounded buffer problem. Also, a direct solution for this issue is to use BlockingQueue which is concurrent version of Queue. 

7. Some insight on Volatile Keyword
In multithreading environment, thread safety is very important. Thread safety involves two things manily which are mutual exclusion and visibility. Mutual exclusion means one thread or process will work on a piece of code at a time and visibility means change done by one thread on shared resource is visible to all other threads. Sometime we just needs only visibility. For example, threads of different processecors will get their own local copy of shared object. Thus, we really do not need to manage the mutual exclusion but changes done by one thread may not reach to thread 2 copy and can lead to inconsistency. Therefore, we just need to manage visibility. Volatile comes to rescue here. Volatile only takes care of visibility which means if a vairble is defined volatile then change related to it will done only in the main memory but not in cache or copy of that var and thus available to all threads. [III] Also, whenever we feel that multiple thread might update and use the value of a variable then we must use volatile keyword.
8. [III] Thread dump is a way of finding out what all threads in your application is doing including the services threads. The thread dump becomes really important when your application getting hang or becomming slow. We can get the thread dump in UNIX/LINUX system using command "kill -3" and "Cntl+break" on windows.
Three ways to find thread dump of java application:
1.	Using JStack tool in JDK. Jstack –l <pid> <file Path>. File path is for the file in which thread dump will be written.  
2.	Sometimes due to security reasons only jre is installed in the server. Thus, we cannot use Jstack. In this situation, we can use command “kill -3 <pid>”
3.	We can also use GUI based tool like JVisualVM. 
9. Why notifyAll() is safer than notify()? Notify() send notification to only one thread out of many threads waiting for accquiring the lock. That one thread gets the notification is based on OS. [III] If for some reason that choosen thread does not process and goes in wait then we will face deadlock. So, notifyAll() which notify all the waiting threads will not potentially reach to such situation. Thus, notifyAll() is safer than notify().
10. When a thread calls wait method then it looses its lock. Other thread cannot uses the lock even when the lock is free. Once the thread just went called wait also calls notify or notifyAll(). NotifyAll() reaches to all the threads in the wait stack of that object. Then, its upto thread scheduler to provide lock among which of the waiting thread.
11. We must call wait, notify and notifyAll method inside synchronized block because its all the action of an object over a thread which has acquired its lock. We can understand it with an example. In standard producer and consumer problem if we implement it without synchronization but just using wait and notify then thing will go wrong. Suppose if consumer tries to get value from queue but the queue is empty then consumer thread should call wait(). But at the same time (since its not synchronized) producer insert an element and call notify but since consumer went to wait exactly same time then can miss the notify. If we are unlucky and if producer does not put any further element then we can face deadlock. 
11. [III] Concept of wait set! Just like each object has monitor associated with it, each object also has a wait set. This wait set will be empty initially when the object was created. Later, it will have the list of the threads waiting on the object. This another key reason why wait, notify and notifyAll() are implemented in object class rather than thread class since thread class does not have knowledge about what different threads waiting on an object.
12. [III] In the case, where a thread is in waiting set of an object and a notify is called and interrupting for that thread is called together. Then, if notification came marginally first and that thread by chance got the notification then thread will be removed normally from wait set and its interrupt flag will not be set. On the other hand, if interrupt came marginally before than notify then thread will be removed from the call stack with throwing interruptexcepition and setting interrupt flag set true. Also, this will not cause the notification to be lost but some other thread will receive the notification. 







=====================================================================================
Java Synchronization 

||Synchronization in Java||
Synchronization in java is capability to control the access of multiple threads to any shared resource. Actually, when multiple threads try to access a shared resource then the problem of thread interference and inconsistency occurs. So, we have thread safety which is done through synchronization and letting only one thread to use the shared resource at a time. Synchronization is of two types which are process sync and thread sync. We will discuss thread sync here. Thread sync is further classified into Mutual Exclusive and Cooperation. In examples, we have given an idea when multiple threads works on a single object (object of task) then the inconsistency occurs. So, we have used the keyword Synchronized in the method signature with the class whose object was worked by threads. Except this, everything else looks same as the normal program. Check the examples in details later when have time. 

Concept of lock – Every object has a lock or monitor. A thread that needs consistent access of the object will require having the lock of the object. Once the thread is done then it should release the lock.

Mutual Exclusive - This helps to prevent the thread interference when multiple threads try to use a shared resource. This can be done in three ways which are synchronized block, synchronized method and by static synchronization.

Synchronization Method – Suppose you have a class which performs some task. Now, you have created an object of that class. Then, you have created multiple threads which try to access the same object. So, for maintaining the consistency we will use the keyword Synchronized with the method whose object is shared as the shared resource.  @@@Try Example

Note: The synchronization done through putting synchronyzed keyword with method signature, actually behind the scene capture the monitor of a particular resource. Now, when other multiple method of a class is using synchronization then the monitor used will be same. The basis is same in all the synchronized method of a class, so if a thread occupies the lock of one method then other thread cannot even access the other synchronized method of the same class. Obviously, non synchronized method can be called by any number of threads any time.  

||Synchronized Block||
This is similar to synchronized method. If you want synchronization for some part of the code in the class then you can create a block like this “Synchronized(this) { code to be synchronized}”. It will work same as synchronized method. Can we have a block inside a method? Yes. In fact, in the example itself the block is inside the method. Synchronized keyword was used with block instead. There is some difference in rules for static and non static block. Why not try and check. @@@Try Example
The synchronization block is syntax is synchronization(this){code}. This can be any object while generally this keyword.

||Static Synchronization||
In simplest term, static synchronization is about providing synchronization for static methods of the class. Do not get confused with inter class thread false concept. We used synchronized keyword with static method to have static synchronization. [IIII] Also, we can have synchronized block also inside a static method where we do not use this keyword however we use “ClassName.class”.
Note: [III]
1. How actually synchronization makes a piece of code thread safe? Actually, when a thread tries to access anys ynchornized block then it checks in the heap to give (or to update heap with) the most updated code to the currently accessing thread. This is one aspect which is related to visibility. 
2. When synchronization is done with non static methods then that is normal synchronization on the object, not on the class level. However, when synchronized keyword is used with static method then synchronization goes from object level to class level. Also, if synchronized keyword is used with any static method then we are talking about the static synchronization by default. 

||Deadlock in Java||
It is a situation where we have two threads A and B. A is waiting for the object which is acquired by B and B is waiting for the object acquired by A. This situation is called as Deadlock. Check the example. 
Note: [III]
1.	Starvation is a situation when a thread not able to access a target resource for a long time.
2.	Thread.join could definitely be a potential reason for thread deadlock situation.  

||Inter Thread Communication or Co-operation in Java||
Inter thread communication means when synchronized threads talk to each other. There are some situations where threads exchange information. This is similar to process communication. The thread pauses in some stage of execution of task. It releases the lock as well. Then, some other thread gets the lock and begins its task on the same object. The first thread will wait until it is not notified by second thread or to a specified time. Let’s see the important method of the object class related to co-operation.  Also, these methods are of object class, not of thread class this is because it acts on lock which is a part of a lock.   
1.	Wait() – It takes the current working thread to a wait state. It will be in wait state until other thread does not notify using notif() and notifyAll() method. 
2.	Notify() – This method is used to notify the first thread by the second thread that it is done with the object. If multiple threads are waiting to be notified then only one thread will be notified and its selection will be random. 
3.	NotifyAll() – This wakes up all the threads which are waiting for the object. 
Note: [III] Thread release in case of Notify() and NotifyAll()! If there is n threads in the call stack of A object and a notify() is called by the thread currently acquiring A then any one of the thread will be removed from the wait setand the thread that will be removed will depend on OS. In case, if notifyAll() method is called then all the threads from the wait set will be removed. However, in any case, later on only one thread will get the lock.  

[III] Difference between wait() and Sleep() –
1.	Wait() releases the lock while sleep() does not.
2.	Wait relates to object class while sleep relates to thread class.
3.	Wait is a non-static method while sleep is a static method. 
4. 	Wait is a final method while sleep is not a final method. 
Check the example carefully later. 

||Interrupting a thread|| [III]
If a thread is in wait or sleep state then calling the interrupt method will force the thread to come out of sleep or wait. It will throw an exception InterruptedException. The thread will stop working if exception is not handled though will work soon as the exception is handled. If a thread is not in wait or sleep state then the thread will behave normally the interrupted flag will be set true. We have three methods in the thread class related to interruption which are interrupt(), interrupted() and IsInterrupt(). Interrupt() is to interrupt a thread. Interrupted() method is used to get the interrupted flag and to set the flag to false if its true. IsInterrupted() method just gets you the flag.  
Note: 
1.	A thread can call interrupt method on some other thread or on itself which will ultimately cause that thread to be removed from the call stack with an interruptedException been thrown. The interrupt flag also sets to true.  

||Reentrant Monitor in Java|| [III]
We want to talk about reentrant lock instead of ReentrantLock class which is implementation of Lock interface. Reentrant lock, as the name suggest, can let same thread to re enter on a monitor again. Like, if two methods using the same monitor for synchronization then a thread can access that method B when called from method B just like it is called directly. I guess the default lock in java is reentant. 
Note(s): [III]
1.	Synchronized keyword can be used with blocks (non static), instance method and static method. It cannot be used with constructor and static blocks. We can use synchronized keyword with run method too. Although, we may find very rare scenario where you would like to do this. Some people might say that its completely pointless to synchronize run method because this will cause sequentializing thread for run method.
2.	If a thread enter a synchronized instance method then it can access all other sycnhronized instance method as it got the object level lock and other threads has to wait. While if the class entered a synchronized static method then it can access all the static methods of the class and other thread has to wait. 
3.	When one thread works on a synchronized method after acquiring the lock, the other thread that want to use the method waits in the waiting stack. Once the running thread is done and it invokes notify() method then any one of the waiting thead gets notified and wakes up. The choice is quite undeterministic and it depends on the implementation of OS. However, if notifyAll() invoked then all the thread gets notification and wakes up. Then, it is the decision of thread scheduler to decide to which thread it should call which is based on factor like priority and other. This is more logical and fair then calling notify method.
4.	Now, how to decide when to use notify and notifyAll? Whenever we are 100% sure that if we call notify method and any certain thread will be notified then we should go ahread suing it. However, if not sure, then it is always better to use notifyAll. Also, notify method can cause deadlock while notifyAll method wont. 


=====================================================================================
Java Concurrency
(Source: https://www.tutorialspoint.com/java_concurrency/index.htm)
Java.util.concurrent package was added for the first time in java 5 version. But, what was the purpose of adding this packge or what benefit it gives? Mutlithreading or concurrent programming let achive a developer the state where multiple part of a program can run simultaneously or multiple thread can a same piece of code simultaneously. However, this isn’t considered easy because of the possible issue like using the shared resource without corrupting it or getting the latest state of a resource. Concurrent package gives us a set of ready to use data structures and utilities which makes concurrent programming easier. Even the java doc official site describes concurrent package as utility containing interfaces and classes helpful in developing concurrent application. The major units of concurrent package are Executors, Queues, concurrent collection, Time unit class, Synchronizers and other. 

||Lock Interface||
In java, synchronization is based on acquiring monitor (intrinsic lock) of an object to work on it. With synchronized keyword, a thread can only access the resource if has its monitor. Similarly, lock interface gives you another way to manage lock of an object with better control. Below are some significant difference between lock interface and synchronized block way of managing lock. 
1.	[IIII] Guarantee of Sequence: with synchronized block, we cannot predict the sequence in which threads will get chance of accessing resource while they are waiting for the resource. However, with lock interface we can manage the sequence in which thread can acquire the resource monitor. Sequence can be managed by creating a fair lock which let thread aquire the lock in the order they request for the lock. We can create fair lock something like this “Lock lock = new ReentrantLock(true);”.
2.	Timeout: In synchronized block, the concept of time until which a thread should not wait for an object exist. We cannot manage the timeout with synchronized keyword. However, we can set the timeout up to which thread should wait for a resource lock with lock interface. 
3.	Multiple Method: With synchronized keyword, we can setup synchronization with a single method however, we can have across multiple method in lock interface. 
4.	We also ReadWrite lock which can be used is not an option with synchronized keyword way of synchronization. This we can achive through ReadWriteInterface. 
Let’s check the important methods of lock interface: [IIII]
1.	Public void lock(): Acquires lock for you. 
2.	Public void tryLock(): Acquires lock for you if lock is free otherwise returns back immediately. It does not wait. 
3.	Public void tryLock(long time, timeUnit unit): Acquire lock for you if lock if free within the specified time as argument and also, unitl the current thread is not interrupted. 
4.	Public void unlock(): This will release the lock. 
5.	Public Condition newCondition(): This returns you a conition that gets bound to the lock. 
6.	Public void lockInterruptibly(): This will get you a lock with the thread is not interrupted. 
Note: 
1.	Reentrant lock class implements lock interface.
2.	With Lock interface timeout feature we can make sure deadlock free application as any thread would not wait for getting lock forever.
 
||ReadWriteLock Interface|| [IIII]
This interface provides dual lock. Read lock that can be acquired by multiple threads at a time if no thread has acquired write lock while write lock that can be acquired by just one thread at a time provided to other thread has write or read lock. 
Below are the important methods of ReadWriteLock Interface:
1.	Public void ReadLock(): This will get you read lock.
2.	Public void WriteLock(): This will get you write lock. 
Example:
ReadWriteLock rwlock = new ReentrantReadWriteLock();
rwlock.readLock().lock();
rwlock.readLock().unlock();
Note: 
1.	ReentrantReadWritelock class implements ReadWriteLock interface. While ReadWriteLock interface does not implements the Lock interface.  
2.	A thread cannot acquire write lock when even a single thread holding read lock. Thus, this way we protects that the read by a thread does not have un-upated value. 
3.	With readLock() method, we get the read lock and then we need to call lock and unlock methods. Similar, goes with writeLock() method. 

||Condition Interface|| [IIII]
Condition Interface has methods equivalent to wait, notify and notifyAll of the object class which are used in synchronized keyword way for synchronization. With condition object, we can bind a condition on the lock which should have created using lock interface. Once we create condition then we can call methods of condition interface for thread communication. We should create the object of condition interface or a new condition through newCondition method of Lock interface. 
Below are the methods of Condition interface:
1.	Public void await(): This is equivalent to wait method which causes a thread to wait until it is not signalled or interrupted. 
2.	Public void await(Long time, TimeUnit unit): This will cause a thread to wait until it is not signalled or interrupted or a time is not elapsed. 
3.	Public void awaitNanos(Long time): It is equivalent to above method but it is only accept time in nano second. 
4.	Public void awaitInterruptibly(): It will wait until the thread is not interrupted. 
5.	Public void signal(): This is equivalent to notify method of object class which will signal one of the waiting thread. 
6.	Public void signalAll(): This will notify/wake all the waiting threads.  
Note:
1.	The condition object can be created using ReentrantReadWriteLock class by first getting the lock through readLock() or writeLock() and then calling newCondition().

||Atomic Variables||
Java.util.concurrent.Atomic package got the classes that support/provides atomic vairbles. All the classes has got set and get methods which work as read and write methods on volatile variables. With volatile variables, we create assurance in multithreaded environment that each thread will get the latest value of the variable declared volatile. If we can do this through volatile then whats the need to use atomic variables? Well, in simple or superficial way, I would say with continous more than one read or write operations, volatile variables do not guarantee the atomicity while atomic variables do. With this I mean, i++ is a combined operation of get i and increment i which is two operations in itself. Here, volatile may not guarantee atomicity. Thus, we should use methods of atomic variable class to ensure the atomic operation. 
[IIII] Another important thing is that atomic variable does not uses synchronization lock concept then how does they provide atomicity. This can be understood by internal working of its methods. Atomic variable classes use compare and swap low level operations. With this, they only allow you to modify a value if the value originally equal to your exected value. Also, it does not just compares once but it runs a loop which compare your expected value with the original value multiple time but modify only if both matches. This way it provides atomic operation. Below can take taken as simple internal implementation of atomic variable methods:
int current;
do {
  current = get();
} while(!compareAndSet(current, current + 1));

We have many classes in this package for different primitive data type like AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference and Other. 
Atomic Integer supports atomic operation on underlying int value. Important methods of atomic integer class are below:
1.	Public int get(): Gets you the value of int. 
2.	Public void set(int newValue): sets new value to int variable. 
3.	Public int addAndGet(int delta): First it atomically adds the delta to the original number and then gets the new value of the variable. Its just like ++a.
4.	Public int getAndAdd(int delta): First it gets you the original value and then it adds to the variable. Its just like a++.
Similarly, we have many other method which we can work if find some scope later. 
Note: We may have different atomic classes having different methods. However, we can go in depth of it if needed in future.

||Executor||
Executor interface is used to launch task in through multiple threads in multithreaded environment. I came across with two of its implementation which are newFixedSizeThreadPool(Size) and newCachedThreadPool(). The key method of Executor interface is execute(). Also, I guess this just support launching the task while to shutdown the executor we might need to create ThreadPoolExecutor object and call shutdown method. 
A sample program is pending. 
 
||ExecutorService||
ExecutorService interface is a sub interface of Executor interface and adds feature to manage the lifecycle of the task as well as executor. 	One of the class implementing ExecutorService interface is newSingleThreadExecutor class. Although, there are many interesting methods it has while the most basic methods are below:
1.	<T> Future <T> submits(): This submits a task for execution and return a future value that would be returned by the task. 
2.	Public void shutdown(): It initiates an orderly shutdown in which previously submitted tasks get executed while no new task gets picked up. 
3.	Boolean awaitedTermination(long timeout, TimeUnit unit): Blocks all tasks have been completed execution after a shutdown request, or thread is interrupted or timeout happens, whichever happens first. 

||ScheduledExecutorService||
It is a subinterface of ExecutorService interface and supports future or periodic execution of task. We can schedule a task for future or can have it periodically to run. We can create its object through newSceduledThreadPool class. One of its method is scehduleAtFixedRate().
We can get in depth as and when needed, but not now. 

||Thread Pool||
Thread pool is a pool of threads that works to execute task in a queue. We have many thread pool classes in concurrent package. However, we can create our own thread pool too which we can have a look once we done with all the existing thread pool classes. 

||Executors Class||
This class has many methods which returns newly created thread pool in the form of Executor and ExecutorService instances. We have different methods for getting different type of thread pool. Lets look at some important executors class method below:
1.	Public Static ExecutorService newFixedThreadPool(int threadCount): This method takes the argument as number of threads needed in the thread pool return. It return thread pool of fixed number of thread. Once all the threads are buzy executing task then newer task received will be queued and remain queued until no threads gets free. 
2.	Public static ExecutorService newCachedThreadPool(): This method return a thread pool which is expandable. Such executor is suitable for application that launches many small tasks. 
3.	Public Static ScheduledExecutorService newScheduledExecutorService(int corePoolSize): It ask for the core pool size and gives task instance of SceduledExecutorService interface which has thread pool that can run a command after certain delay or periodically. We woud like to have when we want to schedule task for future or want it to run periodically. 
4.	Public static newSingleThreadScedularExecutor(): This will give back scheduleExecutorService object which has one thread executing task and if that thread fails or terminates for any reason then a new thread should be created. However, at a time, only thread will be working. It is similar to newScheduleExecutorService(1) but the only difference if the single thread gets terminated here then no new thread will be created to replace it. 

||ExecutorThreadPool Class||
This class is an executor service to execute each submitted task using one of the possible thread from the thread pool. This class provides various methods for checking the statistics of the thread and better controlling it. This class implements the executorService interface and thus implements important methods like submit(), shutdown() and other of executorService interface. It also has its own methods too. We can have a look on it in detail if needed.

||ScheduledExecutorThreadPool class||
It is a subclass of ExecutorThreadPool class and have additional methods that supports the scheduling of execution of a task in future and also for periodic execution. We can have a indepth look later if needed.  
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);

Note:
1.	We have got different executor interfaces which are Executor, ExecutorService, ScheduledExecutorService and classes ExecutorThreadPool and ScheduledThreadPool are for launching some task through one of the thread of the threadpool. 

||Concurrent Collections||
Collections are very important part for any application as it stores data. In the multi threaded environment of java, the data stored in these collection is potentially gets interacted by multiple threads simultaneously. Many classes like ArrayList, LinkedList, HashMap in java collection hierarchy are not synchronized. However, we have methods in collections class that gives us the synchronized version of these collection classes. But the performance of these sycronized collection classes are quite low. Therefore, in concurrent package, concurrent collections were introduced which are suitable for multithreaded java environment and has better performance. Also, concurrent collection does not throw concurrentModificationException when two threads tried to read and write on it. On this note, lets check the different concurrent collection classes. 

|List|
List collection interface has three implementations which are ArrayList, LinkedList and Vector. Vector is already a synchronized collection while we can have synchronized version of ArrayList and LinkedList through static method SynchronizeList() of collections class which takes argument as object of any implementation of list. SynchronizeList() method returns the same implementation after making all its methods as synchronized. Thus, whenever a thread processing a list, blocks all the methods of the list. This way we get a synchronized list. Also, we need to keep in mind that while iterating the synchronized version of the list we must wrap it inside the synchronized block. This should be because synchronization works for an individual method while for a compound operation it needs synchrozation to be managed explicitly. Regarding performance, it is not as good because as it applies a lock on the list (wide lock) and making all methods as synchronized. 
We can use CopyOnWriteArrayList as a part of concurrent package as concurrent arraylist which allows multiple threads to work on the list concurrently. This is because for each structural change of the list, a copy of that is created and the structural difference is made on it. Also, the performance of CopyOnWriteArraylist is better than synchronized list but we still should prefer using it only when we majorly do iteration while rarely do modification. This is simply because for each modification it creates a copy. Also, I feel we do not have concurrent class for LinkedList in concurrent package.
Comparison between CopyOnWriteArrayList and synchronized ArrayList: [IIII]
CopyOnWriteArrayList creates a brand new concurrent ArrayList which used reentrant lock while Synchronized list converts the already existing arraylist which uses the intrinsic lock. With COWAL, multiple threads can operate at a time as for every write operation a new copy is created and then the latest version is given to all while only one thread can be used with SAL at a time. COWAL is fail safe and never thorws concurrentModificationException on modification on iteration while SAL is fail fast and throws concurrentModificationException. We must need to have synchronized block while iterating with SAL, however there isn’t any such restrictions with COWAL. COWAL does not support remove operation during iteration while SAL does like normal AL. 
SAL should only be used when we need a thread safe version of a normal list in multithreaded environment. SAL degrads the performance. Thus, we must need to use COWAL which is much more efficient and has got many advanatges over SAL.
Note:
1.	CopyOnWriteArrayList gets a fresh copy for every update operation which get synchronized with the original at a certain time which is taken care by JVM. This way read value does not gets affected. So, we can say when in between the time a copy is created for modification in COWAL and it is updated in the heap where AL is created. We might not get the latest value when we try to read. While iterating COWAL, iterator() method of it returns an immutable copy of AL and thus any update done after calling interator() is missed. In the next iteration that value will be received. 

|Map|
Just like list, we have synchronize methods for set and Map in collections class which are sycnhronizeSet() and synchronizeMap(). These synchronized versions works exactly the same as synchronize method of list which makes all methods as synchronize and while iteration needs synchronize explicitly. 
The underlying datastructure for concurrent hashmap is hashtable. In concurrent hashmap, the object is divided into different segment according to the concurrency level. The default concurrency level of a concurrentHAshmap is 16. In concurrentHashmap, any numbers of threads can perform iteration simultaneously. However, updation of a thread needs to acquire lock of a particular segment. This is called as segment locking or bucket locking. Therefore, at a time for a normal concurrentHashmap 16 updation operation can be performed at a time. 
Note: 
1.	[IIII] Null insertion in concurrentHashMap is not possible for key or value. This is for a simple reason that the ambiguity of having null cannot be accommodated like in normal hashmap. In case. Get(key) returns null will create ambiguity whether the key is actually null or is not mapped with anything. In non concurrent map, we could have checked this by contains but in concurrent map the map might have checked between the call. The other way of understanding it is if we have to call containsKey() first which checks if the key eixst or not then call get which will get the value of key. In concurrent map, there is a risk that between containsKey and get call, the particular key is removed. This will cause the null to be returned in case of exception in the below code. This isn’t so clear right now!
if (m.containsKey(k)) {
   return m.get(k);
} else {
   throw new KeyNotPresentException();
}

2.	ConcurrentHashMap class has around 5 constructors.
3.	ConcurrentHashMap is better in performance than synchronized version of hashmap because concurrentHashMap as bucket level lock thus multiple updation can happen simultaneously by different threads in java.  
4.	I do not think we have concurrent class version for LinkedHashMap.
5.	ConcurrentMap is a super interface of concurrentHashMap interface. ConcurrentMap interface has a super interface which is Map interface. 

|Set|
We have copyOnWriteArraySet class in java that implements Set interface and gives a concurrent set. The internal implementation of copeOnwriteArraySet is same as COWAL. For this insertion order is preserved and it does not allow duplicates. COWAS also create a separate copy for any update operation. Thus, we should wisely take decision of using it when there are more iteration and less updation. Like COWAL, it is fail safe and cannot perform removal of element during iteration which will otherwise throw unsupportedOperationException.
ConcurrentHashSet can also be derived from concurrentHashMap. For prior to java 8 versions, we can have collections.newSetFromMap(concurrentHashMap) and for java 8 version, we can use concurrentHashMap.newKeySet().  
Note: 
1. We have many options in concurrent package for queue. We will do these when needed.
2. Below is the code shown for getting ConcurrentHashSet from ConcurrentHashMap static method newKeySet().
Set<String> s = ConcurrentHashMap.newKeySet();

|Semaphore|
Semaphore is a synchronization construct that is used to protect a shared resource to be synchronuously accessed by multiple thread and to send signals between threads to avoid any signal to get missed. Semaphore class came as a part of concurrent package in java 5 version, so we do not need to implement our own. The semaphore has a concept of counter and permit. To put it straight, a thread requests permit to access a resource and gets it if the counter of the semaphore is great than 0. Grant of each permit from semaphore to a thread decreases the count of semaphore by 1. When thread no longer needs the permit of the thread, it releases the permits causing an increment in the counter of semaphore. 
Semaphore class has two constructors which are semaphore(int count) and semaphore(int count, Boolean how). Count decides the number of threads that can get permit of a shared resource while how if sent true then permit will be given in the order of request. By default, when how is false, all waiting threads are given access in undefined order. 
Now, we will see how we can use semaphore for setting up synchronized access of a shared resource. We need to create three classes which are driver class, thread class and shared class. Shared class will have a static variable which multiple thread will try to use together. Thread class will have a constructor which will be used in driver class and passing the semaphore object along with thread name. Then, we will create if else condition where if will execute if thread name is A while else will execute if thread name is not A in the run method. If condition code will capture the lock through acquire() method, increment the count value and release the lock through release() method. In the driver class, we will create two objects of thread class and pass semaphore object along with class name. Then, we will call the start method. We will also call join method on both the thread class object so that main thread waits for thread a and thread b. We have used sleep() method in run() method which will actually cause context switching and will give chance to other thread. If semaphore haven’t used then we may have increment and decrement of shares variable randomly. 
Semaphore is also used to send signals between thread just like wait, notify and notifyAll of synchronized block or await, signal, signalAll of lock interface. 
Semaphore Usage Glimpse: 
Semaphore sema = new Semaphore(1); //semaphore with 5 permits
try{
sema.acquire();  //counter -1
//somelogic 
sema.release();  //counter +1
}catch(InterruptedException e) {
	e.printStackTrace();
}
Note:
1.	Good article on semaphore: http://tutorials.jenkov.com/java-concurrency/semaphores.html
2.	How the synchrounous access is managed between threads if the count of semaphore is more than 1? Actually, when semaphores count kept at 1 then it is called as binary semaphore and guarantees mutual exclusion. It is called as binary because it will have permit or not. These two steps only. Need to check here. 
3.	Lock locks a shared resource and has the ownership involved with it. Lock is limited within a scope of process. Mutex is similar to lock which locks a shared resource however mutex scopes for multiple process or threads of multiple resource. Semaphore on the otherside does not involves ownership and the lock is actually shared in the form of permit across different thread and number of threads owning the shared resource will be the count of semaphore. 
4.	A semaphore for managing the shared resource is called simple semaphore. While we have other semaphore which we will study later that are semaphore for signaling, counting semaphore and bounded semaphore.  
5.	[IIII] Why would you want to use semaphore? Hypothetical answer could be like this. If you have written a code which can make let three threads to work simultaneously and if more than 3 thread works on that code then synchronization issues will come. In this case, if we use normal lock then only one thead can use the code at a time and thus we will not be able to use the code in the most efficient way. In this scenario, using semaphore is perfect. Because you can give only three permits for this shared resource and precisely control that max three threads can use the resource at a time. @@@check for more authentic answer. 

|CountDownLatch|
CountDownLatch is a synchronization aid that makes sure a task on a thread to wait for other certain set of threads before starting. It is introduced in java 5 in concurrent package. One good example could be when main thread of the program waits for other service to complete the background task. 
CDL works by having a counter initialized with a number of threads which gets decremented each time a thread completes its execution. When the count reaches to zero then the waiting task gets executed. Below is the pseudocode for a simple CDL program:
//Main thread start
//Create CountDownLatch for N threads
//Create and start N threads
//Main thread wait on latch
//N threads completes there tasks are returns
//Main thread resume execution

How to code CDL? [IIII]
CDL class has given a constructor which is public void CountDownLatch(int count) where count the number of threads the main thread should wait for on the latch. This count once set cannot be changed anywhere. Then, we should create executor service as pass all the background task and start the executor. The main thread immediately should call CountDownLatch.await() method after starting the executor. At this line, we are actually waiting for latch to complete task. Also, other N thread must have the reference of countDownLatch so that it can call CountDownLatch.countDown() method to send a notification to main thread that it has completed its execution. Each invocation of countdown() method, from background tasks, will cause decrement of count and as soon as count becomes zero, main thread will resume its execution.
Check a good examples of CountDownLatch: 
https://howtodoinjava.com/core-java/multi-threading/when-to-use-countdownlatch-java-concurrency-example-tutorial/
https://javarevisited.blogspot.in/2012/07/countdownlatch-example-in-java.html

  	

|CyclicBarrier| [IIII]
CyclicBarrier is another aid for synchronization in multithreading where a barrier is created against a certains number of threads. A thread waits at the barrier by calling await() method at the barrier. Once specified number of thread invokes await() method at the barrier, it breaks the barrier and let the waiting threads to resumes the execution. 
Check an example here: http://tutorials.jenkov.com/java-util-concurrent/cyclicbarrier.html
In this example, we have to create two classes which are driver class and the other is cyclicBarrierRunnable class. In the cyclic barrier class, we will create two instances of cyclicBarrier and initialize them through a constructor. We will implement Runnable interface and override run method. Here, we will call sleep() method and call await method on first barrier followed by another sleep and wait method. This way, we have created two barriers in our run method. In real, application obviously some business logic will be performed. In the driver class, we will create two barrierAction which are two tasks through runnable. Then, we will create CyclicBarrier objects by passing the number of count and barrier action. Then, we need to pass the cyclicbarrier object to call cyclicBarrierRunnable class. Then call thread class start method by passing cyclicBarrierRunnable object. 

Quick Summary on Semaphore, CountDownLatch and CyclicBarrier:
Well, all the three are very aptly placed in java.util.concurrent package introduced in java 5 since they are utility classes for achiving certain goal in multithreaded environment. It is not be possible to compare all three however being a solution of a multithreading env problem is only common thing. Semaphore is mainly used for providing synchronuous access to a shared resource and to carry out thread communication effectively to avoid miss out any communication. CountDownLatch lets a thread wait to start a task until specified number of thread does not complete their task. It has a narrow scenarios to cover. CyclicBarrier class handle the scenario where a task needs one or more barrier where thread should wait for each other and once each reach to the barrier then barrier breaks and let all threads completes the exection. 

||Queue|| [IIII]
Queue is an abstract data structure in which insertion of value happens from one end while removal of values happens from the other end. Queue is an ordered data structure which follows FIFO pattern. Enqueue operation checks if the queue is full or not first. If the queue is full then it throws an exception and exit the program while if it is not full then it adds a new element at the end. Dequeue is just opposite operation where an element is removed from the front. If the queue is empty then it should throw an exception. 
Queue interface extends Collection and iterable interfaces. LinkedList and priorityQueue are two implementations of Queue. However, both are not thread safe. Therefore, in concurrent package, we have different versions of queue which are concurrent queue. 

|BlockingQueue|
BlockingQueue is a queue interface in java which extends interfaces queue, collection and iterable. It is a concurrent version of normal queue interface. It blocks when you try to dequeuer from it and the queue is empty or if you try to enqueue and the queue is full. The queue will remain blocked until some other thread puts an element into empty queue or takes out an element from a full queue. BlockingQueue interface came as a part of concurrent package in java 5. BlockinQueue is the perfect solution for solving producer and consumer problem which otherwise would need to be manually handled using wait and notifyAll methods. 
Methods of blockingQueue:
Insertion: add(o) which may throw exception if not successful, offer(o) which will return special value if not successful, put(o) blocks the thread if unsuccessful and offer(0, timeOut, timeUnit) will block the thread and wait until the timeout. If reaches timeout then return special value. 
Removal: remove(o) which throws exception if not successful, pull() will return a special value if not successful, take() block the thread if not successful and poll(timeout, TimeUnit) block the thread for a specified time and then returns a special value if unsuccessful. 
Examine: element() return the head of the queue while if queue is empty then it throws an exception, peek() too returns the head of the queue while if queue is empty then returns null. 
Check the example where blockingQueue solving producer consumer problem.   
We have many implementations of BlockingQueue which are ArrayBLockingQueue, DelayQueue, LinkedBlockingQUeue, priorityBlockingQueue and SynchronousQueues. We will have a look on all of these shortly. 

ArrayBlockingQueue
ArrayBlockingQueue class is an implementation of blockingQueue interface which uses array internally. It gives a bounded blockingQueue which mean its size will be fixed at the time blockingQueue is created and cannot be changed. ArrayBlockingQueue stores the elements in FIFO order internally. The head of the queue will be the element which will be in the queue for longest time while the tail will be the element in the queue for shortest time. 
Try a simple example later. 

DelayQueue
DelayQueue is another imeplementation of BlockingQueue interface which does not let consumer to consume an element until the preset delay is not expired. Element to be inserted in the delay queue needs to implement delayed interface and should implement method getDelay(). Delayed interface extends comparable interface and thus delayed objects can be compared. We can create a delay	 interface element and while putting the element in the delayqueue using put() method. I think while creating the delayed interface implementation class we can specify the delay time. 

LinkedBlockingQueue
LinkedBlockingQueue is another implementation of blockingQueue interface. LBQ internally uses linked structure to create a queue. We can have an upper bound if we wish otherwise Integer.MAX_INT will be used as upper bound. This means we do not necessarily need to specify the size which is an advantage. It also stores th	e element in FIFO pattern with head as element with longest time in the queue and tail as element with the shortest time. 

PriorityBlockingQueue
PriorityBlockingQueue gives the feature of blocking the thread while enqueuing a full queue or dequeuing an empty queue with characteristic of priorityQueue where elements are order in their natural order or sorted according to the comparator passed. Priority blocking queue cannot contain any null value. Also, PBQ does not enforce any special behavior amoung equal priority elements. Iterator does not guarantee the iteration of element PBQ in order.
SynchronousQueue
SQ can contains only one element internally. A thread inserting elements in SQ gets blocked after inserting one element util some other thread does not dequeue an element. Similarly, if a thread trying to dequeue element from an SQ gets blocked after dequeuing an element util some thread does not enqueue an element. 	
BlockingDeque
Firstly, lets understand deque. Deque is also called as double ended queue which I feel is very apt because it allows the enque and deque from both ends. This was it gives you feature of queue and stack in single data structure. Basic operations performed on a deque are insertFront(), insertBack(), deleteFront() and deleteBack(). 
BlockingDeque is a deque which blocks a thread which tries to insert or remove elemenet when its not possible until someother thread works on the same deque and makes it possible for the first to carryout same operation. BlockingDeque can also be a ready to use solution for producer and consumer problem with thread possible can insert from either ends. 
BlockingDeque has similar methods has we have in blocking queue however we need to suffix either first or last in all the methods. For example: putFirst() or putLast(). 
Also, BlockingDeque is a sub interface of BlockingQUeue and hence we can use it as blockingQueue as well. Then, blockingDeque will insert the element from rare end while remove the element from the front end. Also, mind the methods 
LinkedBlockingDeque
LinkedBlockingDeque is one the implementations of BlockingDeque interface. LBD blocks the thread inserting or removing when its not possible. We have the simple sintax for using LBD. 

ConcurrentNavigationalMap
Firstly, let’s have a look on NavigationalMap. Navgational maps extends sortedMap interface which itself extends Map interface. NavigationalMap has characteristic of sorted map along with some navigational methods. Treemap is one of its implementation. Methods of NavigationalMap like subMap, HeadMap and some other returns map. ConcurrentNavgationalMap returns concurrently accessible map from methods like subMap, HeadMap and other. 
Check in detail later, if needed. 

Exchanger
Exchanger class in concurrent package represent a randezvous point where two threads can exchange object. This class has a couple of exchange method. 

=====================================================================================
Java Memory Model [IIII]
(Source: https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html)
First of all, let’s understand what java memory model is all about. Java Memory model describes whether the execution trace is legal execution of the program or not. In more of multithreading aspect, JMM describes when one thread’s action is guaranteed to be visible to other. Good understanding of JMM is quiet essential for writing multithreaded program since JMM covers knowhow which helps to avoid visibility and race condition related issues in multithreading environment. 
Also, JMM is quite an achievement because, previously, memory models were specific to each processor architecture. JMM is a cross platform model which takes the portability beyond just compiling and executing a piece on code on different platform but it actually gives you same behavior too. Designers took java 5 to get JMM right and since them we do not have change in the JMM. So, let’s get started JMM knowhow.  
Shared Objects
JVM uses the memory of underlying computer its running on and divides the memory as stack and heap. Stack captures all the methods call a thread should have taken to reach an execution point. Each thread has separate stack which other thread cannot see. On the other hand, heap is the shared memory. All the primitive local variable created lies on the stack. Reference of the object type local variable lies on the stack while the actual object get created in the heap. Instance variable and static variable of primitive as well as obect type lies in the heap area. This also means that each thread will have its own different local variable and reference of object type local variable but will share the same instance and static variables. Also, if an instance variable is created and assigned to a local variable then also instance variable will be created in heap. 
Let us try and understand the creation of the variables in different memory through an example below: 
public class MyRunnable implements Runnable() {

    public void run() {
        methodOne();
    }

    public void methodOne() {
        int localVariable1 = 45;

        MySharedObject localVariable2 =
            MySharedObject.sharedInstance;

        //... do more with local variables.

        methodTwo();
    }

    public void methodTwo() {
        Integer localVariable1 = new Integer(99);

        //... do more with local variable.
    }
}

public class MySharedObject {

    //static variable pointing to instance of MySharedObject

    public static final MySharedObject sharedInstance =
        new MySharedObject();


    //member variables pointing to two objects on the heap

    public Integer object2 = new Integer(22);
    public Integer object4 = new Integer(44);

    public long member1 = 12345;
    public long member1 = 67890;
}

The above piece of code’s variables creation can be depicted like the below diagram. 
 
The methodOne() has localVariable1 which is primitive type and thus each thread has a separate copy. localVatiable2 is a object type (sharedVariable) and thus each thread has separate reference but ultimately pointing to the same object of healp (object 3). The object 3 has two internet object which are object 2 and object 4 and reference of each thread will have shared access to these objects too. 
Then, methodtwo() will be called from methodOne() which has a local variable Integer() type which is a object type. Therefore, reference of it is created in stack while actual Integer object created in heap for each. This time both reference is pointing to two different objects in heap since new keyword is used and each thread creates a new object. 
Hardware Memory Architecture
JVM anyway uses the memory of the computer. Thus, we must understand how JVM gets in sync with the memory of the underlying computer on which it is running. Mordern computer has generally have 2 or more CPUs and these CPU may have multiple core. Each CPU (or one core) can run only one thread at a time however multiple CPUs or core can actually run multiple thread concurrently. Also, each CPU has set of register as a memory it can access the fastest. Each CPU also has multi layered cache memory as well. CPU can operate with cache faster than main memory while slower than register memory. All CPU and core shares main memory which nothing but RAM. When a CPU needs to read or write to the main memory then it flushes from registers to cache to main memory. Cache memory also has cache line where some cache lines may take care of writing from cache to main memory while other can read from it. 
Now, we will see what happens when different thread runs on multiple CPUs simulataneously and interacting with different type of variables. We already know that stack and heap lies on the main memory. When two different thread running on different CPUs works on a variable concurrently then there are chances of two problems which are below:
1.	Visibility of update in shared variable to other thread
Assume that two or more thread running on different cores or CPUs is sharing an object which is non volatile and currently in main memory. Once the thread start running it takes the state of that object to its CPUs cache. As long as, the CPU cache does not flush back to the main memory then the state of the object in the main memory remains same. Now, if assume that one of the thread updates the object state and other thread uses to state of the object to implements business logic. Thus, if the CPU cache does not flush in the main memory then the other thread will just take the old state of the object and flaw will occur in the execution of business logic. As a solution, java has a concept of volatile variable. As soon as any thread updates any shared object then its values is updated in the main memory if declared volatile. Thus, any thread taken that object will be get updated value. 
2.	Race condition
When two or more thread uses a shared value and try to update it then it is called as race condition. Now, again assume, we have two thread running on different CPU and sharing a variable count which is currently 1. Both took a copy to its CPUs cache and updated the value. Now, whichever thread flushes the later to the main memory will set the new value of counter. Thus, instead of two increment, counter has just got one increment. This is the issue with race condition. As a solution, java provides synchronization. With synchronization, one thread working on the object locks the object blocking other threads to use it. At the time of locking, a latest or fresh state of the object is taken and worked upon. Then, at the time of releasing the lock, the value if flushed. Therefore, before any other thread take over on that object the value gets flushed from cache to main memory.
Note:
1.	If we have synchronization which flushes the cache object state to main memory after updation and before any other thread acquire it. Then, why do we need volatile? Volatile can definitely be needed in the scenario where the object thread just reading the object for which it does not need lock and using the value in business logic. Thus, it should get the value immediately when updated. While not waiting to synchronization stuff of other thread to over. 
2.	We also has program order, synchronization order, happensbefore order and other few topics that we have done superficially and have to work upon them in depth when needed. 









Actions
Action (inter thread action) is an action performed by one thread which can distantly or directly affect some other thread. These actions are generally reading or writing a volatile or non volatile variable, locking or unlocking a monitor or starting or joining a thread. There can be some other type of execution too which are environment based or divergence action. We can denote an event with a tupel <t,k,v,u> where t is any thread, k is a kind of action, v is variable or monitor involved and u is a randon identifier.  
Also, we only have to concern about the inter thread communication because all thread needs to obey the intra thread semactics. These intra thread semantics states that CPU can reorder the order of execution of a program involving single thread only in such a way that the end result does not changes. CPU does the reordering for fast execution. 
For some real time good examples: https://stackoverflow.com/questions/15654276/interpretation-of-program-order-rule-in-java-concurrency.


=====================================================================================
Java I/O

|Input and Output|
Java I/O is used for processing the input and producing the output. Java uses the concept of stream to make I/O operation faster. Java.io package contains all the classes which are required for input and output operation.
•	Concept of stream – Stream is a sequence of data and the data is in the form of byte. They are of three types which are system.out (output stream), system.in (input stream) and system.err (standard error stream). For example, we use very frequently, system.out.println(“message”) is used to print the output. Similarly, system.err.println(“error message”) is for printing error message at the console. Also, for taking an input from the console we use input stream with syntax: “System.in.println((input data type)variable)”. For example, “System.in.println((char)i)” where char is the data type which is to be taken and input will become value for variable i. 
•	Output Stream – As the name suggest, it is a output stream of data which is used to place the data in the output destinations like a file, an array, peripheral, device or socket. While the input stream is to take the data from such sources. The process of taking the data from the source to the java application and taking data from java application to destinations is done through input and output streams respectively. 
•	Output stream class – it is an abstract class which is extended by each class using the output stream. It uses some methods like write(int), write(byte[]), flush(), close() [check meaning for all the before mentioned methods]. Also, there are different types of output streams which are fileOutputStream, ByteArrayOutputStream and etc. check all the types in later if required. 
•	Input Stream class – It is also an abstract class which is super class to all the classes using the input stream. Also, these have different methods used for different features. Check later if needed. Similar to output stream, it is also of different kind. Check later if needed.  
Note: [III] What are among the top level classes in IO? The most top level classes in IO are InputStream, OutputStream, Reader and Writer. 

|File InputStream and OutputStream|
In simple words, reading data or writing data in a file is done through the Input and output file streams. It is also called as file handling. 
•	File output stream – This is used for writing byte code in any destination file. Firstly, we create an object of fileOutputStream. Then, we create a string and convert it into byte code to write it into file through write() method (since we cannot write directly from string and check what all type of data type we can write through write method). Then close the FileOutputStream by close(). 
•	File Input Stream – it is used to take input from a file and print it on the console as output. Firstly, create the object for the FileInputStream. Now, to read the data (byte code for example) and then, print the char value of the code. The last entry of stream is -1 which is by default so we have used this logic to print till the last value of the text file. As we know that, these streams contain the stream of byte code. So whatever contained in your file will be received in byte code. That is why we have to convert it into char while printing which is done as the syntax in the print statement. If you get error that file not found than to save file at location and file path while declaring the object. Also, make sure that the file is saved in the format declared. Well, try the example for better understanding. 
•	Reading the data from one file and writing it in another file
In this, instead of using the print statement while reading the data from one file we write the content two another file (create the output object beforehand). Also, you can then print the data of the file to which the data is written. Try example for better understanding. 
Advantage: It should be used for basic writing and reading the byte oriented data to or from a file.
Note: [III]
1.	FileOutStream accepts the argument as string or File class object. 
2.	Does the write operation overrides the already existing content of a file? How to control this behavior? When we write the content to the file then it overrides whatever written content however it does not append to what is already written by default. We have a contrutor in FileOutputStream(file, append) which specifies the append to be true or false.  
3.	Forward or backward slash for file path? We can use forward or backward slash in file path. However, we should better use fileseparator class of java for making the code platform independent. 

|ByteArrayOutputStream| 
ByteArrayOutput Streams are used to write the data into the byte array buffer and then used to write into multiple file. Its size increases automatically as required but initially it is 32 bytes which is changeable. Close() method does not make any affect over ByteArrayOutputStream. Here, we use write() method towrite into ByteArrayOutputStream and writeTo() is used to write into FileOutputStream(). Check the example for better understanding. 
Advantage: [III] Why should we consider using ByteArrayOutputStream? ByteArrayOutputStream shoud be good to use since it can increase its size as needed and to replace byteArray containing data to be written.

|SequenceInputStream| 
This class is used to read the data from multiple files. It has got two constructors. First, SequenceInputStream(InputStream1, InputStream2) and second, SequenceInputStream(Enumeration e). First is used for reading data from two files simultaneously and other is used to read the data of an enumeration. Try the example for better understanding. Also, practice for reading the data from two files and instead of printing write it in some third file. 
Must Read - I have used the sequence stream for reading the data from two files and wrote it in a third file. So for writing data into third file, I had made an object of fileoutputstream pointing third file. Therefore, this way I wrote data. Now, when I have to print the data of the third file, I make another object which is of file input stream to read data. I made that object and tried reading the data but got a message at console that file not found. Now, is it because the object that I made for reading the third file points at another location? But when we simply write something is newly created file and then it is printed. Then, it prints the message even when the different objects used for writing and reading (you may have to use two different object for writing and reading). Well, as of now I moving ahead. But later if required then study the topic in detail. I think I must be doing some mistake that time but it should print the msg. verify this.
Advantage: We can use it when we want to read from two files sequentially. Or if we want to read from more file then we need to create an enum of fileInputStream.
Note: [III] Unlike byteArrayOutputStream that can be used to write same content to multiple files, SequenceInputStream is used to read from two files. But not multiple. 

|Java BufferedOutput/InputStream| 
Java bufferoutputStream uses an internal buffer rather than storing the data directly in the stream. It increases the efficiency and hence the performance of the system becomes faster. Buffers are output as well as input type. What I have to do it just to connect the buffer with the respective stream. Else they are all same as file output and input streams. We can use buffer with the byteArray to read multiple array and sequenceinputstream for reading data from multiple file.
Advantage: I think we should always use BufferedInputStream and BufferedOutputStream since it increases the efficiency providing the same functionality as FileInputStream and FileOutputStream.
Note: 
1.	[III] What should we make sure after using reader and witer streams? Make sure to close the object of these classes otherwise program won’t print the values every time.
2.	[III] Efficiency comparison between FileStream class and BufferedStream class! Buffer increase the efficiency by decreasing the number of transfer of data to and from a file. FileStreams class the system class for each byte thus its significantly poor as compared to BufferedStrean. BufferedoutputStream only makes the call to system when flush is used.  
3.	[III] BufferedStream just take only file input or output stream.

|Java FileWriter and FileReader| (file handling in java)
These are for writing and reading data from a text file. They can read and write the character oriented data (unlike byte oriented data in other previous streams). 
•	Java FileWriter class – These are used to write the character oriented data into a file. These are simple, as we do not even have to create string and convert it into byte. But we have to directly insert string data by using write() method. Check example for better understanding. 
•	Java FileReader class – Java is used to read the character oriented data from a file. This is exactly same as streams for reading the data because the data gets internally converted from byte to character. So the difference cannot be made by codes. Check the example for better understanding.
Note:  
1.	While trying an example randomly, I have given the name of the class as “FileWriter” which itself a class and will be treated as the keyword. So, I was not able to import the FileWriter class. Therefore, we should not use the keyword as the class name. 
2.	Make sure to close the object of these classes otherwise program won’t print the values every time.
3. [III] Append or override in case of FileWriter? FileWriter has constructor like FileOutputStream. We can change if we want to append or override the data. By default, it overrides the data. 
4. [III] When to use Char oriented stream over Byte oriented stream? We should opt for char oriented reader and writer when dealing with text files or text data while we should use byte oriented stream when we are dealing with bytes.



|CharArrayWriter Class|
This class is used to write the character oriented data into multiple files. This class implements the appendable interface. Its buffer size increases automatically whenever required. Close() method does not have any affect. This is pretty simple and similar to ByteArrayWriter class but just handles the character oriented data instead of byte oriented data. 
Advantage: it is exactly same as ByteArrayOutputStream along with the API.


|Reading data from keyboard|
We know how to display the data but never looked at how to take data entered at the keyboard. There are few methods for that which are described below.
•	InputStreamReader – This class is used to read data from the keyboard. It first connects to the keyboard and then converts the byte code to characters. BufferReader class is another class which reads the data line by line by readline() method where buffered reader is nothing but a buffer which we connect with the inputStreamreader. Check another example of it which stops taking the input until the user writes stop. Here, do check the while loop condition. It is not working dude!Both logic and syntax is fine but do not know why it is not working.
•	Java Console Class– This class is used to read the input from the console. Java.io.console class is attached with the system internally. It is also used very much to read the password and have different method for that which is readPassword() which is not displayed at the console. Also, the instance or object of the console class is created differently. Its example is giving NullpointerException. It is an eclipse bugs. 
•	Java Scanner class– java scanner class break the input through delimiters that is whitespace by default. Java scanner class extends object class and implements iterator and closeable interfaces. Check the methods of the scanner class which all the related to the tokens (parts of string). That method we have used during cognizant training. Also, look at the to use the delimiter by useDelimeter. 

|PrintStream Class|
PrintStream adds functionality to an outputStream which is to print representation of various data values conveniently. Also, it can be used to print the data at output console if “System.out” is mentioned as the parameter in printStream. It adds to more functionality. First, it does not throw the IOException (most of its methods), unlike outputStreams. Second, it provides an automatic flush. The code is converted into byte internally according to the OS dependent encoding schemes. Thus, it becomes little OS dependent. I have tried an example, where we have to create an output stream and connect with the printStream. Then, we can print the primitive data type values as text through the methods of the printStream class. Also, check the methods of the printStream class.  Errors can be checked by calling checkError() method.
 
|PrintStream VS PrintWriter| [III]
From java 1.0, we have FileOutputStream included in java which is super class of printStream. While we have FileWriter which is included in java1.2, which is super class of PrintWriter. Both these classes are used to print the data into outputstreams and on console as well. However, both are little different from other. First, PrintStream converts the data internally into byte through OS encoding scheme and thus makes itself a bit OS dependent. It can trouble while shifting the application to other platform. On the other hand, printWriter does not do any sort of conversion and prints the data directly as a sequence of characters. We can specify the encoding scheme if needed though.  
Note:
1. [III] We get the object of printStream class from system class when we do “System.out” while println() is a method of print stream class. PrintStream has many other methods. 

|Compressed and Uncompressed File| [IIII]
DeflaterOutputStream and InflaterInputStream are used to compress and un-compress a file in the deflate compression format. Let’s see how we do it. 
•	DeflaterOutputStream – This class is used to compress a file into deflate compression format. Suppose, we have a simple file. We can use .java or .txt file to deflate and inflate. We first read the data from it (so have to create a fileinputstream). Then, we will create a write object (which means fileoutputstream object) which then be connected with the deflaterOutputStream Object. So, we will use deflateroutputstream the same way we use the buffer with the fileoutputStream. 
•	While deflate, we need file (.txt or .java) which need to be deflated. For this, create a file in the workspace location of the class. You know where it is saved.
•	InflaterInputstream – this is used to uncompress a compressed file. We also use this in the same way we use buffer with the fileinputstream. Firstly, read the content of the compressed file and create an object to write something into the new file. Then, create an inflaterInputStream object and connect it with the fileoutputstream object. Then, write the content of compressed file into uncompressed file using the object of inflaterInputStream. Also, then flush the inflater stream. 

|PipedInputStream and PipedOutputStream Class|
These streams are used to read and write the data simultaneously. This is done by connecting both the streams. Threads is used here. Firstly, create the object for both and connect them. Then, create thread t1 to write the data through the object of the pipedoutputstream. Then, create another thread and read the content through the object of pipedinputstream. Then, start both the thread. Check the example for better understanding. We have used anonymous classes for writing the threads. I have tried the example where we create the pipedinput and output streams and connected them. Then, we have created two threads and inserted the numbers through output thread and read the numbers from the input thread which are printed. Though, I was getting IOexception and some unknow special characters were shown. 













=====================================================================================
Java Networking
Concept of Networking
Networking is a concept of connecting multiple computing devices to share resources. In java, java socket programming is used to provide facility to share resources between computing devices. The typical advantage of networking is the ability to share resources and centralize software management (centralize as a hub controls all the nodes in a network. Also, can check more on this) Few important terminologies in networking are given below. 
2.	IP Address – It is a unique number to identify a computing device in a network. It is a logical address which may differ with the physical address. Logical address is the address which is generated by CPU where a physical address is the one that it actually available on the memory. 
3.	Protocol – It is a set of rules which are responsible for setting up the communication between computing devices.
4.	Port Number – This is used to identify the application in a computing device to which the message needs to be sent. 
5.	MAC Address – this is a unique identifier to NIC (Network Interface Controller). A computing device may have multiple NICs that connect it to multiple networks but each NIC have unique MAC Address. PS: It is media access control address. This is used in Ethernet type of networks. Ethernet are LAN type of network and comparatively very small than internet. 
6.	Connection oriented and connection less protocol – Connection oriented is where the notification is sent by the receiver and hence it is slow but reliable. On the other side, connection less is opposite to it. 
7.	Socket – It is the end point between the communicating computing devices.  
Note – Check what physical and virtual (logical) memories are. This is an operating system tutorial topic. 
Socket Programming
The basic idea of socket programming is to connect two computers in a network through java programming. Client creates a socket and tries to connect it with the server (it knows the host name and the port number of the server), in term to make server connection. On the server side, server listens to the socket for any request by the client for connection. Once the connection is made, server creates an object of socket and can share resources. This is the concept of socket programming. Java.net.socket is a class that is used to create socket and java.net.ServerSocket gives a mechanism to listen to client socket and establish a connection. Let’s look at the steps involved in the resource sharing. 
1.	The server instantiate the serverSocket class object, denoting which port number to which the communication occurs. 
2.	Server invokes the server accept() method of the server socket class. This method waits until the client socket is not connected. A server object is created by invoking the accept() method because it returns the object of server. 
3.	At the client side, client instantiate the socket class object specifying the server name and the port number at which the communication will occur. 
4.	The constructor of the socket class tries to connect the client with the server at the specified port number. Then, the client has a socket object that can communicate with the server. 
5.	At the server side, server sends a socket reference to the client (accept method of server actually). 
I have seen the example programs in the tutorial. The steps are same. Though I cannot practice it since port number and all is not known. However, few other things must to mention. First, we have read about many different types of IO streams but here we have used none of the types but a new one called “DataOutput/InputStream”. These streams have methods like writeUTF() and readUTF(). This is again for reading and writing but it supports the UTF-8 standard character encoding scheme. We should also use the flush() and close() methods wherever required. Also, if you want try this program later, open two cmd, one for server and other for client. For now, it is out of scope. 

Java URL
URL stands for Uniform Resource Locator. URL points to a certain location on World Wide Web.  
An URL contains much information such as 
1.	Protocol (generally “http//www.javapoint.com:80/javatutorial”). 
2.	IP address/server name/Host name (http//www.Javapoint.com:80/javatutorial).
3.	Port Number (http//www.javapoint.com:80/javatutorial). If no port number is shown in the example, then -1 is returned by default.
4.	File name or directory name (http//www.javapoint.com:80/javatutorial).
Java.net.URL class gives many methods. Check the example. In the example, we create the object of the URL class and pass an URL as the argument. Then, we have different methods like getHost(), getFile() etc to find certain details. The program was working fine. 

Java URL Connection 
Suppose the application you are creating require you to connect the application with a URL. There we use URLConnection class. From the specified URL, your application can read and write data. To make this actually happen, first create a URL object to specify the URL we want to deal with. Then, create an object of the URLConnection class but that is done using the openConnection() method of URL class (which is very important to understand). This needs to be done because openConnection() method is present only in URL class and it returns the object of the URLConnection class as a return type. Actually, a method URLConnection of URL class returns the object of the URLConnection class. So, its object is made using this method. Also, the URLConnection class does not have its constructor. Now, if we have to read something from URL referred, then create an input stream with the use of URLConnection class object and its method getInputStream(). Then, do usual coding for displaying the inputstream. The example, I have tried has given an error of “refused connection”. So, try and figure out the possible reasons for such error. By now, it is going out of scope. Try the example. 

Java HttpURLConnection Class
HttpURLConnection class is used to get the information like header information, status code, response code, etc. It is not about creating a connection but to get the information of an http URL. The HttpURLConnection class has many methods that give such information. Try an example. In the example, the object of HttpURLConnection class is created which needs to be carefully understood. Creation of object of HttpURLConnection class is interesting. The openConnection() method of the URL class return the object of the URLConnection class and HttpURLConnection class is a sub class of URLConnection class. So, typecasting can be done to convert the object of the URLConnection class as the URL class. 

Java InetAddress Class
This class is used to get the IP address for any host name such as www.google.com or any other host. Check the methods of this class. In the example, the object of the InetAddress class is created first and by using the getByName() method, we pass the host name. Then, we print the host name and host address. Check this class in detail later if needed. 
Doubt(s):
1.	 While trying this, I have tried creating a simple object using new keyword with no parameter. This has given as error as this type of the constructor is not present in the class. However, I also struck as then why not the default empty constructor is not used?  An answer to this could be that once you create any constructor of the class (default or parameterized), the default empty constructor by the compiler is not generated. Also, in this case, getByName() method is used which is purposely made to return the object of this class.
2.	How does it return the IP address of a website like I have got the IP address for www.Google.com and www.javaTpoint.com. This happens as the eclipse is connected with the internet and if internet connection is removed then it will not work. Though, this answer is not verified.   

Java DatagramSocket and DatagramPacket
DatagramSocket and DatagramPacket classes are used for connectionless socket programming. DatagramSocket class is used to create a connection less socket for sending and receiving the data. Datagram is some content and there is not guarantee of its arrival at the receiver. DatagramPacket class is used to create a packet (packet of message) that can be sent or received. If we send multiple packets then it can be received in any order. In the example, we have first created an object of the DatagramSocket class to create a connectionless socket. Then, we will create a message string. Then, we will get the IP address by name through InetAddress class. After this, we will create an object for DatagramPacket which needs information like byte version of the message string, length of the string, ip address and port number. Lastly, using send() method of DatagramSocket class, we can send a packet. At the receiver side, create a DatagramSocket object. Then, create a byte array. After this, create a DatagramPacket object and pass the byte array and the port number into it. Then, with the help of receive() method of the DatagramSocket, we can received the data. Lastly, we have to print the data. So, create a new string and pass the necessary parameters and print it. 



















=====================================================================================
Java AWT (Takenover by Tutorials point)
AWT Home
Java AWT (Abstract Window Toolkit) is an API to develop GUI (Graphical User Interface) or window based application in java. Here, GUI is the interface by which user actually interacts with the application and window based application are those that run by the OS but not run through the browser. In short, by java AWT you can develop GUIs. 

AWT Overview
GUI is Graphical User Interface which is nothing but a user interface through which a user can interact with the application. In my definition, I would like to call it a face of a website. A face has got eyes, ears, nose, mouth and other things. These are all its components. Similarly, GUI has also got its components as window, frame, panel, button, textfield and many more (Where Window, panel, frame, dialog, applet are container type components). GUI works in the form of events. For example, checking a checkbox, Clicking a button, opening a window or closing a window is form of events. Now, let’s understand the basic terminologies. 
1.	Component – a component is an object that has some graphical representation and can interact with user. Examples are button, checkbox, list etc. 
2.	Container – Container object contains multiple components of GUI and other components as well which are ordered according to the index decided at the time of adding to the container. If index is mentioned then the newest component will come at last. 
3.	Panel (kind of a container) – Panel provides a space in which application can attach any other component or any other panel. This is just for grouping up the component and does not stand alone. 
4.	Window (Kind of a container) – It is rectangular space which is displayed on the screen. In different window, we display different programs and display different data. Window provides us with multitasking environment. A window must have frame, dialog or other window as its owner when it is constructed. It will not be focused until its owner is showing on the screen. It can stand alone. 
5.	Frame (kind of a container) – it is a top level window with a title, a border and closing, minimizes and maximize buttons. It has resizable corners. 
6.	Dialog (kind of a container) – It a special type of window. This is mainly used as a pop up window for saving and selecting the file. 
7.	Applets (kind of a container) – It is a kind of panel. 
8.	Canvas – It is a blank rectangular area of the screen onto which an application can be drawn. 
Note: definitely do check the hierarchy of AWT components. 
Some example of GUI applications are ATM, Mobile application etc. But do check the non-GUI application examples. We have CUI also which is Command-line User interface or character user interface. It was the earliest technique of interacting with an application through commands. Though, its use has reduced because of the ease of use and familiarity of the GUI applications. Let’s look on the advantages of GUI over CUI. 
1.	Obviously, GUI provides graphical icon which are its components that makes the user interaction with the application far better. 
2.	It provides the facility of clicking and execution environment (IDE’s and all). 
3.	Using GUI is much easier and interesting at the same time than CUI. 
4.	CUI supports only one task at a time while GUI can support multiple. 
AWT Environment 
This section is all about installing java in the machine. 

AWT Controls
There are three main aspect of any user interface which are discussed below. 
1.	UI elements – UI elements are nothing but the components of the AWT. These may be Label, text field, text area, scroll bar etc. 
2.	Layouts – They define how the UI elements (AWT components) are designed on the screen and this defines the final look of the GUI. 
3.	Behavior – These are the event that occurs when the user interacts with the UI element. In other words, it will define the behavior of the element when user interacts with them.
AWT Component class – This is an abstract super class for GUI components (controls). Below are the most frequently used components. 
1.	Label – Label displays a single line of read only text. The text can be changed by the programmer but cannot be changed by the user in anyway. The label class extends the component class and implements accessible interface. The label class has a lot of methods and constructor. Study them later if required. It is opposite to Textfield and Textarea since it is read only.
2.	Button – this class crates a labeled buttons. Labeled here means that something is written over it. The looks of the buttons changes when cursor passes over it or when it clicked. It creates an event when the button is clicked or released. 
3.	Check box – A check box can be in ON or OFF state. 
4.	Check box group – This class is set for using a group of check boxes. 
5.	List – it presents a user a scrolling list of items. (may or may not have scroll)
6.	Text Field – A textfield object allows a text component that allows an editing of single line text. 
7.	Text Area – It allows the editing of multiple line of text. 
8.	Choice – A choice control is used to show pop up menu of choices. Selected choice is shown at the top of the menu. (This may also be called a drop down menu). 
9.	ScrollBar – These are for scrolling horizontally and vertically. 
10.	Canvas – this class represent user a rectangular area to draw something or receive user input. 
11.	Image – This class is superclass of all the classes representing the images.
12.	Dialog – it is a top level window with a title and border to take some kind of input from the user. It comes in the form of a pop up window.
13.	File dialog – it is for the purpose to let user select a file. Let’s say we have to attach a file and after clicking browse, we get a pop up window for selecting the file we want to attach. This window is the file dialog.
Note: 
1. Every control/component extends the component class and implements the accessible interface. 
2. Refer tutorialspoint for studying components of AWT.

Event handling
Firstly, we have to understand an event. Whenever any user interacts with the components then an event triggers specific to the kind of interaction. There could be foreground and Background events. Foregrounded events require direct interaction of the user like clicking a button while the background events require interaction of end users like operating system interrupts, hardware or software failure, time expires etc.
Event handling – It is a mechanism which decides what to do when a particular events gets triggered. Java uses delegation Event Model for event handling. It has two key parts. First is source which is an object on which the event occurred. It also informs the handler about the event triggered and provides information like what happened and to whom it happened. Second is listener which is known as the event handler. It is responsible for generating the response to an event on the basis of the information provided by the source. The benefit of this approach is that the user interface logic is completely separate from the logic that handles the event. That is why the listener must be registered with the source object so as to receive the notification of the event generated. 

Steps involved in event handling –
1.	The user interacts with the UI element and an event gets generated. 
2.	Then the object related to that event gets automatically created and information about the source and the event gets stored (populated) in the same event object. 
3.	Then, the event object is forwarded to the method of the registered listener class.

The listener class must implement some interfaces which have some forecast callback methods. These methods must be implemented by the listener class for the class to become listener class. These callback methods are nothing but the event methods and in response to the event these callback methods are fired. So, a listener must implement interfaces having callback methods and source class must register the listener to let listener to respond to the events. 
Note: I have checked the program and it seems like we need to do it a lot more depth because I am not able to understand that program. 
Note: The above information where it is told that event handling has two important things which are source and handler is incomplete and the explanation is also not so clear. Here is another attempt to explain the event handling. Actually, it involves three things which are user interacted with whom, how the user interacted and who should be the processing the response of the GUI. So, the component that user has interacted with is called as source. The way the user interacted is called as event like clicking a button. The response is process by something called as handler. So, an object of the component is created which is nothing but the source. An event is added to that source (component) and then listener is configured for that event (state). A small tip here is that try to think an event as a condition or state and you just need to clarify the UI action on every possible event. Now, since you understood the three key things of event handling then it’s the time to understand the sync between the three to handle the event. Firstly, when we create a component then the reference referencing to that component is nothing but the source. Then, we add events to that component by addActionCommand() method (its just an example for adding action type event but the method will change according to the type of event). We also pass the name of the event so that the different events can be identified among different events. Then, we add listener to that component by addActionListner() method (again I am taking an specific example of listener). In this method, we pass the object of the listener class that we created. Actually, we create the listener class but make use of listener interfaces. Then, in the listener classes that we created in the program we handle the different events. Try the example from tutorialspoint when get time for this.  

Event Class
(bahut der mai samagh aya tha bhai. Huuh!)
Event occurs when a user interacts with an UI element. Every event is referenced with an object which is called as source. The super class of all the event class is the EventObject class which is having two methods. First is the getSource() method which returns the object (i.e. the source and clarifies that which UI element interacted). Second, int getId() which returns an Integer value which identified which type of event occurred on the UI element. Now the event classes are sub classes for the EventObject class which are categorized in semantic and low level. The high level event classes example are ActionEvent (an action is performed either by clicking a button, checking a checkbox, etc), AdjustmentEvent (when the scroll is adjusted) and other. However, low level classes are those which are generated for a high level event. Example of low level events are focusEvent (when the mouse is placed on any check then it glows. Therefore when a high level event occurred like Actionevent of checking a checkbox then along with it a low level event like focusEvent also occurred when the cursor is taken over checkbox), WindowEvent and other. One more thing is important, when comes to event classes then they are not about a particular event on which UI element but it is an event which may be applicable for many UI element. For example, the actionEvent can be done over many UI elements. Also, check other event classes. 

AWT Listener 
AWT event listener represents the interfaces responsible to handle events. Java has many event listener classes. Every method of the java listener classes has one argument which is the object of the sub-class of the EventObject class. For example, mouse event listener will accept the instance from the mouse event class which is derived from the eventObject class. 
EventListener Interface – It is a marker interface which is implemented by all the classes in the java.util.package. We have some other listener interfaces which are shown below.
1.	ActionListener – this interface is implemented by the classes which receives the action event. 
2.	ComponentListener – This is used to receive the component listener.
Check the rest of the listener interfaces.
Note: Generally, we have listener interfaces for corresponding event classes. 

AWT Adapters
Adapters are the abstract classes which are used to receive the events. Adapters make the event handling easier. In listener, implementing class must override all the methods but adapters can override only those methods of which they need to receive the events. So, the advantage is simple and clear. Check the AWT adapter classes.
AWT Layouts 
Layout means the arrangement of the UI element within a container. The way they are designed gives the final look of the GUI. We also have a layout manager which can do it for us. Let’s see what layout manager it?
Layout Manager – layout manager simply arranges the UI element for us and makes our life easier. Though, it can be handled manually but layout manager is preferred because of two key reasons. First, it is very tedious to arrange UI element in large quantity. Second, the size information of the UI element is not shown while arranging them manually. We have different kind of layout manager and the arrangement changes according to the size of the applet viewer and window size. 
Check the layout managers and layout manager classes.

AWT Container
Containers are also AWT component but have the ability to add other components and containers in it. The sub class of a container is components like frame, panel, window etc. Each container has a default layout which can be overridden using the setLayout method. The examples of the some containers are frame, window, panel etc. 

AWT Menu Classes
Almost every high level window has a Menu bar. These menu bars have options available to the end user (those who will actually use the application). These menu bars are also has some options which are in the form of the drop down menu. We have MenuControl class which is the super class for all the Menu and Menu items. Check the hierarchy and the menu classes.

AWT Graphics
Graphic controls allow the application to draw onto the component or image. Check the graphical control classes.



























=====================================================================================
Java Swing
Basics of Swing
Java Foundation classes are a set of GUI components which simplify the development of desktop application. Java swing is a part of the JFC which is used to create window based application. AWT is machine dependent and so uses the machine code also. However, swing is purely java written code for the development of WBA. Swing uses AWT though limited. It uses majorly that part of AWT which is in Java, not it machine language. 
History - It was originally named Java foundation classes which later named as Swing (from wiki). Until java1.2, swing was distributed as separate downloadable file.  
Difference between Swing and AWT
1.	AWT is platform dependent unlike Swing. 
2.	AWT component are heavyweight as compared to Swing component. 
3.	AWT window application will look according to the OS but swing gives an option to either look likFe native OS or to have “Java look and feel”. This also means that the java look and feel gives an option of same look on different OS.
4.	Swing has more components.
5.	AWT does not support MVC unlike swing. MVC is model view control is the architectural pattern for implementing the user interface. Check more on MVC. 
Check the java swing class hierarchy. It is same as AWT’s hierarchy.
We already know about what component is. We have a component class which is super class for all the components available and we will look at the most common method of the component class of java swing. These are given below. 
1.	Public void add(Component obj) – to add the component to another component. 
2.	Public void setSize(int width, int height) – set size of the component.
3.	Public void setLayout(LayoutManager obj) – set the layout manager for the component. 
4.	Public void setVisible(boalean obj) – set the visibility of the component. It is by default false. 
Now, we will see the way to create a frame and add a component to it. Frame can be made by two ways which are by creating its object and by extending the frame class. I have made the first swing program creating a frame and then adding the button to the frame. It’s all about creating object and then using the methods. 
Note: local value may not have been initialized error (Compilation error) comes when the local variable is not initialized. However, by rule it must be initialized before it is accessed. 

JButton Class
The JButton class is used to create the buttons which are platform independent (better not to mention, because I know I am studying swing). Well, the use is same which means we can create its object and then use the functionality of the methods. We have to check with the type of constructors and the methods. Also, we have to check with the types of buttons or most commonly used buttons. The button classes are sub classes of the abstractButton Class and uses its methods. Also, for using these methods, we do not need to extend it explicitly. I have understood the example. Check the way of inserting the image. Also, my image was not visible. Check it what’s wrong later when you get time.



JRadioButton Class
JRadioButton class is used to create the Radio Button. These are used to select one option out of multiple choices. It should be added in the groupButton class to make sure only one option is selected out of many. The, group button should be added to frame. I have checked the example and it’s very easy. Also, check how a constructor is called in the main method in its own class. 

Executable Jar file
JAR stands for Java Archive Resource. It is a package file format which is used to aggregate many java class file and associated metadata and resources like images, text etc. The purpose of putting it together is to distribute an application on a platform. They are archive files and has .jar format. They can be executed by just a double click. We can show our application on other’s computer without even jdk but JRE is needed. They can be extracted using JAR command that comes with JDK or by zip tool. We get a JAR utility in JDK.
Now, we can make the jar file executable and that is called as executable jar file. We can do this by a Jar tool (jar.exe) provided by jdk to create the executable jar file. This tells the runnable about the main method. To do that, we need to create a manifest file (.mf) file. There is a particular syntax for creating manifest files which is “Main-Class: first” where first is the class name. Also, in mf file, new line is just after the class name. Now, java tool has got something called as Switches. For example,“-c” is for creating new jar file. Check the other switches available. Syntax for creating the jar file with the manifest file is “jar –cvmf myfile.mf myfile.jar first.class”. This way an executable jar file will be created and is runnable after the double click. Check how does an executable java file look like? I am not able to find out as why the manifest file is necessary for creating executable Jar file. 
Check this link for wonderful explanation on this topic - http://www.dreamincode.net/forums/topic/243325-how-to-create-a-java-executable-jar-file/


JTextArea Class
JtextArea class is used to create a text area that can contain multiline plain text only. Though we will try to create a simple text area but still check the important constructors and the methods of this class for adding more features. One thing to note here is that setVisibility and setLayout is used for frame but not for lower level components. Check if the same setsize, setvisibility, setlatout are to be necessarily written at the end. Nothing is mandatory. But you can set these properties along with setting the background and foreground color.

JComboBox Class 
This class is used to create a ComboBox i.e. the drop down list from which only one option can be selected. Check the example and try more methods for the more features. We have to create an array of string that we need in the drop down box and pass that string as the parameter to the constructor of the JComboBox class.

JTable Class
This class is used to create a table which can display the data two dimensionally. I have tried an example. Firstly, I have created an object of the frame. Then, create two arrays of string (I am not talking about string here, but array of string) i.e. one for columns and another for data. Then, create the object of table and pass the data and column as arguments. Then, create a JScrollPane object. It is not mandatory to create the scrollPane. Lastly, I have passed the table as argument in the JScrollPane and add it in the frame. 
Note: Just understand Pane as a lower level container which can fit inside the higher level container like frame. These are really helpful when the GUI is really complicated. 

JColorChooser
This class is used to create or show the color chooser dialog box through which a user can select a color. Here, i have tried the example. Container is used. Container in swing is a space where a component can be placed and container can add any component into it. We have created a container object and used getcontentpane() method and setLayout() for setting the flowout as layout. I have to understand the purpose for having container and using these methods. Now, in the previous examples, we were having buttons but not adding any event to them. Now, we want to add event to the button so use the “addActionListener()” method. We have to pass “this” keyword as the argument of the addActionListener method. ”this” keyword is used to refer to itself only. Then, we have to create a ActionPerfomred() method passing “Action e” as argument. Check the code of this class later since unable to understand except one thing that “jColorChosse.showDialog()” is used to show the color dialog box. Check the code of the last line in the main method.

JProgressBar
This is used to indicate the progress of the task. I have tried the example. In this, we create JProgressBar object and then used setBound(), SetValue() and SetStringPaint(). JProgressBar object was made by the constructor with arguments as minimum and maximum value. Then, since we have extended the JFrame class so we simply used the add() and setSize() methods for adding the Progress bar and setting the size of the frame without making its object. Then, we created iterated method where we are actually creating task of printing value from 0 to 2000 with adding 20 everytime with a thread.Sleep(150). Now, we have connected a JProgressBar and a task. Now, with the help of setValue() method we can connect the loop with the progressBar. In the main class, you have to create an object of the class and call the iterate method.

JSlider Class
This class is used to create Slider. Using this class, user can select a value from a range of values. I have tried an example. I have created a class extending the Jframe. Then created a constructor and created a JSlider object and specified the orientation, min, max and initial value. Then, using the setMinor/MajorTickSpacing(2/10) placed the major and minor ticks. This does not complete here but we have to setPainttick/label() as true. Then, I have created a panel and added the slider to it (though, even without using panel and simply, directly adding the component to the frame also works the same way). Later this, I have added the panel to frame. Then made the main method and made the constructor visible and used pack() method which ensures that the size of frame is bigger than its component. In the example, pack method was used but I have made it without pack method and it is called by the constructor. 

Digital Watch
In this section, we will learn how to create a digital watch. I have tried the example. It is simple. I have created the class method and created an object of frame and a button (don’t know why botton) which I have to that frame. Also, created a thread and called the start() method. Then, created the run() and done the coding for making the data string. I have understood much of this except the part where we have created the time string and used classes and methods related to date and calendar. Once we will be done with date, then we will do it.

Graphics in Swing
Java.awt.Graphics class provided a lot of methods for graphics programming. In the example, a method was made using the pre defined methods of the graphics class. Also, the canvas class was extended. Check why canvas class was extended. Lastly, the frame created and the class object was added in the frame. Check why the program is not running despite the fact that I have made it correct.
Note: we can only extend one class at a time but we can implement multiple interfaces. 

Displaying Image 
For displaying an image in swing, the drawImage() method  of graphic class is used. In the example, the canvas class is extended.Then, what is this toolkit and getdefaulttoolkit() metod is? Check the entire program again.

Edit Menu of Notepad
Do it later if you have time. 

Open Dialog Box
Do it later if you have time. 

Note: These topics are not studied in detail. We have just studied them to have a brief idea about all and build concept. 

Java Swing App
This is definitely out of the scope at the time I am writing this. Though, if needed later I can revise the basics and try to understand this section too. 























Layout Manager 
Layout is the design in which the components are arranged in Swing. In this section, we will look at the different types of layout managers available where the layout managers are the interfaces which are implemented by the classes to get the layout. There are many types of layout managers though we will study few. 
Border Layout
It is used to arrange the components into five regions which are north, east, west, south and center. The border manager provide five constant i.e. one for each region. Check the constants and constructors. I have tried an example. Only different we have here is to define the region of the button while creating it. Secondly, while adding also we have to mention the region as well. 

Grid Layout
It arranges the component in the form of rectangular grid. One component is displayed in one grid rectangle. I have tried the example. In this, you just need to mention the number of the rectangle block of the grid the component belongs to at the time of creating the component but not at the time of adding it in the frame. Also, we have to set the layout here as gridlayout (check the way of adding the layout) which is not required in the border layout. 

Flow Layout
This layout arranges the component in a series which are numbered. It is same as grid layout while writing it. We just need to setlayout as flow layout except that everything else is same. Also, we have to initiate the series from left or from right. By default it will be in the center.

Box Layout
This layout arranges the component into boxes in horizontal, vertical or other orientations. I have tried an example and found that this layout does only have a constructor which has parameters container and int axis. Check the example in the tutorials once again because that I have written was giving error.  

Card Layout 
This layout shows only one component at a time. It treats each component as a card. Check its example later when you have time. Currently it is getting out of scope. 






=====================================================================================
Java Applet

Must Read – understanding of graphics in computer 
Anything that you see on your computer screen is graphics. There are a lot of APIs in java which are dedicated to graphics. The top level class, just after object class, we have Component class which is super class for all the GUI component classes. After Component Classes we have classes of the component class like button, Label, checkBox, canvas, choices etc and container class. Container class is also a sub class of the Component class (a special one) along with the classes of component. Container is a kind of component which can container other components or other containers.



Now, the container class has two sub classes which are window and panel. Panel is used only for grouping of components which does not exist alone (when I talk about component then include container as well because it is also a kind of component). Window is for creating a group of component and handling them as well. One example of panel is Applet which does not exist independently, but a web browser or applet viewer is needed to view them. It does not stand on its own. However, a window is represented as independent and is not inside any other component. We have two kinds of windows which are dialog windows and Ordinary windows. Dialog windows are for opening and saving the files which are implemented using dialog class. Other category is the ordinary window which is implemented using the frame class. 
Useful link for: https://staff.fnwi.uva.nl/a.j.p.heck/Courses/JAVAcourse/ch5/s1.html
Concept of Graphic class
The above writing covers the components that we have for producing the graphics. Now, we must understand that for any drawing you want to do, you require a “graphic context”. This graphic context is an object belonging to a class Graphics. Now, the need of the Graphic class object is because it has the methods for drawing shape, text, images etc. With one graphics object, you can draw only at one location i.e. any one of the GUI components. Also, the Graphics class is an abstract class so it is impossible to create an object directly. That is why, you have two indirect ways to use Graphics class object. First, You can use the object of the Graphics class as the parameter to the paint() methods. (PS: We will study paint() later in detail). Second, with the help getGraphics() method. This getGraphics() method is  present in every component class. First, create the object of any component like button, canvas, applet etc and then creating the object of the graphics class with the object created of the component like this. 
Example: line1 – Button b = new Button();
	   line2 – Graphics g = b.getGraphics();
Also, we should dispose the object of the graphic class if we have created the object using the getGraphics() method. 


AWT SWING AND APPLET connection
So far what I have figured out is that AWT was made for GUI application (does not specified for which type of application i.e. for window based application or web based application, so I consider it for both). Now, the difference between AWT and swing I know very well. Just to tell you in short, Swing was for same purpose as AWT but with few improvements which you can check in differences. Swing and AWT is used for designing the GUI of window application while Applet is used for web based application. Explore this more later when you get time. Also, GUI development does not only mean to display things but to make them functional together properly. 

Where to use Applets
1.	Applet code written in java can be added in an HTML file. When we use a browser to view the page then the applet code get transferred to the system and executed by the browsers JVM. 
2.	I also want to add about the use of Applet. One of its main use is client side validations. It can make the web pages more users interactive. Think of a situation where you are filling a form and the moment you filed a field incorrect, it becomes red. Other situation could be that you filed all the fields and pressed enter. The page reloaded and the same form loads with a message for the correction needed in some fields. So, in the first situation the page become more interactive and that is only because of client side validations done through applet. However, these days, applets are rarely seen as they are replaced by other better options, mainly javascript for validations. If you only want to use java for validation, then applet becomes the option. Also, if you are thinking that how validation becomes a part of applet that you studied then think this way. The applets can create text field and other things. To restrict user to fill them in appropriately we have validations. 
3.	Another internal use of applet is to get the data of the users’ machine which could typically be done once the user signs the signer’s certificate which is seen very rare to be done by the users. 
Note: What applet can do and cannot do: https://docs.oracle.com/javase/tutorial/deployment/applet/security.html

1.	Paint repaint and update

Applet Basics
A Java Applet is a java program that runs in a web browser. It can use all the Java APIs and resulting it as a complete java application in itself. Let’s check out the difference between java applet and java application.
1.	A java applet class will extends java.applet.Applet class. 
2.	Unlike traditional java application, java applet does not invoke the main() method. 
3.	Applets are designed to be embedded inside an HTML webpage. 
4.	Applet gets automatically downloaded to the user’s machine once the user view the HTML web page. 
5.	The JVM is required to view the web page. In some cases, the JVM is a browser plugin or can be the JVM of the machine. 
6.	Then, the JVM instantiate the applet class and invokes the methods defined within the applet class. 
Some advantages of Applets
1.	It runs on the client side and thus takes less time. 
2.	Secured. Though we have read a little about the Jwrapper which have a significant advantge over Applets due to security reasons. 
3.	It can be executed by a browser running under many popular OS like windows, linux, Mac OS etc.
It also have disadvantage as the plugins are required at the client side. Check the applet hierarchy. 
Lifecycle of Applets
1.	Applet is initialized – This is done through “init()” method which is needed for the initialization of the applets. It is called after the param tags, inside the applet tags, is processed.
2.	Applet is started – This method is automatically called when the init method is called. This method also called when the user returns to that page after visiting some other page. Initialization occurs only once. 
3.	Applet is painted – This method invokes immediately after the start() method. This method will also be called whenever an applet needs to be painted. Here, painted means to use the methods of the Graphics class to be used for drawing oval, rectangle, arc etc.
4.	Applet is stopped – This method is called whenever the user moves off the page applet embedded to. Also, in the case when the browser is minimized. 
5.	Applet is destroyed – This method is only called when the browser is closed. This is for the basic reason as the applets lives in the HTML page. So, when the browser is shut down then the applets are also destroyed. 
Note: 
1.	The java,applet.Applet class gives init(), start(), stop() and destroy() methods while java.awt.paint is gives paint() method. 
2.	Java plug-in software is responsible for the management of its life cycle. 
Now, let’s look at the way to run an Applet. 
There are two ways. First, by HTML file i.e. java enable browser and second, by appletViewer tool. I have made an applet example. In this, first I need to create a .java file which uses java.applet.Applet and java.awt.Graphics. Using Graphics class methods, we can create a .java file. Then, under the applet tag we can attach the .java file and run it on browser. Google chrome and opera does not support the applets while internet explorer, Mozilla, safari do. 

Displaying Graphics in Applets
We have seen Graphics class in AWT as well but unable to understand much about it. Let’s us understand this now. Graphics class let the developers to draw geometric shapes, print text and position images within the borders of a component. In short, all the graphical operations within AWT are performed Graphics class. Please check the common methods of the Graphics class. I understood the example. The graphics that we need to create are written in the Paint(Graphics g) method having argument as the instance of the Graphics class. Then, you can use the methods of the graphics class. We need the graphics context for doing any type of painting. So, just understand the methods of this class well. 

Displaying Images in Applet
Applets are mostly used in games and animation. Therefore, displaying image is very common use. This can be done by java.awt.Graphics class drawImage() method. Other methods used are getImage(), getDocumentBase() and getCodeBase(). I have checked the example. We first have to create a class variable of Image datatype. Then, create an init() method and use getImage() method which has getDocumentBase() and image name as parameter. getDocumentBase() gives the URL of the document that has the image. Then, create the paint() method and use the drawImage() method which has Image type variable, int x, int y and ImageObserver as the parameter where the ImageObserver is an object. Component class implements ImageObserver interface and but applet class extends the component class so current class can also be treated as ImageObserver. Therefore, use keyword ”this” as the 4th argument.  

Animation is Applet
This is a very vast topic though a simple example given to make us understand a bit of it. In the example, an image is displayed 500 times with a sleep of 100 milliseconds. 

Event Handling in Applet
The way we have done the event handling in AWT and swing, the same we can do in applet as well. In this, We have to implement the interface ActionListener and use the method ActionPerformed(ActionEvent e). 

Japplet Class in Applet
We prefer Swing over AWT. We can also use Japplet class that extends the Applet class. In Japplet we use Jbutton instead of button else the program is same as when we extend the Applet class. 

Painting in Applet 
We can perform painting operation in Applet by the mouseDragged() method of MouseMotionListener.
Check the example later if get time. 

Digital Clock in Applet
Check it later when you have time. 

Analog Clock in Applet
Check it later when you have time.

Parameter in Applet
We can get any information from the HTML file as a parameter. For this, we have getParameter() method in Applet. Check the example later when you have time. 

Applet Communication
Java.applet.AppletContext class provides the facility of communication between two Applets. Check more on this when you have time.  








=====================================================================================
Java Reflection
Reflection API
Java Reflection API is the process of examining or modifying the runtime behavior of a class at run time. This topic is comparatively an advanced topic. 
Java.lang.Class class – this class is used to provide two main tasks. First, provide to get the metadata of the class at the run time. Second, provides the methods to examine and change the run time behavior of the class.
 We can create an instance of a Class class in three ways which are below.
1.	forName() method of the Class class – this method should be used to dynamically load the class and when full name of the class to be loaded is known. Also, this cannot be used for primitive data type. 
2.	getClass() method of the Object class – This returns an instance of Class class. It should be used when you know the type. It can be used with primitives. Check the example.
3.	The .class syntax – do it later. Check the example. 

Determining the class object - It means to check that the object of the class hold a class, an interface or an array. This can be checked by the help of three methods which are public boolean isInterface(), public boolean isArray(), public boolean isPrimitive(). It will return either true or false. Check the example.
Note: 
Java Reflection:
Reflection is an API of java which is used to inspect and modify the methods, classes and interfaces at runtime. Java.lang and Java.lang.reflect are the packages that provide the important classes for implementing reflection property in java. Java.lang.Class class is one of the most important classes which has the methods used to implement Reflection. Some of the methods of Class class are forName(), getClass(), which returns the instance of the class Class.
Reflection can be used to get the information about class, constructors or methods. The methods such as getClass(), getConstructors() and getMethods() gets the class, constructor or method to which a particular object belongs.
We can typically use reflection in inspecting the elements of a class like name of class, constructors and method. We can invoke constructors and methods. Infect, we can invoke the private members of a class as well which can only be done through reflection. We do setAccessible(true) for accessing private variables of a method.

newInstance() Method
The newInstance() method of the Class class and Constructor class is used to create a new instance of the class. The newInstance() method of class Class can invoke method with zero argument while the newInstance() method of the Constructor class can invoke method with multiple arguments. So, constructor class is preferred. This is used to create an instance of the class then what is so special of it than the usual method?

Understanding Javap Tool
The Javap command is used to disassemble a class file. The javap command used to display the information about the fields, constructor and methods present in the file.
Try an example and understand more of it later as it is out of scope as of now.

Creating Javap Tool
This is out of scope as of now. So, understand it later when done with the fundamentals. 
Creating your own Appletviewer
Appletviewer creates a frame and displays its result in the frame. We can also create our own frame and display the result in it. Check more this later as it is out of scope for now.

Call Private Method
We will look at the way of calling a private method from another class by changing the runtime behavior.  Check this later when you have time.

=====================================================================================
Java Date 
Java Date API
The java.util, java.sql and java.text package contain classes for representing data and time. There are four days of printing the current date in java. 
1.	Creating object date of the of the class Date of the util package. In the example, first create the object of the date class and then simple print it. 
2.	We can pass the long type object while creating the date object. We have to use the currentTimeMillis() method for creating the object. “long millis = system.currentTimeMillis”. Else the method is same. The result is same as above way.
3.	Same way we can create using the Date() method of the java.sql sql package. Here, the date method will need an argument (madetory). This is because it do not have a constructor without any argument. So, create a long type variable and then pass it as argument. It prints only date.
4.	This time we will use the java.util.Calendar package and methods getInstance() and getTime(). 

Java.util.Date class
This class represents the date and time in java. It provides constructors and methods that deals with date and time. It implements serializable,  cloneable and Comparable<Date> interface. It is also inherited by some classes. However, after the calendar class was made then many of Date class methods were deprecated. Check its methods. I have tired the example. We have simply create an object and print that object. We can pass argument through that object as well. 

Java.util.SQL class 
This class represents only dates in java. It inherits the java.util.Date class. It is higly used in the JDBC because it can be used to store the date in the database. Some of its methods were later deprecated.  I have tried an example and we can also pass a string containing date with the help of valueOf() method of the data. Check the example. 
Doubt: when I tried to import java.util.Date and java.sql.Date in the same class, I received an error that “java.sql.Date collide with other import statement”.

Java Date format
In java, date formatting can be done by java.text.DateFormat class and simpleDateFormat class. The java.text.Dateformat class is an abstract class which extends java.text.Format class and extended by java.text.simpleDateFormat class. Also, converting date into string is called as the Formatting andvice versa is called as Parsing. Check the methods of the DateFormat class. 
I have checked an example. First we have to create an object of current date through Date class. Then, we have to create a string and use the format() method of the class DateFormat to format the class. Try second example later if get time. Also, to convert the string date into date, the entire program is same except we use parse() method instead of format() method. 

SimpleDateFormat class
This class is used to format and parse the date and time in java. It is a concrete class and extends the DateFormat class. Though this method we can present the date and time in which ever format that we write while create the instance. I have checked the example to format date to string. We have to create a current date object. Then, we have to create an instance of SimpleDateFormat class and pass the format we want to print the date in. Also, dd/MM/YYYY shows the format where “d” should be small, “M” should be capital and “y” could be capital or small. Try other methods of this class. Also, I have checked parsing as well. 

Get Current Date 
We have three ways for getting the current date. We can get it by java.util.Date class, java.sql.Date class or java.util.Calender class. Though, java.util.Calender class is not recommended. Check the example. 

Java Conversions 
Java String to int
We can convert an String to int in java using parseInt() method of integer class. Whenever we get data from the text field or text area, entered data is received as String. If entered data is String then we have to convert the String to int. This method returns int and accept String as argument. I have tried the example and it is very easy. 

Java int to String
This we can do by the help of valueOf method of String class and toString() method of Integer class. It is used when we have to show the number as a string because everything in a form shown in String. I have tried the example and they are very easy. Just keep in mind that valueOf() method is of String class and toString() is of Integer class. 

Java String to long
Long is nothing but the int with more range. So the requirement of conversion between String and long is for the same purpose as the conversion of String and int. we use parseLong() method of the class Long. 

Java Long to String
This we can do by valueOf() method of String and toString() method of Long class. The purpose is same as we have to show the long values as String. The example is simple. 

String to Float
To convert the String to float, we have parseFloat() method of the Float class. It is because of the same requirement of extracting the float data received in the string. 

String to Double
It is same as above.

String to Date
This we can do by parse method of the DateFormat class. Check the example. It is easy. 


Extra
Important concepts 
1.	Difference in object and instance –A class contains the behavior and property of a group of object. A class contains lots of object. While if we instantiate a class i.e. try to talk about of a particular object which is an instance.  For example, we have a Student class which is nothing but made of lots of students and contains properties and behaviors of the students. But when we instantiate the student class and create a instance. Like Student rishav = new student(). Here rishav is instance as we are talking about a spcific student of a class. Now, some people say that object and instance are same. I would say they are correct in a way but not completely. In the example, I said “rishav” is an instance but it is an object as well as it is a student at the same time. In the nutshell, an object is any element of a group of elements of which your class is made and instance is a specific element we are talking about.  
2.	Difference in argument and parameter– This is interesting. Parameters are also called as formal parameters. These are the variable which is passed into the caller method that represents the actual parameter while the argument is called as the actual parameter which is actually passed into the caller method. Example, I = 8; If a method calls I. Then, we can variable I or value 8. Here, I is the parameter (formal parameter) while numeric value 8 is called as the argument (actual parameter).
3.	What exactly static and public keyword mean – If something (variable, block, method or nested class) is made static gives a general idea that it is related to the class, not to any references. Check static section.Anything declared public means can be used by anyone without any restriction. 
Important terminologies
For understanding the difference between package and library, try to understand the intentions creating these concepts. 
Package – it is a namespace which is made mainly on two ideas. To identify the class location like java.packageName.className. We can trace the location of a file with its package name and class name. Also, it is used for scoping purpose. The classes in the same package have different ability to share its resources. 
Library – it is also an organizational concept. The intention behind creating libraries is to group some similar classes which can be called to give some feature or functionality. It is like you have thousands of program that can be used to give a specific functionality, whenever needed, are placed in library. It is not of a particular project or application but these are general and can be used in any project if needed the functionality it serves.
API – It is a part of a Library. There are different opinions that people have about API. Some says, API is a part of the library containing those methods which a program can access while libraries have some private member that cannot be accessed. Other says, as a communication needs an interface like for user and application communication we need graphical user interface, we need Abstract Programming Interface (API) for the communication between two codes (ex. Communication between libraries and framework). These two point of view looks reasonable. Also, APIs were originally the part of libraries but then it became the part of other things as well like framework and other. This means you can encounter API as something else as well but the definition above also holds true.   
Framework – Your application uses the libraries for some functions already implemented in it for code reusability. A framework runs your code or application and decides what order things must happen or execute. The main difference between library and framework is of Inversion of control which means the control is at the code while using the libraries while control is at framework when it calls the application. Framework provides a skeleton for the application into which the application code is inserted to give it a structure.   














=====================================================================================
Java Collections
||Collection Basics||
Collections in java Wiki – “The Java Collection Framework is a set of classes and interfaces that implement commonly reusable collection data structure. Although it is referred as framework but it works in a manner of a library. The JFC provides both the interface which define the collection and classes that implement the methods of the collection.”
Collection is simply an object that groups multiple elements in a group. A collection framework is a unified architecture for representing and manipulating the collections. Each collection framework has the following. 
1.	Interfaces –The collection interface is the foundation on which the collection framework is built. The collection interface declares all the methods that a collection will have. 
2.	Implementation (classes) – It is the implementation of the methods in the interfaces i.e. the implementation of the method that a collection interfaces have. In essence, they are reusable data structures (quoted in oracle docs).This means that these classes will have the methods which will in accordance with the data structure of collection.
3.	Algorithms – These are the static methods that perform useful implementations such as searching and sorting on the objects implementing the collection interfaces. Algorithms are known to be polymorphic as the same method can be used on many different implementations of the appropriate collection interfaces. In essence, algorithms are reusable functionality. This means that these functions are simple called from the collection classes whenever required instead of reinventing the wheel again. 
Check the hierarchy of the Collection Framework
 Note: the above shown hierarchy missed the iterator interface which is extended by Collection interface. 

||Iterator Interface||
This interface provide the facility to iterate the elements of a collection. It can iterate only in one direction and once the iteration is complete in one direction then new iterator needs to be created for further iteration. It has three methods which are Public boolean hasnext(), public object next() and public void remove(). Once the iterator method starts iterating a collection, an exception is thrown if the collection is modified. Iterator object is not created by “new” keyword. It is created specific to each collection.
Note: [III]
1. Iterator interface is the only iterator that can iterate all the collections. Not sure if Spliterator does the same or not?
2. Common exception iterator thorws! Iterator can throw a couple of exception which are UnsupportedOperationException and IllegalStateException. If remove operartion is not supported by the collection under iteration then UnsupportedOperationException will be thrown and IllegalStateException if the remove method is called before the call to the next method. Also, concurrentModificationException can also be thrown if concurrent modification is done on the collection. 

||Collection interface||
This interface extends the iterator interface and extended and implemented by the all other classes and interfaces in the collection framework hierarchy. Check its methods later, if get time. 
Begginners Book link to collection tutorials: http://beginnersbook.com/java-collections-tutorials/
Note: Collection allows only object to store (String, Wrapper classes and user defined objects). Wrapper classes are actually the replacement for every primitive type data. For example, int can be stored through the wrapper class Integer. Boxing is done to convert the primitive to wrapper class type and vice versa. Some think that it is design fault in java as allowing the primitive data type indirectly through wrapper classes puts an unnecessary load for boxing. But this is how java is designed.


||List Interface||
List Interface- List interface is an ordered collection (sometimes called as sequence). Lists may contain duplicate elements. Since, it is ordered collection then the position of elements matters. Its elements can be inserted or accessed by their position in the list i.e. index. Index starts from zero. 
|ArrayList|
ArrayList class implements the List interface, so it must be ordered collection and can contain duplicate values. It can contain null elements as well. It is non-synchronous. Here, manipulation is slow as any element is removed then lot of shifting needs to be done. Mostly, arrayList is used in place of array mainly because array is fixed size and arraylist is resizable. Also, if any element is removed from array then memory consumption would be the same as it does not shrinks. Moreover, we can use predefined methods in arraylist that make our task easy. 
I have practiced the example. We need to create an object of arraylist first and then we can use the methods of class arraylist to add, add to a specific index position, remove, removing element from specified index position. When we add element at any index where other element is already present then the arraylist expands and shrinks if an element is removed. So far we have just checked the way to create, add and remove element from an arraylist. However, check all the tabs to of the below mentioned links and practice them. 
Internal Working:
How arraylist works internally? How add() method works internally?
The basic data structure used by arraylist is nothing but array. Now, array list has given three constructors. First, we can create an arraylist like this “List<String> l = new ArrayList<String>”. This uses the default constructor of array list and results in the creation of an arraylist with default size of 10. Second, we can also create an arraylist like this “List<String> l = new arrayList<String>(5)”. This uses the parameterized constructor of arraylist class which results in creation of arraylist with a sixe of 5. Third constructor is little strange so lets leave it now which actually is used to create an array from some other collection.
Now, when an element is needs to be added in an arraylist then we make use of arraylist add() method. Add method first check the capacity of the arraylist and how much an array currently occupied. If arraylist has the scope to add an element then it simply adds but if the array is already full then it will increase the capacity by 50%. For a current capacity of 10, new capacity will be of 15. But how the size of arraylist increases dynamically? It actually creates a whole new arraylist with the new capacity and transfers all the data from old arraylist to new arraylist. 
Where to use – It should be used where the elements are more searched then inserted or deleted. 
How to implement a list? http://www.java2novice.com/java-interview-programs/arraylist-implementation/
Note(s):
1.	Simply printing the object of collection shows all the elements of the collection while the Iteration is printing all the elements one by one. We can do the iteration by Iterator() and by for loop.
2.	You can use user defined class objects to store in an arraylist. Suppose you have made a class where you have passed the values in the constructor by creating objects in the some other class. Then, we can use those objects as the element of arraylist.
3.	We can add element of one array into other in single shot by using addAll() method. Try this. 
4.	We can also remove the elements of one array which are common to another array in single shot by removeAll(). Try this. 
5.	Java Collection Framework was non-generic before java1.5. From java1.5 java collection framework became generic which means we can have only one type of element. Here, types mean data type and that we have to mention while creating an object. We mention the type in the angular braces “<String>”. We will get compile time error if we try to insert other type of element.  
6. [III] The default size of arrayList is 10. Load factor is 1. This means by size become twice after (10*1) 10 elements are filled in array. 
7. If we try to modiy the arraylist while iterating through iterator or for each (no matter how), then we will receive ConcurrentModificationException(). We can use CopyOnWriteArrayList(). The below example will let you modify arraylist while iteration:
public class Class1{
	public static void main(String args []){
		Class1 c = new Class1();
		List<Integer> list = new CopyOnWriteArrayList<Integer>();
		list.add(10);
		list.add(9);
		Iterator<Integer> i = list.iterator();
		for(int element: list){
			if(element==10){
				list.add(11);
			}
			System.out.println(element);
		}
		System.out.println(list);
	}
}
If we would have used normal ArrayList then we would have received concurrentModificationException.  
8. If we want ArrayList in threadSafe enviroment then we can use Collections.synchronyzedArrayList(originalList). 
9. We have Employee e1 = new Employee(1, "Rishav") and Employee e2 = Employee(1, "Rishav"). If we compare e1 and e2 then they will not be the same. This can checked using hashset. 
10. CopyOnWriteArrayList is not a part of collection class while it is a part of concurrent package of java. 	
11. [III] Modification comparison between arraylist and linkedlist! As we know that arraylist performs poorer in modificaton compared to linkedList. However, if we are sure that the insertion is happening at the last then arraylist is a winner. Also, LinkedList has more overhead of memory too. 
12. [III] Remove method argument of different collections! Remove method of List implementions takes the argument as index or object, Set implemention takes object and Map implementations takes argument as key alone or key and object pair. 
13. [III] Why set does not have get() method? List implementation passes the index as the argument of get method while Map implementations passes the key as the argument of the get method. Set implementation does not have either thus it does not have get method. 
14. The classes and interfaces of collection framework are in java.util package.

|LinkedList Class|
LinkedList Class is doubly linked list which implements the List interface and Deque interface. Since it implements List interface so it is ordered and can contain duplicate elements. It can contain null values as well. It is non-synchronous like ArrayList class. Manipulation is faster in LinkedList because no shifting is needed. The concept of doubly linked list is that the elements of the linkedList are treated as nodes and connected by double linked with preceding and succeeding element. That is why named as doubly named, not because it implements two interfaces. 
Detail on Doubly Linked list, check: http://java2novice.com/data-structures-in-java/linked-list/doubly-linked-list/
I have tried creating the object of the LinkedList. Then, I tried adding, printing and removing the elements from the linked list. It is very much similar to the ArrayList. Many of its methods are same as methods of arrayList. Check other all the tabs of the below mentioned link.
Must to check: http://beginnersbook.com/2014/08/java-linkedlist-class/
Where to use – It should be used where the insertion and removal of elements is more frequent than searching an elements. 
[III] Internal Working:
Well, not too sure about the internal working of LinkedList but it uses double linked list internally. Thus, when we try to add an element to a LinkedList it adds to a doubly linkedList. Once we do dat structure, it will be better. 
Comparison between ArrayList and LinkedList
1.	Search operation arrayList is much faster than of linkedList. This is because arrayList maintains indexed based system as it uses array data structure implicitly but linkedList uses doubly linked list data structure which requires traverse through all the elements for searching an element. Also, array data structure stores the elements in the linear sequence and every element associated to an index. 
2.	Insertion and removal of an element in a linkedList is much faster than in arrayList. This is because elements in linkedList are connected through double links with other elements and can be added and removed from the list without shrinking of expanding. While in array list, whenever an element is added or removed than a lot shifting of element occurs. 
3.	Memory Overhead – since linkedList maintains the data as well as two links to connect two elements while array maintains data and index. Therefore, arrayList uses lesser memory than linkedList. 
4.	Both are non-synchronous and can be synchronized explicitly.
5. [III] Linked list does not have random access feature like arraylist because it does not implement the random access interface. This means it may take different time for getting different element in the linkedlist.

|Vector Class|
Vector implements the List interface and it is similar to arraylist collection as it also an ordered collection which stores data on the basis on index. It is synchronized. Since, it is synchronized, it is thread safe as well. It can contain null values as many as user wants.
I have practiced an example. It is similar to arrayList and linkedList in creating, adding, removing and printing the elements. 
Where to use – It should be used in the multithread environment as it is synchronous. We must avoid using it in single thread case because it has less efficiency and arraylist should be used in single thread cases.
Internal Working:
[III] Vector class implements growable array of object and thus quite similar to arraylist. Only major difference is that vector is synchronized. Most propbably, vector class must be using array behind the scene. Also, vector should not be asked to implement in interview as its synchronized collection. 
Note:
1.	Vector increases its size from 10 to 20. That’s is just double. 

|ListIterator Interface|
List interface extends the collection interface and declares methods to insert and delete the element in the List. It is also a factory of ListIterator interface. We have studied the Iterator interface which is extended by collection interface and use to iterate the elements of collection. listIterator interface is specific to List collection. It has few methods like hasnext(), next(), hasPrevious() and Previous(). First two are same as the methods of Iterator interface but other two are to provide the iteration in opposite (backward) direction.
I have checked the example. We have to create a list collection (any type). Then, create an object of listIterator interface for list collection object. Carefully, check the syntax for do this. Then, apply the iteration using listIterator method. 
Note: There are mainly three ways to iterate a list. First, to iterate with the simple for loop where we make use of list.size method. Second, we use advance for loop which is only possible with generics where we know the type of the list element. Third, we can make use of iterator where we first make iterator object and then make use of its methods. 

||Set Interface||
Set interface – Set is a collection that cannot contain the duplicate elements. Some of the Set implementations are ordered and some are not. Set allows only one null element. There is no such thing as listIterator for Set but we use Iterator for Sets. It extends the collection interface.
Note: [IIII]
1.	We do not have a get() method in Set interface. Then, how can we get a single value or element of set? We can do it through Iterator next method. The reason why we do not have get() method in any of the set implementation is because we do neither have index nor key to get the value like in list and map. Also, there is no point calling the value by passing the value since you already have it that why you able to pass it. The other way of looking into it is the set does not guarantee any sequence of element sorted unless the implementation does. 

|HashSet Class|
HashSet class implements the Set interface and so it cannot hold duplicate elements and can have only one null element. It is not ordered so can iterate elements in any order. It is non-synchronous. It stores its element in hashTable. (Hashtable is also a data structure which accommodates the value by mapping it to a key. It is also called as associative array.) 
I have tried an example and found that it is similar to List interface. First we need to create its object and then with the help of methods like add(), remove() we can add and remove the elements. Iterator is used for iteration of the elementsCheck all the tabs of the link below. Also, if two null values were inserted then only one will be printed and no exception or error will be given. Same with duplicate values, it will print one value without giving any exception. 
Note(s): 
How Hashset works internally?
[III] Hashset uses Hashmap internally. Whenever we try to add any value into a hashset through add(element) method, internally put(element, default_value) method of element is called. Now, the element is treated as the key for the hashmap on which hashset is based and default value (example: present) will be value for hashmap entry. Put method returns the previous value associate with the key. If no previous value is found then it insert the entry and add method returns true while if a value associsted with the key already found then put method will return value and add method will return false and value will not be inserted. Obviously, put method find the hash value for the element and chooses the bucket for it. Likewise, when we try to remove the value from hashset, the key with the same hashcode is searched and removed from the hashmap. 
Note: 
1.	How to insert null value? The correct way of inserting the null value is to write “null” without double quotes. When we write nothing in the double quotes then it is means inserting the empty String.
2.	Hashset is based internally on Hashmap by keeping element of hashset as key with some default as value.
3.	SortedSet class implements navigableSet interface.
4. 
5. [III] We can get synchronized set using collections class like collections.synchronizedSet(HashSet). 
6. HashSet implements clone() method and can create shallow copy of it. 
7. [III] emptySet() returns empty and immutable set. For immutability we can get it. Can do more research on this. This is just like Arrays.asList() gives an immutable ArrayList. 
8. [III] Initial capacity of HashSet is 16 and load factor is .75. The product of (initialCapacity*load Factor) is the size of the hashset when rehashing happens and a new hashset of double capacity gets created. This mean load factor*capacity will decide when to do rehashing but the new size after rehashing will be double of the previous capacity.
Must to read: http://beginnersbook.com/2013/12/hashset-class-in-java-with-example/

||LinkedHashSet||
LinkedHashSet implements the Set interface and so it cannot contain duplicate elements and can contain only one null element. LinkedHashSet maintains the order of insertion i.e. it will iterate the elements in the order of insertion
I have found nothing on whether they are synchronous or not. I feel that they are also non-synchronous. It is same as HashSet except the order of the elements iteration.
I have checked an example and everything is same. Though check all the tabs of the link given below.
Must to read: http://beginnersbook.com/2013/12/linkedhashset-class-in-java-with-example/
Internal Working:
[III]LinkedHashSet extends HashSet class. It does not have any method of its own while it calls all the methods of HashSet class and thus it behaves similar to HashSet. The only difference in both is LinkedHashSet maintains the order of insertion. It iterates the values in the order the values was inserted. 
Note: [III]
1.	LinkedHashSet is internally based on LinkedHashMap. The elements of LinkedHashSet is stored in LinkedHashMap while value as some constant default value. But, along with this, before and and after value references are also stored with each entry. So, linkedHashSet stored the values like (before+KeyValue+After). Since, each entry has info about the before and after element reference thus LinkedHashSet becomes able to maintain the order of insertion. 	 

||TreeSet Class||
TreeSet class implements the Set interface and so it cannot contain the duplicate value. Unlike other sets, treeSet cannot contain any null value and if tried then nullPointerExcetion will generate. Actually, adding null element in treeSet was possible until java 6 but later it declared as bug. [III] TreeSet maintains the element iteration in ascending order or the order according to the external comparator provided while creating the map. which means from latest inserted to the older. It is non-synchronized. It is similar to hashSet except the order of element iteration and null value difference. 
I have checked the example and everything is fine. Just check the tab in the link below. 
Must to read: http://beginnersbook.com/2013/12/treeset-class-in-java-with-example/
Internal Working: [III]
TreeSet implements navigational map interface. It is backed by Navigational map object. We can explore more about navigational map. 
Note: [III]
1.	Treeset connot contain any null value because it internally uses treemap. Treemap uses natural comparable interface (implements NavigableMap interface which is a sorted map) which throws an exception when any key of the treemap inserted as null. Thus, we cannot have even a single null value in TreeSet.
2.	TreeSet stores the elements in ascending order. But how this happens? I think behind the scene it uses comparable interface. Because elements types like String, Integer implements comparable interface and thus we gets it. However, in case of user defiend iobjects we need to explicitly implement comparable interface other the order of object will be natural.

Note: check time complexity and try to relate them with the different type of collections. 

||Queue Interface||
Queue Interface – It extends the collection interface and Iterable interface. It represents a group of object just like list but the data is intended to be inserted at the end of the queue. The elements are ordered in First in First out manner. It has two implementations which are LinkedList Class and PriorityQueue class. Ordering is must. Duplicate elemente in terms of equals contract are considered distinct in queue as there is no two elements with same ordering and thus it contains duplicate elements. 
Basic methods of Queue Interface:
Insertion: add(e) to add an element and if queue is full it gives exception, offer(e) to add element and return a special value if queue is full.  
Removal: remove(e) to remove the head element and throws exception if queue is empty, poll() to remove the head element and returns a special value if qeueue is empty.
Examine: element() to find out the head element and throws execption if queue is empty, peek() to find out the head element and return as special value if queue is empty. 

|PriorityQueue|
Priority queue implements the Queue interface and but it is not necessary that it follows FIFO. However, it is an exception in collection and it follows the natural ordering or ordering done by the comparator passes as an argument. It can contain the duplicate elements as a property from queue interface. It cannot contain even a single null value. It is non synchronous. 
Internal Working:
PriorityQueue represented as a binary heap. The priority queue is ordered by a comparator or by elements natural ordering. Initial capacity of the priority queue is hardcoded as 11. It on its root level uses an array of object.  
Priority Queue Implementation: http://www.java2novice.com/data-structures-in-java/queue/priority-queue/
|LinkedList|
LinkedList is another implementation of Queue interface. It implements all the methods that a queue needs to perform its operations. 
Note: 
1.	Blocking Queue is tread safe version of a normal queue where enqueue of full queue blocks the thread and dequeue of empty thread blocks the thread too. Blocking queue is a perfect ready to use solution for producer consumer problem and programmer do not need to write wait and notify method to handle this problem. 
2. 	Queue implementations does have differences on insertion of null. Like, LinkedList allows the insertion of a null while PriorityQueue do not allow insertion of null. Poll method returns null if queue is empty. Therefore, even if linkedlist allows insertion of null, but we should avoid this. Because when poll returns null then we wont be sure if null returned is because it was on head of queue or the queue is empty.  

||Map Interface||
Map interface – It extends the collection interface. It takes the element with respect to a key as a combination of key and value. The pair of key and value is called as Entry. Entry is a sub-interface of Map. We can access it by Map. It provide key to provide methods to get key and value. 

|HashMap Class|
HashMap is a class that implements the Map interface and hence it contains a pair of key and value. [III] It cannot contain duplicate key but can contain duplicate value. Elements are not ordered in this class. It permits one null keys and multiple null values. It is not synchronized. The difference between HashSet and HashMap is that heshSet contains only values while HeshMap contains keys and values both.
I have tried an example. Firstly, I create an object where we need to specify the key and value types. Then, to add the values to a Map, we have used put() method instead of add() method. We can print the object of Map. Now, if we have to iterate the entries (pair of keys and values) then we have to create an object of iterator as usual. However, to create object of iterator we have to first create a Set view of a Map. For doing so, the syntax is: “Set obj = MapObj.entrySet()”. But why do we need to create the set view? Check note point below. Then, we can iterate the keys and values using Set view object. Though I have understood the basic methods still check all the tabs and methods of the below link.
Must to read: http://beginnersbook.com/2014/08/java-hashmap-class/
Internal Working: [IIII]
HashMap works on the concept of Hashing however its not as simple as it sounds. Hashing is concept of assigning a unique code (ideally, but not in this case) to an object. A hashing algorithm gives the exact same hashcode to the same object. HashMap class stores the data in the form of entries. It has an inner class Entry which holds the key and value pair. Therefore, it is better to say that HashMap stores data in the form of inner class Entry’s object rather than as key and value pair. 
Placing a value: HashMap while placing any value in the HashMap uses put() method which first checks if the key of then given entry is null. If the key is null then the hashcode given will be zero. HashMap class has hashCode() method which is used to get hashcode of any key. In order to get the value within the limit of an array another method hash(key.hashCode()) is called. The necessity of hash() will be exploring in coming para.  HashMap class do also have indexFor() method which takes the hash and table.length to find out the suitable index to store entry instance.  
Hash() method is basically to defend poor hash code for an input to avoid possible head collision and to spread entries evenly among hashmap buckets. HashMap uses power of two length of hash table and it is important for hash to be different in lower bits. So, with hash() method, we are trying to have more difference in lower bit of hash provided by hashCode() method. IndexOff() function simply takes the output of hash() and find the index by method of power two (like for hash 0000001111, index would be 15). For more detail: https://java2blog.com/hash-and-indexfor-method-in-hashmap/. 
Now, it is possible that two different keys may have same hash code and ultimately the index found for them would be the same. In this scenario, both the entries will be stored in the same bucket. Also, each bucket is linkedlist in the older versions of java while treemap in newer versions of java. 
Avoid duplicate keys in HashMap: HashMap does not allow duplicate keys. In other words, if a key already is present in HashMap and we try to add another entry with same key then a new value gets updated. But how this happens? Hashcode of a key is find out first and then index where to keep that entry. Now, if that bucket already has some entry then the keys of all the existing entries will be checked through equal. If any of the existing entry key is matched then the value of the existing entry of that key is updated with the new value instead of adding that entry.  
Getting the value: While get() method is used then key is passed as an argument. The same process happens to find the bucket after getting the key. Once the bucket or index is found then the value is returned when only entry is present in the bucket. However, when multiple entries are present then hashcode are compared for each entry using equals method. The once that matches, its value is returned.
Note: 
1.	[III] Why does Map not has any iterator? We can understand the requirement of the set view as the HashMap class does not have the iterator method while set interface have. So, we create an object of set class. Since it is an interface thus we cannot create its object directly and hence we do it through the entryset class that returns an instance of the set interface. I am not sure about this but the reasoning looks fine. Also, map does not have iterator() method because a map can be iterated through entries, values or just by keys. Thus, it was design decision to convert the map to a set or list for an entries, values or keys to iterate over.
2.	In the hashmap of length 8, a maximum of 8 buckets are possible.
3.	[III] Put method of hashmap returns object currently associated with a given key to see if a key already exist. It returns null if no value was associated with the key earlier. 
4.	Hashing ideally should give unique code for each input while can have same hashcode even when the same input is given. There are different hashing algorithm which are used to perform hashing. Keep that in mind, it not necessary that all hashing algorithm procudes unqiue hash for an input and this mean two different inputs may have same hashing. It completely, depends on the hashing algorithms. hashCode() function of hashMap class is good example.
5.	We have concurrentHashMap to avoid concurrentModificationException when some thread tries to modify a map while it is iterating and sunchronizedMap gives a synchronized version of map which is basically thread safe.
6.	[III] Whats the difference in concurrent collection type and Synchronized Collection? Concurrent collections like CopyOnWriteArrayList, ConcurrentHashMap are present inside concurrent package of JDK and are normal classes. By concurrency we avoid having concurrent modification exception when collection is modified while its under iteration. With concurrent collection (HashMap), we divide collection into different segments and thread safety is provided on the basis of each segment. By default, a HashMap object is divided in 16 segments and thus 16 threads can work simultaneously on a collection object but each at different segment. On the other hand, we have synchronization which is for getting thread safe collection. Here, the lock is provided on the entire object (not on the segments of an object). So, the bottomline is that where we need segment level concurrent changes in a collection then use concurrentCollection while for one thread at a time usage, we need to use SynchronizedColleciton.  
7.	[III] Index access is the situation when we can get element at nth index directly by moving the cursor directly to nth index while iterator access is a situation where we iterator from 1st index through nth index to get to the element at nth index.
8.	Sample of hashcode function override:
    @Override
public int hashCode() {
int result = 17;
result = 31 * result + name.hashCode();
result = 31 * result + age;
result = 31 * result + passport.hashCode();
return result;
    }
HashCode and equals methods are can be generated through eclipse directly. 
9. What will happen if we try to store an entry with key thats already present in the Hashmap? Then the value will get overriden. 
10. [III] Array is the pure datastructure used to created buckets while linkedlist stored all the mappings which maps to same bucket. So, a bucket is what linkedList is while table of bucket is the array of the linkedlist. Thus, HashMap is said to be based on HashTable (array of linkedList). 
11. Difference between size() and capacity. Capacity will literally give the capacity (how much it can store) while size will give the entries currently present in hashmap.
12. TableSizeFor() is the method in HashMap class that gets the size of the table to be created as power of two by taking the initialCapaciy as the argument. 
13. [III] How hashmap handles a single key as null? HashMap handles the null key case as special one. Therefore, before it call hashcode method to find hash of key, it checks if the key is null. If the key is null then it does not even call hashcode function but it assigns the bucket zero for keeping that entry. If another entry comes with null then again bucket 0 will be allocated and if an entry exist with key null then the value only gets updated. Also, at the time of get, the key again found as null and value is directly called from bucket 0 with key as null.  

|LinkedHashMap Class|
LinkedHashMap implements Map interface and extends the HashMap class. It has all the properties of HashMap class but ordered in the order of insertion. Also, LinkedHashMap is HashTable and LinkedLink implementation of Map interface.
I have tried an example and it is the same as hashMap and seen the iteration in the order of insertion. Check the below link carefully. 
Must to read: http://beginnersbook.com/2013/12/linkedhashmap-in-java/
Internal Working: [III]
As we see that LinkedHashMap extends HashMap and thus make use of a lot of methods of the HashMap class. Constructor of the LinkedHashMap calls constructor of HashMap. 
Note:
1. [III] How LinkedHashMap able to maintain the order of insertion? LinkedHashMap extends HashMap class and gets all it features and along with that it maintains the order of insertion which HashMap does not. Well, the core difference lies Entry object. In LinkedHashMap class, Entry object uses HashMap inner Entry only to create entry object it create two additional references Head and Tail. These head and tail are appended with every entry. Whenever a put operation is invoked, head gets instanciated. Thus, with these extra head and tail references, LinkedHashMap is able to maintain the order of insertion. 

|TreeMap Class|
TreeMap implements the Navigational Map interface and extends AbstractMap methods class. It also cannot contain duplicate key while replaces the latest value for a key with an existing value. [III] It can have multiple null values but cannot have any null keys. It is same as HashMap but it has the ordering of the elements in ascending order. TreeMap is Red Black Tree based Navigational interface implementation.  
I have checked a program and it is same as other Maps. Check the link given below.
Internal Working: [III]
Treemap is backed a Navigable map object. With navigational map, Treemap is able to maintain the order of entries in the natural order of elements or through any comparator explicitly provided. 
Treemap does not works on principal of hashing while it works on the principle of red black tree. Right from the first entry, treemap performs sorting and always keeps its elements in order. As the name says, TreeMap is quite equal to work with a tree, thus it has parent, left and right elements. Left element will always be logically lesser than parent while the right element will always be greater or equal to the parent. While a value is placed using put method, compareTo() method of overridden by the comparator or default compareTo implementation would be used. Each value placed is added as a tree node. The logically smaller entry is added on left while the greater on right. 
Check the example on this wonderful exaplaination: http://www.thejavageek.com/2016/06/07/working-of-treemap/
Must to read: http://beginnersbook.com/2013/12/treemap-in-java-with-example/
Note:
1.	[III] Since treemap implements sortedMap interface which provide ordering on the basis of the key. Thus, by default the entries get sorted. 
2.	[III] Treemap uses natural comparable interface which throws an exception when any key of the treemap inserted as null. Thus, we cannot have even a single null value in TreeSet.

|HashTable| [III]
HashTable is an array of list. Each list is known as bucket. It implements Map interface and extends Dictionary class. Actually, HashTable has implemented Map interface in java 1 and is part of collection framework. It is similar to hashMap and will update the latest value for a duplicate key placed in. It cannot contain any null key or value. Hashtable is synchronized. HashTable does not maintains the order of iteration. 
Internal Working:
I checked it myself. While creating a Hashtable, an array of Entry objects gets created. All the methods of Hashtable works similar to HashMap but all are synchronized. 
https://www.javaworld.com/article/2077346/core-java/hashtables.html
Differences between HashMap and HashTable 
1.	HashMap is not synchronized (can explicitly be synchronized) while HashTable is synchronized. 
2.	HashMap can contain null values (one key and multiple values) but HashSet cannot contain any null values. 
3.	[III] HashMap introduced in Java 1.2 and HashTable is a legacy class.
4.	HashMap is faster than HashTable. (apply sync. and non-sync funda).
5.	HM can be iterated by iterator but HT can be by Iterator and enumerator.
6.	Iterator that HM has is Fail-Fast while Enumerator in HT is not Fail-Fast.
7.	HM extends AbstractMap  class while HT extends Dictionary class.

Note: 
1.	HashMap garauntees no order of element over a period of time. LinkedHashMap order the element in the order of iteration. TreeMap orders the element in ascending order of key. 
2.	We have three collection views of Map. Since, map is not counted as Collection then we can have collection view of map which are Keyset, entrySet and Values. Keyset contains the set of keys contained in a Map. EntrySet is a method of map interface that provides the set of key and value. Likewise of keyset and entryset, we have value method which provides the set of values present inside a map.  
3	Java.util.properties extends java.utils.hashtable. 
4. [III] Hashtable cannot contain null key or value. This is because of the basic eligibility for a key is that it should implement hashcode and equals method however since null is not an object so cannot get the hash for it. Also, HashMap came after Hashtable into existence and was built as an improvement of Hashtable. HashMap has handled to have only one key as a null and many null as value. Also, there is a if condition to handle that null key check. 
5.	Fail Fast – it means that when we try to iterate and mean while try to modify the content then it will give an exception “ConcurrentModificationException”. 

||Sorting||
In collections, we generally use String, Wrapper class objects and user defined objects. We can sort the element of String object, Wrapper class object and User defined class object and to do so the element should be comparable. String and Wrapper classes implement the comparable interface implicitly. User class need to explicitly implement the comparable or comparator interface and override its method. 
Collections class provides a static method for sorting the elements of list collection.
I have checked an example. First, create any type of List collection and insert elements in it. Then, simply by using the sort() method, we can sort the elements. String type is sorted in alphabetic order and Integer (Wrapper) is sorted in increasing order. However, sort() method only applicable for list. 
Note: 
1.	collections sort uses Arrays sort method so has same performance. But takes sometime to convert the collection to array. 
2.	Please do not get confused with the words: Collection interface – It is an interface which extends the iterator class and extended by all the lower level interfaces. Collections class – it contains the static methods for sorting the collections, concurrent collection, synchronized collection, readonly collection and many more having certain types of elements. Collections (neither interface nor class) meant as a plural version of the word collection. ;-)

||Comparable Interface||
Comparable interface is used to order (sort) the objects of user defined class. This is because the String and Wrapper class are already comparable and can be compared by Collections class method sort(). It contains only one method called compareTo(Object). You can sort the elements based on the single datamember like rollno, name, age etc. 
Note:
For every user defined class, it is necessary to implement comparable interface so be able to be sorted through sort() api of collections class. To use comparator, we need to create separate comparator class and use them as argument in sort() method. If just one comparator is used then that comparator is used directly while if multiple comparators are used then chained comparator is used as argument of sort() method. 

||Comparator Interface||
Comparator interface is also used to sort the object of the user defined class on the basis of multiple datamembers. This interface contains two methods for sorting. First, compare(Object o1, Object o2). This helps in comparing the object on the basis of multiple datamembers.  
Notes: [III]
1.	We cannot implement comparable outside the user class. We cannot create idComparator type class with comparable. Thus, we cannot created chained comparator like chained comparable. Thus, we cannot use comparable for sorting on the basis of multiple data members.  
2.	For sorting on the basis on multiple data member, we need to create multiple comparator class. Then, we need to club them all in chainedComparator class. In chainedComparator class, we need to create a list of comparator which will be initialized inside the constructor. The constructor uses “…” to give freedom of having any number of argument. Then, we need to override the compare method. Inside compare method, we need to use for each loop, to iterate through all the comparators. Inside for loop, we need to use if condition to return the int value if the value int value result is unequal. 
3.	Equals method method gives Boolean value depicting wether two object are equals or not while compareTo tell which is greater over other on the basis of data member. 

Differences between Comparable and Comparator interface
1.	Comparable provides single sequence sorting (on the basis of single datamember) while comparator can provide for multiple data member.
2.	Comparable affects the original class while comparator does not. 
3.	Comparable has one method compareTo(T object) while Comparator has two methods which are compare(T o1, T o2 ) and equals(T object). 
4.	1st has lang package and 2nd has util package. 
5.	They have different parameter of their sort method.

Properties Class
This class is used store the data in the pair of key and value in the form of String. It is sub class of HashTable. We can add and access the properties values through the properties keys from the properties file. The main advantage of properties file is the lowest maintenance. Once the pair is saved and then we do not need to execute it again to update the value. Properties class has the facility to specify default value when no value is defined for certain key. 
There are few examples of properties files. First is to create a properties file. Second, getting the information from the properties file and third, is to get the properties of the system.Check later when get time.
Note: [III]
Tell your experience of using properties class! Almost every project has properties file which we use to store key value information generally are URL, db connection detail, end point or anything which suppose to be used in the entire application. We have to create .java class for loading properties file. In one of my project, I have used factory pattern where a factory class gives a singleton object of a property class.
We first have a parent level class which is an abstract class and has a constructor which takes the file name and loads it. Then, factory class uses it and has a get method for each property class. 

||Random Topics in Collection|| [IIII]
|Load Factor|
Firstly, load factor is not applicable for all the collection classes. Load factor is a concept of deciding when to do the resizing of certain collection classes. The product of intial capacity and load factory is the size when a particular collection get resized. Like, a HashMap has a default initial capacity of 16 and load factory of .75. Thus, when the size of hashmap reaches to 12, it get resized (provided its created using default capacity) to just double of initial capacity i.e. 32. Load factor decide when to resize, but not how much to resize. 
Now, we will look why load factor is not a concept for all the collection classes. All the hashing based collection classes like HashMap, LinkedHashMap and other can possibily store more entries than their capacity because of chances of hash collision. Now, having hash collision is not good for hashing based collections performance and thus it has a concept of load factor which is generally kept below .75 which can be changed for better performance at the cost of memory. On the other collection classes like Arraylist, LinkedList, Vector, Treeset and Treemap, which does not follow the concept of hashing and can store elements or entries only equal to the capacity. Thus, we do not mind to alter the concept of resizing other than what is default. Thus, we do not have a concept of load factor (i.e. it mean has load factor of 1). Conclusion, We typically do not want to change the way resizing done for non hashing based collection classes however we might be interested in Hashing based collection classes to improve performance. 
Also, load factor is generally be altered while created a collection while cannot be changed once its created. HashMap has a constructor HashMap(Initial Capacity, Load Factor).

|Cursors|
Java has a concept of cursors which is nothing but an iterator which can iterate or traverse through the elements in collection or stream objects one by one. Java has so far four cursors which are Enumeration (Java 1), Iterator and ListIterator (Java 2) and Spliterator (Java 8). We already know the issues with enumeration like its one directional, has really long method name, supports only READ CRUD operation and other. Iterator and ListIterator came as improvements. Iterator too though a one directional cursor but has shorter names, essentially can perform READ and DELETE CRUD operations.  Also, Enumeration is supported only by legacy collection classes like HashTable while not supported by classes like HashMap. On the other hand, Iterator is supported by all the collection classes. ListIterator is specific t List and its bi-directional cursor. @@@pending: We will look at spliterator while studying java 8 feature.
Need to be done
1.	Data structure of all the collection and then do the other important data structures.
2.	Try to complete the Data structure and algorithms tutorials. http://www.tutorialspoint.com/data_structures_algorithms/

|References and its categories|
Object is some object instance placed in memory while reference is the memory address of that object. We have around 4 categories of references in java which are discussed below:
1.	Strong Reference
The normal default reference that we create is a strong reference. Any object which has a active strong reference is not elgible for garbage collection. Have a look at the below code:
ClassName ref = new ClassName();   //not eligible for GC as its an active strong reference. 
Ref = null; //eligible for GC as strong reference in not active now. 
2.	Weak Reference
A weak reference is not a default reference and need to be created a little differently for any given object. If an object is only referenced by weak references then it is eligible for garbage collection. We can use java.lang.ref.WeakReference class to create a weak reference. 
A good example of weak reference would be the entry object in WeakHashMap class. Also, in enterprise application, weak reference can be used while estabilishing DB connection which might get cleaned up when the database gets closed. 
ClassName strongRef = new ClassName();    //a strong reference is created. 
WeakReference<ClassName> weakRef = new WeakReference<ClassName>(strongRef); //Weak Reference created pointing to the same object where strong ref is pointing
strongRef = null;  //only weak ref is pointing to the object now so it is eligible for GC.
weakRef.get();   //returns the object
We have couple of levels of weak referencing which are soft and phantom references.
3.	Soft References
Similar to Weak references, if an object is only referenced by soft references then the object becomes eligible for garbage collection. However, GC will still not garbage collect it until it does not need the memory desparately. Only when the GC runs out of memory then it will GC all the soft references to gain memory. We can use java.lang.ref.SoftReference class to create a soft references. Check the code below:
ClassName strongRef = new ClassName();  //strong reference
SoftReference<ClassName> softRef = new SoftReference<ClassName>(strongRef);  //created soft reference which is pointing to the same object which strong reference is pointing. 
softRef.get();  //returns the object
4.	Phantom Reference
Phantom reference also makes an object eligible for GC. However, before being removed from the memory they are placed in a queue. They are placed in the queue after calling the finalize method. We can create phantom reference through a class java.lang.ref.PhantomReference().
ClassName strongRef = new ClassName(); //strong reference
PhantomReference<ClassName> phantomRef = new PhantomReference<ClassName>(StrongRef);
phantomRef.get();  //gets you null. 

[IIII] Revise all collection interfaces and implementations. Below is quick revise:
@@@List: Dupes(yes), Order (all in insertion), Null (all as many as wants)
@AL: Sync(no)
@LL: Sync(no)
@V: Sync(yes)
@@@Set: Dupes(no)
@HS: order(no), null(yes but 1), sync(no)
@LHS: order(yes, insertion), null(yes but 1), sync(no)
@TS: order(yes, ascending), null(no), sync(no)
@@@Map: Dupes(values gets updated for duplicate key)
@HM: order(no), null(1 key, many value), sync(no)
@LHM: order(yes, insertion), null(1key, many value), sync(no)
@TM: order(yes, ascending), null(no null key, many values), sync(no)
@HS: order(no), null (no null key or value), sync(yes) 

=====================================================================================
Java JDBC
JDBC Introduction
Java JDBC (Java Database Connectivity) is a java API which connects and executes query with the database. JDBC API has JDBC driver which is specifically used to connect the java application with the database. Now, why to use JDBC? Before JDBC, we had ODBC whose driver was written in C language which is platform dependent and unsecure. There, we have java API JDBC which has its driver written in java that makes it platform independent and much more secure.
API – Java API is a set of classes included in the development environment (this refers to packages and libraries). These classes are written using java language and run on the JVM. So, basically it contains all the classes of the java that forms its basis. Also, JDK has two main things which is the compiler, debugger and other classes and the JRE. Now, JRE contains the JVM and API (libraries and packages). 

JDBC Driver 
The JDBC driver is responsible for the connecting the java application with the database. The JDBC drivers are of 4 types. 
1.	JDBC-ODBC bridge driver – This converts the JDBC function calls into ODBC calls. This needs to be installed in the client machine. Though this was easy to connect and use.
2.	Native API driver – This instead of converting the JDBC function calls into ODBC converts the function calls into Native Database API library. It is not entirely written in java. Its performance is better than JDBC-ODBC.
3.	Network Protocol Driver – This include a middle ware in the form of application server. This driver uses the middleware to directly or indirectly convert JDBC calls to vendor specific database protocols. It is fully written in java. However, network support is becomes necessary for the client machine. Also, needs the database specific coding needs to be done in the database. 
4.	Thin Driver – This driver itself converts the JDBC function calls to vendor specific database protocols. It is also known as Thin driver. It is fully written in Java. It has the best performance among all the types but we need to choose it according to the database type. 
Note: Actually driver is mainly needed to convert the JDBC function calls to vendor specific (Oracle, sql, Mysql etc) protocols.  

5 steps to Connect to the Database in java
To connect the java application with the database we need to follow 5 steps. These steps are
1.	Register the driver class – This means we need to register the driver class with the application. This can be done by forName() method of the Class class. 
2.	Create connection - We can create a connection using the getConnection() method of DriverManager classes that we just got after registering the driver. 
3.	Create statement – we can do this by createStatement() method of the connection interface. 
4.	Execute a query – This we can do by executeQuery() method of the Statement interface. We print the result set using while loop.
5.	Close connection – this we do by close connection of connection interface. 
Note: Check the coding of all the above steps. 

Connecting the Oracle Database
Well, we already know the following steps to connect the database. However, while connecting to a database we need to have some database specific information. Let’s try for oracle 10g. Driver class for it is “oracle.jdbc.driver.OracleDriver”. So, we have to register this class to our java application. Then, the URL needed while making connection. It is “jdbc:oracle:thin:@localhost:1521:xe” where jdbc is the API, oracle is database, thin is a type of driver, local host is the server name, we may use the IP address, 1521 is the port name and xe is the oracle service name. We need pass username and password while making connection. Username is System and password is given by us. 
I have tried to make connection and made entire program correct. Though, it was giving one error because the ojdbc jar file was not loaded. So, what is this ojdbc14.jar file and how we load it?
Ojdbc14.jar File – This file need to be loaded for connecting the java application with oracle database. OJDBC is oracle java database connectivity. 
The ojdbc14.jar file can be downloaded from internet and then pasted specifically in JRE/Lib/ext path and then the path should be set. Path can be set either by command prompt or by the control panel.  While setting with command prompt the syntax is “Set ClassPath = c:\folderpath\ojdbc14.jar;.;”

Connecting the MySQL Databse
Try this later if you get time. 

Database connectivity with Access with and without DSN
Access is a Microsoft based DBMS just like oracle, MySQL. In this section, we are describing about the procedure of connecting the java application with the access database with and without DSN. DSN is Database Source Name which contains all the information about the database to which the ODBC is to be connected. 
Try this later if get time because java applications are mostly connected with Oracle, MySQL and SQL.

Driver Manager Class
This class acts as an interface between the java application and the driver. It keeps track of the drivers available for creating the connection. This driver manager class has a lot of driver and it maintains a list of drivers which are connected with any java application. Check the methods of the DriverManager class. It has methods of registering, deregistering a driver and creating connections.

Connection Interface
It is used to create statement object. By this only, we can execute the queries. Also, this interface is used for providing many important SQl trasactions methods like rollBack(), Commit() and AutoCommit(). Also, we can close the connection with Close() method. 

Statement Interface 
This interface is used to execute the SQL statement and creates the resultSet. It has different methods for different category of commands. Like for select statement we have executeQuery() method while for all update related SQL statement (create, drop, insert, update, delete etc) we have executeUpdate()  method. Also, for returning multiple resultset we have “public boolean execute(String sql)”. We can execute batch Cmmands as well by public int[] executeBatch() method. 
Note: Batch file in SQL contains a set of commands (batch) which are always written together so that you can simply enter the batch name rather than writing the set of command every time you to use.   
ResultSet Interface
The object of resultSet contains the resultSet which we get after executing a SQL query. Its object maintains a cursor at a particular row of data. Initially, cursor points towards the first row. By default, resultSet object can move further but cannot be updated. However, we can make this object updatable by passing “ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.TYPE_SCROLL_UPDATABLE”.  Also, check the methods that it has for moving cursor. 

PreparedStatement Interface 
It is a Sub-Interface of Statement Interface. It is used to execute parameterized query. We pass “?” as a parameter. The value will be set the setter method of the prepared statement.
Why to use PreparedStatements – The concept of prepared statement is that these statements are compiled once and can be executed multiple times. So, it increases the performance as the statement is not compiled every time we call it.
I have checked few examples. We have to register the driver and then create the connection. Once, it is done then we have to create a prepared statement object and pass the sql query as an argument which is different from simple statement. Since we pass the “?” as the argument of SQL query so have to define these arguments with the help of the methods of the preparedStatement interface. Also, check the syntax for creating the preparedStatement. Then, we have to execute the statement using execute method depending on the type of query. Then, we can print the result that we have taken in an integer variable. Practice few examples.
Note: The prepared statement are compiled and saved within the DATABASE. Though, remember that not all the databases support the prepared statement.  
ResultSetMetaData Interface
MetaData is the data about the data i.e. the further information that we get from the data. We can get the meta data of the result of the executed SQL query. This can be done by the methods of the ResultSetMetaData Interface. It has methods like getColumnCount(), getColumnName() etc. I have checked an example and we can simply call the methods of the resultSetMetaData interface by the objects of the resultSet Interface. However, the object of the ResultMetaData can be created with the help of the getMetaData() method of the ResultSet Interface.

DatabaseMetaData Interface
We can get the MetaData of the Database by the help of the methods of the DataBaseMetaData Interface. It has got the methods like getDriverName(), getDriverVersion() etc. we can simple create an object of DatabaseMetaData interface and use its methods. However, to create the object of the DatabaseMetaData class we have use the getMetaData() method of connection interface. Syntax is: “DatabaseMetaData md = con.getMetaData()”. This will return an object md of DataBaseMetaData class. Check its method and try the examples.

Storing the image in the Database
We can store an image in the database with the help of preparedStatement interface method called setBinaryStream(). This method is used to set the binary information into the parameterized index. In its example, the driver was registered and connection was made. Then, we have connected a prepared statement and passed an sql query which updates an images with its name in the name column with string data type and photo column with BLOB data type. BLOB (Binary Large Object) is used as the data type in the database to store an image. Then, we have to use the setString() of prepared statement to set the name and SetBinaryStream() method for setting the image in the photo column after creating a fileInputStream which refer an image. Then, we have to execute the update query and get the result set. Try an example.

Retrieving image from the Oracle Database
Even after storing the image in the database, when the table is seen all the data will be shown except the image. To show the image, : Before java7, we could use int, short, char and byte. We could have used wrapper class version of these as well. With java 7, we can now also use String in the switch case statement. we have to retrieve the image from the database. To do so, we use getblob() method of the prepared statement which is used to get the binary information and getbytes() method which is called on the blob object  to get the array of the bytes of the binary information that can be written into the image file. In the example, we create the prepared statement. Then, if statement we get the blob object (which means blob is data type as well as a class like string) that gets the binary information of the image through getblob() method. Then we create an array of byte on the object of blob. Then, we write the array of byte on the image using the FileOutputStream. Check the example for better understanding. Check why retrieving an image is important in Database.

Store file in Database
This is same as storing an image in a database, though the data type of a file for database is CLOB (character Large Object). We make use of the setBinaryStream() method to store the file. Check the example. 

Retrieve file in Database
This is same as retrieving the image from the database though the method for retrieving changes from getBlob() to getClob(). We use fileWriter in it. Check example. 
Callable Statement
To call the stored procedure and the functions, collableStatement interface is used. Stored procedures are the SQL queries which are given a name and stored in the database in the precompiled form and hence can improve the efficiency. Also, suppose you need the age of an employee by giving a name so you have created a function that takes the name and returns the age. This is a function. 
Difference between stored procedure and function
1.	SP is used to perform business logic while F is used for calculation. 
2.	SP must not have a return type while F must have a returntype.
3.	SP may return zero or more values while it returns only one value. 
4.	We can call F from SP but cannot call SP from F.
5.	SP support input and output parameter while F supports only input parameter.  
6.	Try catch can be used in SP but not in functions. 
To create an instance of the callable statement, we should use prepareCall() method of the connection interface. The syntax is: “CallableStatement cs = con.prepareCall(“Call procedureName(?,?,?....)”)”. 
Practice a detailed example after having JDBC and database. 
Note: Outer parameters are those which can either return data or the cursor variable where this cursor variable is the result retrieved one row at a time. 
Transaction Management in JDBC 
A transaction represents a single unit of work. ACID describes the transaction management very well. It stands for Atomicity, Consistency, Isolation and durability. Atomicity means either all successful or none which means that a set of SQL statements either all or none gets executed because partial change is dangerous. Consistency means bringing database from one consistent state to other. Isolation means one transaction is isolated from other. Durability means once a transaction has been committed it will remain so even in the events of error, power loss etc. 
The main advantage of maintaining a transaction is that it increases the speed. The collection interface consists of methods of transaction like commit, rollback etc. In the example, we have just used the commit() method called by the object of connection interface. Check the example in detail. 

Batch Processing
Instead of executing single query, we try to execute many queries together to improve the efficiency. It makes the performance faster. In this, we use the addBatch() method of the statement class to add a query in the batch. Then, we use executeBatch() method of execute the queries added in the batch together. Try the example. 


=====================================================================================
Java Miscellaneous small topics  

|Generics with Collections| [IIII]
Generics is a concept introduced in java 5 to allow types (variable) as a parameter of a method, class or interface. Example of it are ArrayList, Hashset and other classes. 
With generics, we get two major advanatges which are below:
1.	Protection from suprising runtime exception by providing compilation error. 
2.	No mandatory casting needed. 
Until java 1.4, we did not has the concept of java generics. Therefore, in collection everything is treated as the object type inside collection. We can add any type of non primitive element inside a collection. We will not get compilation error and those element will be added as object. At the time of getting value from collection, type casting is mandatory to the type to which we believe value is. Check code below:
		List list= new ArrayList(); //created collection in non generic style
		list.add(new Integer(1)); //added Integer first
		list.add("String"); //added String second
		String element = list.get(1); //compilation error
		String element1 = (String) list.get(1); //no compilation error as type casting is done
		String element2 = (String) list.get(0); //class cast exception, as get(0) returns integer 
So, the problem with non-generic collection is that we are can add any element to the collection and may caught by a suprising class cast exception and second, we are forced to do casting while getting element from collection. 
From java 1.5, the concept of generics was introduced to overcome these problems along with other benefits. 
List<String> list= new ArrayList<>(); //created collection in non generic style
		list.add(new Integer(1)); //compilation error, since we are adding integer
		list.add("String"); //can add string with no problem
		String element2 = (String) list.get(0); //no need of casting
We will get compilation error if try to add element of other type as mentioned while creating a collection protecting from classcast exception at runtime. Secondly, no casting needed while getting value from collection.
 
Sub Types in Generics: 
Sub types are not allowed in generics. This means you cannot assign or pass as argument a List<String> to List<Object> while you can assign or pass as argument a String to or in place of object. If tried so, it will give compile time error. This is not allowed because we would have added incompatible type of data to the collection otherwise through having generic type. Check the code below:
List<String> list = new ArrayList<>();
		List<Object> list1 = list;  //gives compile time error
List<Object> list2 = new ArrayList<String>(); // gives compile time error
		String s = new String("Rishav");
		Object o = s;				//does not give compile time error  
However, a list of object can be used to add different type of object since ultimately we are adding the object and satisfying the contract. Check the code below:
		List<Object> list1 = new ArrayList<Object>();
		list1.add("String");
		list1.add(new Integer(1));
		list1.add(new Boolean(true));
Note: 
1.	As we have seen we can add any type of object like String, Integer or other in the List of object (List<Object>) then will that not give runtime error when we try to get element from collection like Integer I = list.get(0)? It will actually give compilation error since we are expecting integer from Object list. We can get the element like Object o = list.get(0);
2.	Generics mai kuch bhi nahi daal sakte. Jo pehle bola hai wahi daloge warna compilation error milega. To jab nikalte ho to sure hote ho ki kya niklega. Isliye class cast exception nahi milta.

WildCards in Generics collection
This ? wildcard is used in method signature like “MethodName(List<?> list)” meaning “a list of any type can be received”. “?” is the wildcard in generics which means unknown. Thus, List<?> means you can assign a list to any type of list. Here, I do not mean by adding any type element to the list. Check the code below:
List<Object> list1 = new ArrayList<Object>();
		List<?> list2 = new ArrayList<>();
		list2 = list1; 
		list2.add(1);  //this gives compilation error.
Here, we cannot assume the type of the list. The best we can do it so treat everything as object in the list. Using ? wildcard alone is a unbounded type of wildcard. 
Wildcard can be bounded as well. Like, we have upper and lower bound wildcard. 
The upper bound wildcard is List<? Extends SomeClass> which mean “a list of any type of sub type of someclass and of someclass”. We can assign a list of itself or its subclasses.
List<? extends Number> numbers = new ArrayList<>();
		List<Integer> list = new ArrayList<>();
		list.add(1);
		numbers = list; 
		Number n = numbers.get(0);
We can read any object as SomeClass object only because the retrieved element could be of any possible subtype. We cannot add anything in it, not even Someclass object. This is if collection is of any sub type than adding object of someclass (could be any other sub type) is not valid. It will involve downcasting which is not automatic in java.  
List<? extends Number> numbers = new ArrayList<>();
		numbers.add(1);  // we cannot add to it 
		List<Integer> list = new ArrayList<>();
		list.add(1);
		numbers=list;
		Number n = numbers.get(0);  //read the value as Number  
The lower bound wildcard is List<? Super SomeClass> which means “a list of any type of super type of someclass and of someclass”. Now, we cannot predict the type which will be super type of the given SomeClass expect Object class thus while reading we can only read the element as object. Check the code below:
List<? super Integer> integers = new ArrayList();
		List<Object> list = new ArrayList<>();
		integers = list; 
We can add an element of someClass type only because ? will definitely be a someClass as it is super type. However, we cannot add an element of any of the superclass since we superclass object could actually be subclass object of some other type. We cannot read anything from it, not even the someclass object because if we get its super class object (could be sub type of another type) then downcasting need to be done which is not automatic in java.  
			List<? super Integer> integers = new ArrayList();			
			integers.add(1);  //wrote as integer
			Object o = integers.get(0);  //read a object	
Note: 
1.	Why cannot we use List<Object> instead of using List<?>. List<?> can be assigned List of anything while List<object> can only be assigned list of object not the list of any other type as sub typing is not allowed in generics. 
  
Type Identifier (Generics Type Parameter): 
We can write generic classes and method through Type Identifier “T”. A generic class can be created as public class<T> and a generic method as “public static T void ClassName”. 
A class that can refer to any type is known as generic class. Like, class of employees is Employee. Employee class will have object of employee however when I create a generics class then it can create object of anything which we put in <here>. Look at the code below for proper understanding:
class MyGen<T>{  
T obj;  
void add(T obj){this.obj=obj;}  
T get(){return obj;}  
}  
 
class TestGenerics3{  
public static void main(String args[]){  
MyGen<Integer> m=new MyGen<Integer>();  
m.add(2);  
//m.add("vivek");//Compile time error  
System.out.println(m.get());  
}}  

A generic method is the one that can accept any type of argument. Here, a method printArray() can print array of int as well as string. 
public class TestGenerics4{  
   public static < E > void printArray(E[] elements) {  
        for ( E element : elements){          
            System.out.println(element );  
         }  
         System.out.println();  
    }  
    public static void main( String args[] ) {  
        Integer[] intArray = { 10, 20, 30, 40, 50 };  
        Character[] charArray = { 'J', 'A', 'V', 'A', 'T','P','O','I','N','T' };  
  
        System.out.println( "Printing Integer Array" );  
        printArray( intArray  );   
  
       System.out.println( "Printing Character Array" );  
        printArray( charArray );   
    }   
}

Note: 
1.	Generic Interface: We can have generic interfaces just like generics class.
2.	Multi bound WildCard: It is possible to write multi bounded generics as well in java which is something like this “SomeClass<? extends Class1 & Class2>”. 
3.	Type Erasure: Through type erasure compiler erases all the generics related information before runtime. However, there can be exception where runtime can have generics type parameter information. Only when class is generics then its detail reached to runtime. 
4.	Generic classes and interfaces can also be called as parameterized classes and interfaces. Base type in generics will be called as the class which we are passing generic type parameter too. 
5.	Using T character as type parameter is not mandatory and thus we can use any valid java identifier. T is just as it is first letter of Type parameter. 
6.	It is pretty much allowed to use multiple type parameter separated by comma while defining a generic class. Simple example: HashMap. 
7.	Inheritance is not applicable on generics. This means List<String> is not sub type of List<Object>.
8.	Generics is also for static as well as instance method.  Also, it is applicable to constructors. 
9.	We cannot use “?” just like we use “T”, but can use “T” where we can use “?”. T can be making type as variable for anthing while “?” is for making type variable for data type of any collection. We can use extend and super with T as well.  

|Why use Generics?| 
In this section, we will understand the advantages we get using generics in our code. Generics has three main advantages which are described below. 
1.	Type Safety (Stronger type check at compilation) – Here, “Type” signifies the type of the object. In absence of generics, we create collection without specifying the type of object. When we will be using the add() method to join the collection. Then, we will be asked for the type of the add() method based on the data type we want to insert. Though, we can add different type of data as well.   
2.	No Casting needed: If you are using generics then no casting needed for generic code since we are making what type of data we are dealing with before hand. 
3.	Datastructure gets friendly to be used: It generics the already existing algorithms can be changed to generic version and will become quite easier to read and deal with. One good example collection classes. 
Must check the generics in collection section in Collection. 

||Serialization|| [IIII]
(Super Article: http://www.oracle.com/technetwork/articles/java/javaserial-1536170.html. 
https://stackoverflow.com/questions/817853/what-is-the-difference-between-serializable-and-externalizable-in-java )
In simple words, Serialization is a process of converting the state of an object into a byte stream. The reverse process of getting back the object state from the byte stream is called as deserialization. The byte stream created will be platform independent. 
Now, we will see how can we actually serialize and deserialize programmatically. We have serializable marker interface which need to be implementated by the class whose object need to be serialized. To actually serialize an object we can use writeObject method of ObjectOutputStream implementation class. For getting back the state of the object we can use readObject() api of ObjectInputStream implementation class which literally reads the raw bytes of the object. Behind the scene, these method uses reflection will be used to figure out how to marshal and unmarshal the object. At the time of reading, casting needs to be done since it can read any object from the stream. 
So far so good. Now, in a situation, where we have a reference of another class (not talking about parent class) which does not implements serializable interface is present in our class then would that be a problem? Yes. In this case, we will receive NotSerializableException. However, a simple solution to it is to make that reference as transient. Making a var transient indicates the virtual machine to not include that variable in serialized state of the object. 
SerialVersionUID
Concept of SerialVersionUID: During serialization, an id is assigned to a class whose object is getting serialized and this id is used to verify if the correct object deserialized through the same version id. By default this is provided my JVM however we can give custom SerialVersionUID using "static final long serialVersionUID=42L". We can have any access modifiers while we must ahve long data, static and final. Private access modifier is more recommended as it is definitely not useful for child classes. As we know that if we do not give our own serialVersionUID then JDK has a tool serialver which create the serialVersionUID. To generate serialVersionUID, we need to hover over the class name and then we can see option to generate serialVersionUID. 

Customizing Serialization
Would you ever want to customize serialization or deserialization process? Let’s assume that we are serializing a class that starts a thread from its constructor to perform its sole functioning. Like, an animation class which do some animation as soon as its instantiated. While serializing, the process is normal. However, when you deserialize the object then you are restoring the state of the object while not creating the object via calling the constructor. Thus, even your object needed is created does not perform animation as its constructor is called. In this secanrio, you might want to customize the serialization and deserialization process. This is just one scanrios, however there could be many scenarios where you might want to customize the serialization process.
To customize or, better to say, to add something to the existing serialization process we can write a couple of private methods writeObject() and readObject() in our class. These are private method and thus it mean they are not inherited, overridden or overloaded. The trick here is that JVM can access the private method of a class. Now, when we do the serialization of this class then JVM checks for these special private methods. In this example, these methods can all the method written in the ObjectOutputStream class which will first carries out the normal serialization or deserialization process and then adds the code that we need to execute additioning to the serialization of the class.  
Serialzation uses reflection behind the scene and which was very slow in the initial version of java and thus especially serializaing heavy objects or graphs use to affect the performance. Therefore, designers of java felt the need to provide interface to let developer have their own implementation of serialization. Therefore, Externalizable interface was introduced. Thus, this is to enable the completely  handling the serialization process. 
Externalizable Interface in serialization
Externalizable interface extends the serializable interface. We can have custom serialization by using Externalization interface. Here, customized serialization means changing the way object is converted to string, format or other things. This way we control the data member of the serialized object sent and received. Also, we can provide some integrity to the data of the object through externalization interface. 
For using Externalizable interface, we have to make our class implement the Externalizable interface and have to override writeExternal() and readExternal() methods. Now, when we try to serialize the data in the usual way then when we write our class object to ObjectStream through writeObject() then the overridden method of writeExternal is called. Thus, only the way that serialization is customized the object gets serialized. Also, since the Externalizable interface extends the serializable interface thus implementing Externalizable interface is sufficient. 
Also, when using Externalizable interface, creating non args constructor is mandatory. This is because in externalization, the deserialization does not happens like leterally reading the byte stream back to construct the object like in serialization. However, first the object of the class is created and this its state is restored. Thus, have a public non args constructor is mandatory. 

Note: 
1. Do we need to override any method in normal serialization process? Since, serializable interface is a marker interface that is used to mark that class to be able to get serialize thus we does not has any method to override. Other marker interface example are clonable or remote. 
2. Parent Child Serilization observation! If parent class has implemented the seriabizable interface then child does not need to repeat. But if child class wants to be non serializable intentionally then we can use the private readObject and writeObject methods and will just throw the NotSerializableException. 
3. Does serialization works for static members? Only instance data members can be saved using serialize process. While it does not work for static data members and transient instance member. 
4. Serialization of collection! Although all collection classes implements serializable interface however the object stored in them should too be serializable to serialize the collection classes. Also, since serialization is costly thus avoid serializing entire collection.
5. Need of constructor for Serialization and Externalizatino! Constructor of object is never involved or called during deserialization using serializable interface. While in Externalization, no args constructor is mandatory. 
6. We have a class that we have serialized and kept the bit safe in a file. Now, we have made change to the class. So, would the earlier serialized bits hold good as we have changed the base class? There can be different type of changes that we can make to the class which are classified as compatible and non compatible changes. Compitable changes like adding a new field to the class does not make already existing serialized version incompatible while incomptiable changes like making a field from static to non static or vice versa will make existing serialized version incompatible. Also, when we try to deserialze as incompatible serialized version then we get invalidClassException.
7. In Serialization, we can override validateObject() method of ObjectInputValidation interface to provide some validation to make sure the data integrity is not harmed. 
8. Does the order of member matters for serialization? The order of variables is very important in serialization. Wether you are having private readObject and writeObject method or other, the order of the members must be same.
9. Serialization poses great security risk because an attacker can change the byte stream and can attack. Like, it can change the normal user to admin user by changing the stream of the user object. Therefore, Serialization proxy pattern is used to achieve security against security threat due to serialization. Please go in depth as and when needed. 
10. Do not only consider the use case of serialization as transferring the state of the object. However, this could majorly to store the state of the object in the form of bit stream and to create the exact same object to use whenever needed.
11. Serialization does not care about the access modifiers. It serializes everthing except static and transient. 
12. Externalization mostly be used for getting some integrity to the object serialization and not majorly because of controlling what member to be used while serializing. For this purpose, transient keyword is quite sufficient. Also, to efficiently carry out serialization and to avoid extra over head like parent and other class level serialization. Child containing parent instance or other class instance do get serialized upto object class level. Wheverver performance is of primary importance then prefer writing your own serializer which can bring serialization time 50% or less.
13. Object serialized gets cached in the stream while not written anywhere. If their state changes and we again serialize them then their state does not overrides in the stream until they are not flushed out  of stream. This can be handled by calling close method immediately on the stream so that it writes the object somewhere. The other way is to call the reset method of the stream. However, reset method flushes all the object present in the stream thus be careful. 
14. After Deserialization, the members which were not serialized because being transient are given default value. Static member get the latest value as we get Class.staticMember and not the default for static. Non static non serializable user object of other class give notSeriablization exception. We can make them transient to avoid exception.
15. If a class has method of ObjectStream and Externalization interface then the precendence to methods of Externalization will be given over ObjectStream class and readObject and writeObject will not execute.   


||Java Date related classes||
We will discuss some important classes and packages to deal with date and time in java. The basic class is the Date class which is in java.util package. Apart from Date class, we will also look into classes like SimpleDateFormat, DateFormat and Calender Class. 
Date Class:
With a simple date class object we can print the current date and time till millisecond precision. The Date class is provided in util package and it implements the serializable, clonable and comparable interfaces. This class has different constructor and APIs to play with date. Although, this class method of  the APIs are not sufficient to format the class. We have other classes for it. Lets look on them. 

1.	SimpleDateFormating Class:
This class helps in formatting and parsing the data. So, we can play with the format of the date and also interpret string date format into Date objects.
		SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yy, hh:mm:ss");
		System.out.println(sdf.format(date));

2.	Formatting using the DateFormat class.
DateFormat class is an abstract class which is parent class of SimpleDateFormat class and has parent class as Format Class. It has different static final datamembers like LONG, MEDIUM and SHORT which can be used to format the string instead of giving a format ourselves. 
DateFormat df = DateFormat.getInstance();
		System.out.println(df.format(date));
		DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT);
		System.out.println(df.format(date));
3.	Calendar class
Generally, Caldendar class is used for adding or subtracting anything from the current time or from a given time. Below is a sample code for increasing 5 minutes from the current time.
		Calendar c = Calendar.getInstance();
		c.setTime(date);
		c.add(Calendar.MINUTE, 5);
		System.out.println(c.getTime());

Note:
1. SimpleDateFormat and DateFormat are the part of java.text package while Date is of java.util package.
2. DateFormat seems to be a singleton class as we get its instance using getInstance() method. 
Below are the pending programs to cover for this:
Actions: 1. Printing the date, 2. Changing the format, 3. Getting date, day, year and other parts individually, subtracting the date. 

||Java Version features|| [IIII]
|Java 5 features|
Generics, concurrent package, var args, static import, Autoboxing, enhanced for loop. 
|Java 6 features|
JDBC 4.0, Many new annotations.
|Java 7 Feature|
a.	Multi-Catch Exception – Before java 7, we have to write a separate block for each category of exception. Shorten the traditional coding practice. Writes from specific to generic exception. [III] Also, we cannot have exception of sharing parent and child relation in same block since parent already covers child. Check the example.
b.	Try-With-Resource – We used to place the code related to resource opening in try block (file, db connection, socket connection) and close them in finally block. HOwever, if we forget to close then in finally then it will cause memory leak. THus, java 7 can with a better coding practice. We can use try with resouce. Here, we will open the resource in as an argument in try block. Thus, we do not need to write additonal finally block just for closing the resources and resource closing will automatically be handled. 
c.	Diamond Operator – This is for DRY coding. Removes the effort for repeating type. 
List<String> list = new ArrayList<String>();// usual way
List<String> list1 = new ArrayList<>(); //java 7 way to promote DRY coding practice. 
d.	Underscore in Literals – For better readability and grouping the digits in java. Check the code below which has output as 100100.
long a = 100_100;
		System.out.println(a);

e.	String in Switch statements: Before java7, we could use int, short, char and byte. We could have used wrapper class version of these as well. With java 7, we can now also use String in the switch case statement.
f.	Binary Literals – Can express any literals (int, long, short, byte) using binary code with a prefix 0b/0B. Code for int 2 is “10”. So, we can represent int 2 as “0b10”. It will print 2. Check the code below:
long a = (long) 0b0110L;
System.out.println(a);	
g.	Imporved compiler warning and error when using refieable formal parameters with varargs method

Note: 
1.	[NNN] We cannot catch an exception along with its super class in same multi catch. Also, we can catch a checked exception if we explicitly throw it or a called method throws it.
2.	[NNN] We have to even instanciate the resource inside try block. We cannot instanciate it before. 

|Java 8 Features|
1. Lambdas Expression
Lambdas expression is one of the exciting feature of java 8 which lets you implement the method of a fucntional interface. Function interface is an interface which has just one abstract method. Before lambdas expression, we generally implement method of the functional interface using annonymous class. With Anonymous class, an extra class file will be created while with labda expression no extra class is created. Also, lambda expression reduces the line of code.  
Check the syntax: {(no. of arguments)->implementation logic}
Lets see one example of usage of lamba expression. To iterate, filter and sort the collection
[III]Iteration of collection:
list.forEach(i->System.out.println(i));
Now, we have forEach method of Iterable interface introduced in Java 8 which takes the argument of accpet method of consumer functional interface. Therefore, we are providing the implementation as the argument of forEach method. accept method takes the argument of list data type. 
Sort the Element:
Collections.sort(list, (i1, i2)->return i1.compareTo(i2));

2. ForEach() – This method is used to iterate a collection entries and accept arugment as accept method of consumer interface. Consumer and game class. We need to make an annonymous class by overriding the accept method. Also, we can use lambdas function. 

4.	Default and Static methods in Interface
Prior to java 8, we can have only public abstract method in an interface. In this situation, if we add a new method to an interface then all the implementing class must have to implement it. In case, the implementing class are thousands then it will be a huge task. Therefore, to add new methods to already existing interfaces with complete backward compatibility, we have default and static methods in java. 
From java 8, we can have interfaces with method implementation by using default or static keyword with its signature. One good example of this feature is forEach() method of Iterator class. Static method can direcltly be used through the interface name while for using default method we need instance of the interface which we can get through anonymous class or through lambdas expression. Also, we can override the default method of interface while cnnot override the static methods.  
Now, if interfaces have implementation of the methods then they can also cause diamond case problem. The solution is that if diamond case problem occuers then a compile exception will occur pointing if that the same default method with the same arugment exist in multiple super interface and that method need to be implemented in the child class. Thus, multiple inheritance (implementing multiple interfaces) is still possible.

4. Java Stream Package. 
In Java 8, a new package java.util.stream is added altogether which contains a lot of classes and interfaces. We basically can do a lot of things using the API inside this package like creating internal iteration, sequiential and parallel execution, filtering and other. In short, we can do a lot processing on the data stored in different datastructures like array, collections and other. Stream APi generally work in a functional style and thus quite suitable for lambdas expression. The main purpose for this package is for working with bulk data operations with a little ease and less lines of code.
Some common interfaces of stream API are Function, BiFunction, Predicate, BiPredicate, Comsumer, BiConsumer and other. Find out there purpose if needed. 
For practice, we can look at how to create a stream of different kind in different ways? How to perform certai actions like iteration, filtering or sorting of elements of collection using steam API?
Stream API seems have a lot of depth. But, we are leaving it here. 
Note:
1.	Stream package has an interface StreamBase which is implemented by four classes. First by a generic stream class through which a stream of any object type can be created. Besides this, three primitive streams can be created which are intStream, DoubleStream and LongStream.
2.	If we use a string second time then it give illegal state exception. Like, We frist create a string, then iterate it and then try to create list back fom the stream. Then, while we try to create a list of stream, we will get illigalstate Exception. 

5. Spliterator 
Spliterator is another iterator which is introduced in java 8 for iterating elements of collection and streams while cannot iterate map. It can support parallel programming. It can do sequential or parallel processing or iteration. 
It is quite similar to forEach() style of iteration since it also support use of lambdas. Spliterator interface has three important method which are below:
1.	ForEachRemaining(): For iterating the element in sequential style. 
2.	tryAdvance(): To iterate element individually in multi threads. 
3.	trySplit(): to split the spliterator and allow parallel processing. 
It has a lot of depth and hence we will do it when needed. 
5. We have another new package in java 8 which is java.time package which has a lot of different sub packages like java.time.format and java.time.zone. 

|Java 9|
This was released back in sept 2017.
1.	Jshell
2.	Private methods in interface
3.	New HTTP 2 API for supporting HTTP 2
4.	Stream API improvements
5.	Module System (java will have module and we can create our own too)

Note: Java 10 was release in Mar, 2018. While, java 11 was release in Sept, 2018 and also, java 12 is planned to be released by Mar, 2019. 

||Enumeration or Enum|| [IIII]
Enumeration in java is a group of named constants which came as a part of java 5 changes. Examples of enums could be planets, days of week etc. [III] Enums can be written inside or outside a class but not inside a method. The members of an enum are suggested to written in upper caps. Enum is treated as the data type in itself.  Below is the code for using enum:
enum choices{
	FIRST, SECOND, THIRD, FOURTH;
}
public class Class1{
	public static void main(String[] args){
		choices c1 = choices.FIRST;
		System.out.println(c1 instanceof choices);
	}
}
In the above example, output comes as true. 
Note:
1. Internally, every enum is just like a class which has private static final members which are mentioned in enum like below.
/* internally above enum Color is converted to
class Color
{
public static final Color RED = new Color();
public static final Color BLUE = new Color();
public static final Color GREEN = new Color();
}*/
2. Every enum type represents an object of enum type. Thus, we get true in the above example. 
3. We can use Enum type in switch statements. 
4. We can write main method inside enum and thus can invoke enum from cmd. This was we can have two main method in a class but not literally. One will be in enum and other will be in the class. 
5. Every enum extends java.lang.enum class and thus cannot extend any other class. Though can implement any number of interfaces. 
6. java.lang.enum class overrides toString() method which returns enum name.
7. Values(), ValueOf() and ordinal() methods of enum class can be used. 
public class Class1{
	enum choices{
		FIRST, SECOND, THIRD, FOURTH;
	}
	public static void main(String[] args){
		choices c1 = choices.FIRST;
		//using values() for getting al the values of enum
		choices[] choiceArray = choices.values();
		
		//using ordinal() for showing index of an element
		for(choices c: choiceArray){
			System.out.println(c+ "is at index "+c.ordinal());
		}
		
		System.out.println(choices.valueOf("FIRST"));
	}
}

||Varargs||
Varargs was introduced in java 5. This features was introduced to provide ease in creation of methods which accept variable arguments and varargs is short form for variable arguments. Before varargs, variable arguments was handled using overriding i.e. by having the method form for each set of arguments or by accepting arguments as array of arguments. However, both the ways are quite lengthy. The varargs is specified by three periods like “…”. With vargars, compiler gets to know that this method can have zero or more arguments. Also, varargs should be the only for a single data type at a time and comes as last argument. We can have only one varargs in a method as it has to be the last argument. We can have any number of argument before varargs in a method. Most importantly, we have to treat varargs as array of argument to use it. Check the example for better understanding.  
public void method(String ...varargs) {
		String[] arguments = varargs;
	}

||Internationalization and Localization||
Internationalization is abbreviated as I18N since there is 18 alphabet between I and N in the word Internationalization. It is mechanism to create such an application that are adaptable in different languages and regions. It makes an application to response messages, currencies, date, time etc in the differently for different regions. 
Localization is abbreviated as I10N since there is 10 alphabet between I and N in the localization. It is a mechanism to create or enable an application for a particular language or region by adding local specific messages or components. 
Java has locale class in util package whose object will be specific to a specific location or language. This class has dfferent fields which are different locals like Canada, French or France etc. Below is simple example of usage of locale class:
Locale locale=Locale.getDefault();  
//Locale locale=new Locale("fr","fr");//for the specific locale  
System.out.println(locale.getDisplayCountry());   
Below is the code for creating a locale object for a specific location:
Locale frLocale = new Locale("fr", "FR");

||What do you understand by Advance Java|| [IIII]
Core java comporises of core concept of java as a language while Advance Java technologies are extensions of java to provide solution to specific problem. Java Servlet, JSP, JDBC, JMS and many other comes under advance java. Also, if we check the package naming convention then java extensions or advance java topics has packages like javax.servlet, javax.jsp, javax.jms with some exceptions.   

||Reflection|| [NNN]
Implementations
I have created this section for the sole purpose to speak about the implementation of what we have learned in this tutorial. We must use as many practical examples as we can related to the real world.  














































1. Core Java Programming Introduction of Java
Introduction to Java; features of Java 
Comparison with C and C++
Download and install JDK/JRE (Environment variables set up)
The JDK Directory Structure
First Java Program through command prompt
First Java Program through Eclipse
2. Data types and Operators
Primitive Datatypes, Declarations, Ranges 
Variable Names Conventions
Numeric Literals, Character Literals
String Literals
Arrays(One dimensional; two- dimensional)
Array of Object References
Accessing arrays, manipulating arrays
Enumerated Data Types
Non-Primitive Datatypes
Defining a class, variable and method in Java
Method Signature; method calls
Expressions in Java; introduction to various operators
Assignment Operator
Arithmetic Operators
Relational Operators
Logical Operators
Conditional Operators
Operator Precedence
Implicit Type Conversions
Upcasting and downcasting
Strict typing
Type conversion
3. Control Flow statements
Statements and it's various categories in Java
if, if-else, if-else-if 
switch case
for statement (both flavours traditional and enhanced for)
while and do-while loops
The continue Statement; labelled continue statement
The break Statement; labelled break statement
return statement
4. OOPS and its application in Java
Classes and Objects
Defining a class;Defining instance variables and methods
Creating objects out of a class
Method calls via object references
Abstraction
Interfaces and Abstract classes 
Abstract and non-abstract methods
Inheritance 
extends and implements keywords in Java
Super class and Sub class
this keyword, super keyword in Java for inheritance
Concrete classes in Java
Polymorphism
Compile time polymorphism -- Overloading of methods
Run time polymorphism -- Overriding of methods
Method  Overriding rules and method overloading rules
Introduction to Object class and it's methods
Encapsulation
Protection of data
Java Bean, POJO
Getters/Setters
Memory management in Java
Heap
Stack
5. Packages
Need for packages
What are packages; package declaration in Java
Import statement in Java
How do packages resolve name clashes?
6. Miscellaneous
Var-Args
Reference variables, local variables, instance variables
Memory allocations to variables
Double equals operator(==) operator for primitives and objects
toString() method on an object
7. Statics
Static variables and methods
Static imports
Static initialization blocks; instance intialization blocks
Static concept in inheritance
8. Constructors
What are Constructors?
Properties of Constructors
Default and Parameterized Constructors
Rules for constructor implementation
Constructor Chaining
this call; super call for constructors
Constructors for Enumerated Data Types
Constructors concept for Abstract classes and interfaces
9. Exceptions in Java
What are Exceptions?
Need for exceptions
How can Exceptions be coded in Java?
API heirarchy for Exceptions
Types of Exceptions
Keywords in Exception API: try, catch, finally, throw, throws
Rules for coding Exceptions
Declaring Exceptions 
Defining and Throwing Exceptions
Errors and Runtime Exceptions
Custom Exception
Assertions
What are Assertions?
Enabling and disabling assertions in development environment
10. Strings in Java
What are Strings? 
String heap memory and Constant Pool memory
Immutability in Strings
String creation on heap and constant pool
Method APIs on String; operations on Strings
Mutability of String Objects - StringBuilder and StringBuffer
Splitting of Strings and StringTokenizer class
11. Collection Framework in Java
The Collections Framework 
The Set Interface
Set Implementation Classes
The List Interface
List Implementation Classes
The Map Interface
Map Implementation Classes
Queue Interface
Queue Implmentation classes
Utility classes
Sorting collections using utility methods
equals() and hashCode contract in Java collections
overriding equals and hashCode methods in Java
New Collections added in Java 1.6
Primitive wrapper classes and all its method APIs
12. Generics
Generics for Collections
Generics for class
Generics for methods
13. Input-Output in Java
What is a stream?
Overview of Streams
Bytes vs. Characters
Overview of the entire Java IO API
Reading a file; writing to a file usinf various APIs
Reading User input from console
PrintWriter Class
14. Serialization
Object Serialization
Serializable Interface
Serialization API
ObjectInputStream and ObjectOutput 
Transient Fields 
readObject and writeObject
15. Inner Classes
Inner Classes
Member Classes
Local Classes 
Anonymous Classes 
Static Nested Classes
16. Threads in Java
Non-Threaded Applications
Threaded Applications
Process based multitasking Vs Thread based multitasking
Thread API in Java
Creating Threads 
States of a Thread 
Sychronization for threads; static and non-static synchronized methods; blocks; concept of object and class locks 
Coordination between threads - wait, notify and notifyAll methods for inter-thread communication
17. Applets
What are applets?
Need for Applets 
Different ways of running an applet program 
Applet API heirarchy 
Life Cycle of an applet 
Even Handlers for applets, mouse events, click events
18. Swing GUI
Introduction to AWT 
Introduction to Swing GUI 
Advantages of Swing over AWT 
Swing API 
Swing GUI Components
Event Handlers for Swing
Sample Calculator application using Swing GUI and Swing Event handling
19. JDBC
What is JDBC; introduction 
JDBC features 
JDBC Drivers 
Setting up a database annd cretaing a schema 
Writing JDBC code to connect to DB 
CRUD Operations with JDBC 
Statement types in JDBC 
Types of Rowset, ResultSet in JDBC
20. Access Modifers in Java
What are access modifiers?
Default
Protected
Private
Public
21. Debugging of Java Programs in Eclipse.
ADVANCED JAVA Syllabus:
                                      Servlets and JSPs
1. Basics of a Web application
What is a web application? 
What is a web client and web server? 
How do client and server communicate? 
HTTP protocol basics 
HTML language basics 
What is a TCP/IP port, URL? 
Need for a Web Container
2. Web Container and Web Application Project Set up
To set up Tomcat Container on a machine 
To set up a Servlets JSP project in Eclipse 
To configure dependency of Servlet JSP APIs 
Web application project structure
3. Servlets
What are Servlets?
What can they do? Why are they needed?
How do Servlets look in code?
HTTP Methods; GET, POST, PUT, DELETE, TRACE, OPTIONS
GET/POST request; differences between the two 
Servlet Lifecycle 
Servlet Context and Servlet Config
Forwarding and Redirection of requests
4. Session Management
What is a session?
Why is it required?
How to get a session?
Session information passing between client and server
Sesssion information passing mechanisms - Cookies, Rewriting
How to destroy a session
5. JSPs
Introduction to JSP an dneed for JSPs
Basic HTML tags
JSP Lifecycle
6. JSP Elements
Scriptlets 
Expressions
Declarations
Significance of above elements and fitment into the JSP Lifecycle
What are Directives in JSP?
Page Directive
Include Driective 
Taglib Directive
7. JSP Tag library
JSP Standard Actions 
Expression Language
JSTL basics and it's usage
Need for Custom Tag Library
Custom Tag Library implementation
                                 Struts Framework (version 2.x)
1. Basics of MVC
What is MVC?
MVC Type1 and Type2 architecture
Why Struts framework? 
Struts 1 overview
Struts 1 and Struts 2 comparison
2. Struts 2 Architectutre
Architecture Diagram explanation of following components: 
Components of Model, Views and Controller in Struts Framework 
Interceptors 
Model/Action classes 
Value Stack 
OGNL 
Introduction to configurations; framework and application architecture
Declarative and Annotations configuration approaches
3. Struts 2 set up and first Action class
Download JAR files 
Struts 2 project build up and Configuration files
To build Action class 
To intercept an HTTP request via Struts2 framework using Action class 
Defining data and business logic in Action class
Preparing and Forwarding control to Views
4. Struts 2 Interceptors
What are Interceptors
Responsibilities of an Interceptor 
Mechanism of Interceptor calling in Struts 2
Defining Interceptors 
Defining Interceptor stacks 
Defining Custom Interceptors
5. Struts 2 Tag Library
Introduction to tag library of Struts 2 and it's usage
6. Struts 2 Validations
Validations using Validateable interface 
Workflow interceptor mechanism for validations 
Validations using Validateable interface 
Validation Framework introduction and architecture 
Validating user input with above two mechanisms
7. Struts 2 Tiles Frameworks
Introduction to Tiles in a page 
Struts2 Tiles framework introduction 
Defining tiles.xml file 
Configuring pages for tiles 
A complete Tiles example with Struts2
                                Hibernate Framework (version 3.x)
1. Introduction
What is ORM principle? 
Why ORM? 
ORM implementations
2. Hibernate Architecture
Introduction to Hibernate 
Hibernate Architecture
What are Peristent classes?
3. Hibernate CRUD
Setting up Hibernate project
Configuring all JARs and XML files
Setting up connection to DB using Hibernate
Performing basic CRUD operations using Hibernate API 
Object Identity; Generator type classes
Using SQL with Hibernate
Using HQL 
Using Criteria queries
4. Mapping Collections and Associations
To define sets, mas, lists in Hibernate
Association Mappings: 1. One to one
2 One to many 
3 Many to one 
4 Many to many
5. Hibernate Caching
What is caching? 
What are the types of caching in Hibernate? 
Explanation of various caching mechanisms in Hibernate
6. Using Hibernate Annotations (if time permits)
Sample example of using Hibernate Annotations
                                Spring Framework (version 3.x)
1. Introduction to spring
What is Spring?
Spring Architecture explanation and all it's components
2. Introduction to all modules of spring
Spring Bean Factory 
Spring Application Context 
Spring DI 
Spring AOP 
Spring Integration; Spring messaging, Spring JMS 
Spring MVC 
Spring DAO
3. Setting up spring
Setting up of Spring framework 
Download JARs 
Configure XML files
4. Dependency Injection
What is Dependency Injection?
How is it implemented using Spring Framework? 
Bean Wiring mechanisms in Spring
5. Spring AOP
What is Spring AOP?
Implementation of Spring AOP




https://www.quora.com/Which-is-the-best-library-in-Pune
